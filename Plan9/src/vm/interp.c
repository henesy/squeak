/* Smalltalk from Squeak4.5 with VMMaker 4.13.6 translated as C source on 11 December 2014 12:55:14 pm */
/* Automatically generated by
	CCodeGenerator * VMMaker-dtl.350 uuid: 2ad132b0-5fb3-4580-b5a8-29af12c3cb81
   from
	Interpreter * VMMaker-dtl.350 uuid: 2ad132b0-5fb3-4580-b5a8-29af12c3cb81
 */
static char __buildInfo[] = "Interpreter * VMMaker-dtl.350 uuid: 2ad132b0-5fb3-4580-b5a8-29af12c3cb81 " __DATE__ ;
char *__interpBuildInfo = __buildInfo;



#include "sq.h"
#include <setjmp.h>

#ifndef assert
 #include <assert.h>
#endif

#ifndef allocateMemoryMinimumImageFileHeaderSize
 /* Called by Interpreter>>allocateMemory:minimum:imageFile:headerSize: */
 /* Default definition if not previously defined in config.h */
 #define allocateMemoryMinimumImageFileHeaderSize(heapSize, minimumMemory, fileStream, headerSize) \
    sqAllocateMemory(minimumMemory, heapSize)
#endif

#ifndef sqImageFileReadEntireImage
 /* Called by Interpreter>>sqImage:read:size:length: */
 /* Default definition if not previously defined in config.h */
 #define sqImageFileReadEntireImage(memoryAddress, elementSize,  length, fileStream) \
    sqImageFileRead(memoryAddress, elementSize,  length, fileStream)
#endif

#ifndef error
 /* error() function called from Interpreter */
 /* Default definition if not previously defined in config.h */
 #define error(str) defaultErrorProc(str)
#endif

#ifndef ioMicroSecondClock
 /* Called by Interpreter>>primitiveMicrosecondClock and GC methods */
 /* Default definition if not previously defined in config.h */
 #define ioMicroSecondClock ioMSecs
#endif

#ifndef ioUtcWithOffset
 /* Called by Interpreter>>primitiveUtcWithOffset */
 /* Default definition if not previously defined in config.h */
 #define ioUtcWithOffset(clock, offset) setMicroSecondsandOffset(clock, offset)
#endif

#include "sqMemoryAccess.h"

sqInt printCallStack(void);
void defaultErrorProc(char *s) {
	/* Print an error message and exit. */
	static sqInt printingStack = false;

	printf("\n%s\n\n", s);
	if (!printingStack) {
		/* flag prevents recursive error when trying to print a broken stack */
		printingStack = true;
		printCallStack();
	}
	exit(-1);
}

/*** Constants ***/
#define ActiveProcessIndex 1
#define AtCacheFixedFields 4
#define AtCacheFmt 3
#define AtCacheMask 28
#define AtCacheOop 1
#define AtCacheSize 2
#define AtCacheTotalSize 64
#define AtPutBase 32
#define BlockArgumentCountIndex 3
#define Byte0Mask 255
#define Byte1Mask 65280
#define Byte1Shift 8
#define Byte1ShiftNegated -8
#define Byte2Mask 16711680
#define Byte3Mask 4278190080U
#define Byte3Shift 24
#define Byte3ShiftNegated -24
#define Byte4Mask 1095216660480U
#define Byte4Shift 32
#define Byte4ShiftNegated -32
#define Byte5Mask 280375465082880U
#define Byte5Shift 40
#define Byte5ShiftNegated -40
#define Byte6Mask 71776119061217280U
#define Byte7Mask 18374686479671623680U
#define Byte7Shift 56
#define Byte7ShiftNegated -56
#define Bytes3to0Mask 4294967295U
#define Bytes7to4Mask 18446744069414584320U
#define CacheProbeMax 3
#define CallerIndex 0
#define CharacterTable 24
#define CharacterValueIndex 0
#define ClassAlien 52
#define ClassArray 7
#define ClassBitmap 4
#define ClassBlockClosure 36
#define ClassBlockContext 11
#define ClassByteArray 26
#define ClassCharacter 19
#define ClassExternalAddress 43
#define ClassExternalData 45
#define ClassExternalFunction 46
#define ClassExternalLibrary 47
#define ClassExternalStructure 44
#define ClassFloat 9
#define ClassInteger 5
#define ClassLargeNegativeInteger 42
#define ClassLargeNegativeIntegerCompactIndex 4
#define ClassLargePositiveInteger 13
#define ClassLargePositiveIntegerCompactIndex 5
#define ClassMessage 15
#define ClassMethodContext 10
#define ClassPoint 12
#define ClassSemaphore 18
#define ClassString 6
#define ClassUnsafeAlien 54
#define ClassWeakFinalizer 55
#define ClosureFirstCopiedValueIndex 3
#define ClosureIndex 4
#define ClosureNumArgsIndex 2
#define ClosureOuterContextIndex 0
#define ClosureStartPCIndex 1
#define CompactClassMask 126976
#define CompactClasses 28
#define ConstMinusOne -1
#define ConstOne 3
#define ConstTwo 5
#define ConstZero 1
#define ContextFixedSizePlusHeader 7
#define CrossedX 258
#define CtxtTempFrameStart 6
#define DoAssertionChecks 0
#define DoBalanceChecks 0
#define Done 4
#define EndOfRun 257
#define ExcessSignalsIndex 2
#define ExternalObjectsArray 38
#define ExtraRootSize 2048
#define FalseObject 1
#define FirstLinkIndex 0
#define GCTopMarker 3
#define HashBits 536739840
#define HashBitsOffset 17
#define HashMaskUnshifted 4095
#define HeaderIndex 0
#define HeaderTypeClass 1
#define HeaderTypeFree 2
#define HeaderTypeGC 2
#define HeaderTypeShort 3
#define HeaderTypeSizeAndClass 0
#define HomeIndex 5
#define InitialIPIndex 4
#define InstanceSpecificationIndex 2
#define InstructionPointerIndex 1
#define InterpreterSourceVersion "4.13.6"
#define InvokeCallbackSelector 53
#define LargeContextBit 262144
#define LastLinkIndex 1
#define LiteralStart 1
#define MaxExternalPrimitiveTableSize 4096
#define MaxJumpBuf 32
#define MaxPrimitiveIndex 575
#define MessageArgumentsIndex 1
#define MessageDictionaryIndex 1
#define MessageLookupClassIndex 2
#define MessageSelectorIndex 0
#define MethodArrayIndex 1
#define MethodCacheClass 2
#define MethodCacheEntries 512
#define MethodCacheEntrySize 8
#define MethodCacheMask 4088
#define MethodCacheMethod 3
#define MethodCacheNative 5
#define MethodCachePrim 4
#define MethodCachePrimFunction 6
#define MethodCacheSelector 1
#define MethodCacheSize 4096
#define MethodIndex 3
#define MillisecondClockMask 536870911
#define MyListIndex 3
#define NextLinkIndex 0
#define NilContext 1
#define NilObject 0
#define PrimErrBadArgument 3
#define PrimErrBadIndex 4
#define PrimErrBadNumArgs 5
#define PrimErrNoMemory 9
#define PrimErrTableIndex 51
#define PrimitiveExternalCallIndex 117
#define PriorityIndex 2
#define ProcessListsIndex 0
#define ProcessSignalingLowSpace 22
#define ReceiverIndex 5
#define RootTableRedZone 2400
#define RootTableSize 2500
#define SchedulerAssociation 3
#define SelectorAboutToReturn 48
#define SelectorCannotInterpret 34
#define SelectorCannotReturn 21
#define SelectorDoesNotUnderstand 20
#define SelectorMustBeBoolean 25
#define SelectorRunWithIn 49
#define SelectorStart 2
#define SemaphoresToSignalSize 500
#define SenderIndex 0
#define SpecialSelectors 23
#define StackPointerIndex 2
#define StartField 1
#define StartObj 2
#define SuperclassIndex 0
#define SuspendedContextIndex 1
#define TempFrameStart 6
#define TheDisplay 14
#define TheFinalizationSemaphore 41
#define TheInterruptSemaphore 30
#define TheLowSpaceSemaphore 17
#define TheTimerSemaphore 29
#define TrueObject 2
#define TypeMask 3
#define Upward 3
#define ValueIndex 1
#define XIndex 0
#define YIndex 1

/*** Function Prototypes ***/
sqInt activateNewClosureMethod(sqInt blockClosure);
sqInt activateNewMethod(void);
#pragma export on
EXPORT(sqInt) addHighPriorityTickee(void *ticker, unsigned periodms);
EXPORT(sqInt) addSynchronousTickee(void *ticker, unsigned periodms, unsigned roundms);
EXPORT(sqInt) addGCRoot(sqInt *varLoc);
#pragma export off
sqInt addNewMethodToCache(void);
sqInt addToExternalPrimitiveTable(void (*functionAddress)(void));
sqInt addressCouldBeObj(sqInt address);
sqInt adjustAllOopsBy(sqInt bytesToShift);
sqInt allYoungand(sqInt array1, sqInt array2);
sqInt allocateChunk(sqInt byteSize);
sqInt allocateOrRecycleContext(sqInt needsLarge);
#pragma export on
EXPORT(sqInt) amInVMThread(void);
#pragma export off
sqInt argumentCountOf(sqInt methodPointer);
void * arrayValueOf(sqInt arrayOop);
sqInt asciiOfCharacter(sqInt characterObj);
sqInt balancedStackafterPrimitivewithArgs(sqInt delta, sqInt primIdx, sqInt nArgs);
sqInt beRootIfOld(sqInt oop);
sqInt beRootWhileForwarding(sqInt oop);
sqInt becomewith(sqInt array1, sqInt array2);
sqInt becomewithtwoWaycopyHash(sqInt array1, sqInt array2, sqInt twoWayFlag, sqInt copyHashFlag);
sqInt biasToGrow(void);
sqInt booleanValueOf(sqInt obj);
sqInt byteSizeOf(sqInt oop);
sqInt byteSwapByteObjectsFromto(sqInt startOop, sqInt stopAddr);
sqInt byteSwapped(sqInt w);
sqInt callExternalPrimitive(void (*functionID)(void));
#pragma export on
EXPORT(sqInt) callInterpreter(void);
EXPORT(sqInt) callbackEnter(sqInt *callbackID);
EXPORT(sqInt) callbackLeave(sqInt cbID);
#pragma export off
sqInt changeClassOfto(sqInt rcvr, sqInt argClass);
sqInt characterForAscii(sqInt ascii);
sqInt characterTable(void);
sqInt checkForInterrupts(void);
sqInt checkImageVersionFromstartingAt(sqImageFile  f, squeakFileOffsetType  imageOffset);
sqInt checkedIntegerValueOf(sqInt intOop);
sqInt checkedLongAt(sqInt byteAddress);
sqInt classAlien(void);
sqInt classArray(void);
sqInt classBitmap(void);
sqInt classByteArray(void);
sqInt classCharacter(void);
sqInt classExternalAddress(void);
sqInt classExternalData(void);
sqInt classExternalFunction(void);
sqInt classExternalLibrary(void);
sqInt classExternalStructure(void);
sqInt classFloat(void);
sqInt classLargeNegativeInteger(void);
sqInt classLargePositiveInteger(void);
sqInt classNameOfIs(sqInt aClass, char *className);
sqInt classPoint(void);
sqInt classSemaphore(void);
sqInt classSmallInteger(void);
sqInt classString(void);
sqInt classUnsafeAlien(void);
sqInt clone(sqInt oop);
sqInt commonAt(sqInt stringy);
sqInt commonAtPut(sqInt stringy);
sqInt commonVariableatcacheIndex(sqInt rcvr, sqInt index, sqInt atIx);
sqInt compare31or32Bitsequal(sqInt obj1, sqInt obj2);
sqInt compilerCreateActualMessagestoringArgs(sqInt aMessage, sqInt argArray);
sqInt compilerFlushCache(sqInt aCompiledMethod);
sqInt compilerMapFromto(sqInt memStart, sqInt memEnd);
sqInt compilerMark(void);
sqInt compilerPostGC(void);
sqInt compilerPostSnapshot(void);
sqInt compilerPreGC(sqInt fullGCFlag);
sqInt compilerPreSnapshot(void);
sqInt compilerProcessChange(void);
sqInt compilerProcessChangeto(sqInt oldProc, sqInt newProc);
sqInt compilerTranslateMethod(void);
sqInt containOnlyOopsand(sqInt array1, sqInt array2);
sqInt contexthasSender(sqInt thisCntx, sqInt aContext);
sqInt copyBits(void);
sqInt copyBitsFromtoat(sqInt x0, sqInt x1, sqInt y);
sqInt copyObjtoSegmentaddrstopAtsaveOopAtheaderAt(sqInt oop, sqInt segmentWordArray, sqInt lastSeg, sqInt stopAddr, sqInt oopPtr, sqInt hdrPtr);
sqInt createActualMessageTo(sqInt aClass);
sqInt dispatchFunctionPointer(void (*aFunctionPointer)(void));
sqInt dispatchFunctionPointerOnin(sqInt primIdx, void (*primTable[])(void));
sqInt displayBitsOfLeftTopRightBottom(sqInt aForm, sqInt l, sqInt t, sqInt r, sqInt b);
sqInt displayObject(void);
sqInt doPrimitiveDivby(sqInt rcvr, sqInt arg);
sqInt doPrimitiveModby(sqInt rcvr, sqInt arg);
sqInt dummyReferToProxy(void);
#pragma export on
EXPORT(sqInt) dumpImage(char *fileName);
#pragma export off
sqInt executeNewMethodFromCache(void);
#pragma export on
EXPORT(sqInt) extraHeaderBytes(sqInt oopOrChunk);
#pragma export off
sqInt failed(void);
sqInt falseObject(void);
void * fetchArrayofObject(sqInt fieldIndex, sqInt objectPointer);
sqInt fetchClassOf(sqInt oop);
sqInt fetchClassOfNonInt(sqInt oop);
double fetchFloatofObject(sqInt fieldIndex, sqInt objectPointer);
sqInt fetchIntegerofObject(sqInt fieldIndex, sqInt objectPointer);
sqInt fetchLong32ofObject(sqInt fieldIndex, sqInt oop);
sqInt fetchPointerofObject(sqInt fieldIndex, sqInt oop);
sqInt fetchStackPointerOf(sqInt aContext);
sqInt fetchWordLengthOf(sqInt objectPointer);
sqInt finalizeReference(usqInt oop);
sqInt findClassOfMethodforReceiver(sqInt meth, sqInt rcvr);
sqInt findNewMethodInClass(sqInt class);
sqInt findSelectorOfMethodforReceiver(sqInt meth, sqInt rcvr);
sqInt firstAccessibleObject(void);
char * firstFixedField(sqInt oop);
char * firstIndexableField(sqInt oop);
double floatArg(sqInt index);
sqInt floatObjectOf(double  aFloat);
double floatValueOf(sqInt oop);
sqInt flushExternalPrimitiveOf(sqInt methodPtr);
sqInt flushExternalPrimitives(void);
sqInt forceInterruptCheck(void);
sqInt fullDisplayUpdate(void);
sqInt fullGC(void);
sqInt fwdBlockValid(sqInt addr);
sqInt fwdTableInit(sqInt blkSize);
sqInt fwdTableSize(sqInt blkSize);
sqInt getCurrentBytecode(void);
sqInt getFullScreenFlag(void);
sqInt getInterruptCheckCounter(void);
sqInt getInterruptKeycode(void);
sqInt getInterruptPending(void);
sqInt getLongFromFileswap(sqImageFile  aFile, sqInt swapFlag);
sqInt getNextWakeupTick(void);
sqInt getSavedWindowSize(void);
#pragma export on
EXPORT(sqInt) getStackPointer(void);
#pragma export off
sqInt getThisSessionID(void);
sqInt growObjectMemory(usqInt delta);
sqInt heapMapAtWord(sqInt wordPointer);
sqInt imageSegmentVersion(void);
sqInt incCompBody(void);
sqInt incCompMakeFwd(void);
sqInt incCompMove(sqInt bytesFreed);
sqInt includesBehaviorThatOf(sqInt aClass, sqInt aSuperclass);
sqInt incrementalGC(void);
sqInt initCompilerHooks(void);
sqInt initializeImageFormatVersionIfNeeded(void);
sqInt initializeInterpreter(sqInt bytesToShift);
sqInt initializeMemoryFirstFree(usqInt firstFree);
sqInt initializeObjectMemory(sqInt bytesToShift);
sqInt installinAtCacheatstring(sqInt rcvr, sqInt *cache, sqInt atIx, sqInt stringy);
sqInt instanceSizeOf(sqInt classObj);
sqInt instantiateClassindexableSize(sqInt classPointer, sqInt size);
sqInt instantiateContextsizeInBytes(sqInt classPointer, sqInt sizeInBytes);
sqInt instantiateSmallClasssizeInBytes(sqInt classPointer, sqInt sizeInBytes);
sqInt integerArg(sqInt index);
sqInt integerObjectOf(sqInt value);
sqInt integerValueOf(sqInt objectPointer);
#pragma export on
EXPORT(sqInt) internalIsImmutable(sqInt oop);
EXPORT(sqInt) internalIsMutable(sqInt oop);
#pragma export off
sqInt interpret(void);
sqInt ioFilenamefromStringofLengthresolveAliases(char *aCharBuffer, char *aFilenameString, sqInt filenameLength, sqInt aBoolean);
#pragma export on
EXPORT(usqLong) ioUTCMicroseconds(void);
#pragma export off
sqInt isKindOf(sqInt oop, char *className);
sqInt isKindOfClass(sqInt oop, sqInt aClass);
sqInt isMemberOf(sqInt oop, char *className);
sqInt isArray(sqInt oop);
sqInt isBigEnder(void);
sqInt isBytes(sqInt oop);
sqInt isExcessiveAllocationRequestshift(sqInt size, sqInt bits);
sqInt isFloatObject(sqInt oop);
sqInt isHandlerMarked(sqInt aContext);
sqInt isInMemory(sqInt address);
sqInt isIndexable(sqInt oop);
sqInt isIntegerObject(sqInt objectPointer);
sqInt isIntegerValue(sqInt intValue);
sqInt isNegativeIntegerValueOf(sqInt oop);
sqInt isPointers(sqInt oop);
sqInt isWeak(sqInt oop);
sqInt isWords(sqInt oop);
sqInt isWordsOrBytes(sqInt oop);
sqInt isWordsOrBytesNonInt(sqInt oop);
sqInt isYoung(sqInt oop);
sqInt lastPointerOf(sqInt oop);
sqInt lengthOf(sqInt oop);
sqInt literalofMethod(sqInt offset, sqInt methodPointer);
sqInt literalCountOf(sqInt methodPointer);
sqInt literalCountOfHeader(sqInt headerPointer);
sqInt loadBitBltFrom(sqInt bb);
sqInt loadInitialContext(void);
sqInt lookupInMethodCacheSelclass(sqInt selector, sqInt class);
sqInt lookupMethodInClass(sqInt class);
sqInt lookupMethodInDictionary(sqInt dictionary);
sqInt lookupMethodNoMNUEtcInClass(sqInt class);
sqInt lowestFreeAfter(sqInt chunk);
sqInt magnitude64BitIntegerForneg(usqLong magnitude, sqInt isNegative);
usqLong magnitude64BitValueOf(sqInt oop);
sqInt makePointwithxValueyValue(sqInt xValue, sqInt yValue);
sqInt mapPointersInObjectsFromto(sqInt memStart, sqInt memEnd);
sqInt markAndTrace(sqInt oop);
sqInt markAndTraceInterpreterOops(sqInt fullGCFlag);
sqInt markPhase(void);
sqInt methodArg(sqInt index);
sqInt methodArgumentCount(void);
sqInt methodPrimitiveIndex(void);
sqInt methodReturnValue(sqInt oop);
#pragma export on
EXPORT(sqInt) moduleUnloaded(char *aModuleName);
#pragma export off
sqInt nilObject(void);
sqInt nonWeakFieldsOf(sqInt oop);
sqInt normalizeFloatOrderingInImage(void);
sqInt noteAsRootheaderLoc(sqInt oop, sqInt headerLoc);
sqInt nullCompilerHook(void);
sqInt objectAfter(sqInt oop);
sqInt objectArg(sqInt index);
sqInt obsoleteDontUseThisFetchWordofObject(sqInt fieldIndex, sqInt oop);
sqInt okayFields(sqInt oop);
sqInt okayOop(sqInt signedOop);
sqInt oopisGreaterThan(sqInt anOop, sqInt otherOop);
sqInt oopisGreaterThanOrEqualTo(sqInt anOop, sqInt otherOop);
sqInt oopisLessThan(sqInt anOop, sqInt otherOop);
sqInt oopHasAcceptableClass(sqInt signedOop);
sqInt oopHasOkayClass(sqInt signedOop);
sqInt pop(sqInt nItems);
sqInt popthenPush(sqInt nItems, sqInt oop);
double popFloat(void);
sqInt popRemappableOop(void);
sqInt popStack(void);
sqInt positive32BitIntegerFor(sqInt integerValue);
sqInt positive32BitValueOf(sqInt oop);
sqInt positive64BitIntegerFor(sqLong integerValue);
sqLong positive64BitValueOf(sqInt oop);
sqInt possibleRootStoreIntovalue(sqInt oop, sqInt valueObj);
sqInt postGCAction(void);
sqInt prepareForwardingTableForBecomingwithtwoWay(sqInt array1, sqInt array2, sqInt twoWayFlag);
sqInt primitiveAdd(void);
#pragma export on
EXPORT(sqInt) primitiveAddLargeIntegers(void);
#pragma export off
sqInt primitiveAdoptInstance(void);
#pragma export on
EXPORT(sqInt) primitiveAllObjects(void);
#pragma export off
sqInt primitiveArctan(void);
sqInt primitiveArrayBecome(void);
sqInt primitiveArrayBecomeOneWay(void);
sqInt primitiveArrayBecomeOneWayCopyHash(void);
sqInt primitiveAsFloat(void);
void primitiveAsOop(void);
sqInt primitiveAt(void);
sqInt primitiveAtPut(void);
sqInt primitiveBeCursor(void);
sqInt primitiveBeDisplay(void);
sqInt primitiveBeep(void);
sqInt primitiveBehaviorHash(void);
sqInt primitiveBitAnd(void);
#pragma export on
EXPORT(sqInt) primitiveBitAndLargeIntegers(void);
#pragma export off
sqInt primitiveBitOr(void);
#pragma export on
EXPORT(sqInt) primitiveBitOrLargeIntegers(void);
#pragma export off
sqInt primitiveBitShift(void);
#pragma export on
EXPORT(sqInt) primitiveBitShiftLargeIntegers(void);
#pragma export off
sqInt primitiveBitXor(void);
#pragma export on
EXPORT(sqInt) primitiveBitXorLargeIntegers(void);
#pragma export off
void primitiveBlockCopy(void);
sqInt primitiveBytesLeft(void);
sqInt primitiveCalloutToFFI(void);
sqInt primitiveChangeClass(void);
#pragma export on
EXPORT(sqInt) primitiveChangeClassWithClass(void);
#pragma export off
sqInt primitiveClass(void);
sqInt primitiveClipboardText(void);
void primitiveClone(void);
void primitiveClosureCopyWithCopiedValues(void);
void primitiveClosureValue(void);
void primitiveClosureValueNoContextSwitch(void);
void primitiveClosureValueWithArgs(void);
sqInt primitiveConstantFill(void);
void primitiveCopyObject(void);
void primitiveDeferDisplayUpdates(void);
#pragma export on
EXPORT(sqInt) primitiveDisablePowerManager(void);
#pragma export off
sqInt primitiveDiv(void);
#pragma export on
EXPORT(sqInt) primitiveDivLargeIntegers(void);
#pragma export off
sqInt primitiveDivide(void);
#pragma export on
EXPORT(sqInt) primitiveDivideLargeIntegers(void);
#pragma export off
void primitiveDoPrimitiveWithArgs(void);
sqInt primitiveEqual(void);
#pragma export on
EXPORT(sqInt) primitiveEqualLargeIntegers(void);
#pragma export off
sqInt primitiveErrorTable(void);
void primitiveExecuteMethod(void);
void primitiveExecuteMethodArgsArray(void);
sqInt primitiveExitToDebugger(void);
sqInt primitiveExp(void);
sqInt primitiveExponent(void);
void primitiveExternalCall(void);
sqInt primitiveFail(void);
sqInt primitiveFailFor(sqInt reasonCode);
sqInt primitiveFailureCode(void);
sqInt primitiveFindHandlerContext(void);
sqInt primitiveFindNextUnwindContext(void);
sqInt primitiveFloatAdd(void);
sqInt primitiveFloatAddtoArg(sqInt rcvrOop, sqInt argOop);
void primitiveFloatAt(void);
void primitiveFloatAtPut(void);
sqInt primitiveFloatDivide(void);
sqInt primitiveFloatDividebyArg(sqInt rcvrOop, sqInt argOop);
sqInt primitiveFloatEqual(void);
sqInt primitiveFloatEqualtoArg(sqInt rcvrOop, sqInt argOop);
sqInt primitiveFloatGreaterthanArg(sqInt rcvrOop, sqInt argOop);
sqInt primitiveFloatGreaterOrEqual(void);
sqInt primitiveFloatGreaterOrEqualtoArg(sqInt rcvrOop, sqInt argOop);
sqInt primitiveFloatGreaterThan(void);
sqInt primitiveFloatLessthanArg(sqInt rcvrOop, sqInt argOop);
sqInt primitiveFloatLessOrEqual(void);
sqInt primitiveFloatLessOrEqualtoArg(sqInt rcvrOop, sqInt argOop);
sqInt primitiveFloatLessThan(void);
sqInt primitiveFloatMultiply(void);
sqInt primitiveFloatMultiplybyArg(sqInt rcvrOop, sqInt argOop);
sqInt primitiveFloatNotEqual(void);
sqInt primitiveFloatSubtract(void);
sqInt primitiveFloatSubtractfromArg(sqInt rcvrOop, sqInt argOop);
sqInt primitiveFlushCache(void);
void primitiveFlushCacheByMethod(void);
void primitiveFlushCacheBySelector(void);
sqInt primitiveFlushExternalPrimitives(void);
sqInt primitiveForceDisplayUpdate(void);
#pragma export on
EXPORT(sqInt) primitiveForceTenure(void);
#pragma export off
sqInt primitiveFormPrint(void);
sqInt primitiveFractionalPart(void);
sqInt primitiveFullGC(void);
sqInt primitiveGetAttribute(void);
sqInt primitiveGetNextEvent(void);
sqInt primitiveGreaterOrEqual(void);
#pragma export on
EXPORT(sqInt) primitiveGreaterOrEqualLargeIntegers(void);
#pragma export off
sqInt primitiveGreaterThan(void);
#pragma export on
EXPORT(sqInt) primitiveGreaterThanLargeIntegers(void);
#pragma export off
sqInt primitiveIdentical(void);
#pragma export on
EXPORT(sqInt) primitiveImageFormatVersion(void);
#pragma export off
sqInt primitiveImageName(void);
sqInt primitiveIncrementalGC(void);
sqInt primitiveIndexOf(sqInt methodPointer);
sqInt primitiveInputSemaphore(void);
sqInt primitiveInputWord(void);
sqInt primitiveInstVarAt(void);
sqInt primitiveInstVarAtPut(void);
sqInt primitiveIntegerAt(void);
sqInt primitiveIntegerAtPut(void);
#pragma export on
EXPORT(sqInt) primitiveInterpreterSourceVersion(void);
#pragma export off
sqInt primitiveInterruptSemaphore(void);
void primitiveInvokeObjectAsMethod(void);
#pragma export on
EXPORT(sqInt) primitiveIsRoot(void);
EXPORT(sqInt) primitiveIsYoung(void);
#pragma export off
sqInt primitiveKbdNext(void);
sqInt primitiveKbdPeek(void);
sqInt primitiveLessOrEqual(void);
#pragma export on
EXPORT(sqInt) primitiveLessOrEqualLargeIntegers(void);
#pragma export off
sqInt primitiveLessThan(void);
#pragma export on
EXPORT(sqInt) primitiveLessThanLargeIntegers(void);
#pragma export off
sqInt primitiveListBuiltinModule(void);
sqInt primitiveListExternalModule(void);
sqInt primitiveLoadImageSegment(void);
void primitiveLoadInstVar(void);
#pragma export on
EXPORT(sqInt) primitiveLocalMicrosecondClock(void);
#pragma export off
sqInt primitiveLogN(void);
sqInt primitiveLowSpaceSemaphore(void);
sqInt primitiveMakePoint(void);
sqInt primitiveMarkHandlerMethod(void);
sqInt primitiveMarkUnwindMethod(void);
sqInt primitiveMaxIdentityHash(void);
sqInt primitiveMethod(void);
#pragma export on
EXPORT(sqInt) primitiveMicrosecondClock(void);
#pragma export off
sqInt primitiveMillisecondClock(void);
#pragma export on
EXPORT(sqInt) primitiveMillisecondClockMask(void);
#pragma export off
sqInt primitiveMod(void);
#pragma export on
EXPORT(sqInt) primitiveModLargeIntegers(void);
#pragma export off
sqInt primitiveMouseButtons(void);
sqInt primitiveMousePoint(void);
sqInt primitiveMultiply(void);
#pragma export on
EXPORT(sqInt) primitiveMultiplyLargeIntegers(void);
#pragma export off
sqInt primitiveNew(void);
sqInt primitiveNewMethod(void);
sqInt primitiveNewWithArg(void);
sqInt primitiveNextInstance(void);
sqInt primitiveNextObject(void);
sqInt primitiveNoop(void);
sqInt primitiveNotEqual(void);
#pragma export on
EXPORT(sqInt) primitiveNotEqualLargeIntegers(void);
#pragma export off
sqInt primitiveNotIdentical(void);
sqInt primitiveObjectAt(void);
sqInt primitiveObjectAtPut(void);
sqInt primitiveObjectPointsTo(void);
void primitivePerform(void);
sqInt primitivePerformAt(sqInt lookupClass);
void primitivePerformInSuperclass(void);
void primitivePerformWithArgs(void);
#pragma export on
EXPORT(sqInt) primitivePlatformSourceVersion(void);
#pragma export off
void primitivePushFalse(void);
void primitivePushMinusOne(void);
void primitivePushNil(void);
void primitivePushOne(void);
void primitivePushSelf(void);
void primitivePushTrue(void);
void primitivePushTwo(void);
void primitivePushZero(void);
sqInt primitiveQuit(void);
sqInt primitiveQuo(void);
#pragma export on
EXPORT(sqInt) primitiveQuoLargeIntegers(void);
#pragma export off
sqInt primitiveRelinquishProcessor(void);
#pragma export on
EXPORT(sqInt) primitiveRemLargeIntegers(void);
#pragma export off
sqInt primitiveResponse(void);
void primitiveResume(void);
#pragma export on
EXPORT(sqInt) primitiveRootTable(void);
EXPORT(sqInt) primitiveRootTableAt(void);
#pragma export off
sqInt primitiveScanCharacters(void);
#pragma export on
EXPORT(sqInt) primitiveScreenDepth(void);
#pragma export off
sqInt primitiveScreenSize(void);
sqInt primitiveSecondsClock(void);
sqInt primitiveSetDisplayMode(void);
sqInt primitiveSetFullScreen(void);
#pragma export on
EXPORT(sqInt) primitiveSetGCBiasToGrow(void);
EXPORT(sqInt) primitiveSetGCBiasToGrowGCLimit(void);
EXPORT(sqInt) primitiveSetGCSemaphore(void);
#pragma export off
sqInt primitiveSetIdentityHash(void);
sqInt primitiveSetInterruptKey(void);
sqInt primitiveShortAt(void);
sqInt primitiveShortAtPut(void);
sqInt primitiveShowDisplayRect(void);
sqInt primitiveSignal(void);
sqInt primitiveSignalAtBytesLeft(void);
void primitiveSignalAtMilliseconds(void);
sqInt primitiveSine(void);
sqInt primitiveSize(void);
sqInt primitiveSnapshot(void);
sqInt primitiveSnapshotEmbedded(void);
sqInt primitiveSomeInstance(void);
sqInt primitiveSomeObject(void);
sqInt primitiveSpecialObjectsOop(void);
sqInt primitiveSquareRoot(void);
sqInt primitiveStoreImageSegment(void);
void primitiveStoreStackp(void);
sqInt primitiveStringAt(void);
sqInt primitiveStringAtPut(void);
sqInt primitiveStringReplace(void);
sqInt primitiveSubtract(void);
#pragma export on
EXPORT(sqInt) primitiveSubtractLargeIntegers(void);
#pragma export off
sqInt primitiveSuspend(void);
void primitiveTerminateTo(void);
sqInt primitiveTestDisplayDepth(void);
#pragma export on
EXPORT(sqInt) primitiveTestShortenIndexableSize(void);
#pragma export off
sqInt primitiveTimesTwoPower(void);
sqInt primitiveTruncated(void);
#pragma export on
EXPORT(sqInt) primitiveUTCMicrosecondClock(void);
#pragma export off
sqInt primitiveUnloadModule(void);
#pragma export on
EXPORT(sqInt) primitiveUtcWithOffset(void);
#pragma export off
void primitiveVMParameter(void);
sqInt primitiveVMPath(void);
#pragma export on
EXPORT(sqInt) primitiveVMVersion(void);
#pragma export off
void primitiveValue(void);
void primitiveValueUninterruptably(void);
void primitiveValueWithArgs(void);
sqInt primitiveWait(void);
sqInt primitiveYield(void);
sqInt print(char *s);
#pragma export on
EXPORT(sqInt) printAllStacks(void);
#pragma export off
sqInt printCallStack(void);
sqInt printCallStackOf(sqInt aContext);
sqInt printHex(sqInt n);
sqInt printNameOfClasscount(sqInt classOop, sqInt cnt);
sqInt printNum(sqInt n);
sqInt printStringOf(sqInt oop);
sqInt printUnbalancedStack(sqInt primIdx);
sqInt push(sqInt object);
sqInt pushBool(sqInt trueOrFalse);
sqInt pushFloat(double  f);
sqInt pushInteger(sqInt integerValue);
sqInt pushRemappableOop(sqInt oop);
sqInt putLongtoFile(sqInt aWord, sqImageFile  aFile);
#pragma export on
EXPORT(sqInt) readImageFormatFromFileStartingAt(sqImageFile  f, squeakFileOffsetType  imageOffset);
#pragma export off
sqInt readImageFromFileHeapSizeStartingAt(sqImageFile  f, usqInt desiredHeapSize, squeakFileOffsetType  imageOffset);
sqInt readableFormat(sqInt imageVersion);
#pragma export on
EXPORT(sqInt) reestablishContextPriorToCallback(sqInt callbackContext);
#pragma export off
sqInt remap(sqInt oop);
sqInt removeFirstLinkOfList(sqInt aList);
#pragma export on
EXPORT(sqInt) removeGCRoot(sqInt *varLoc);
#pragma export off
sqInt restoreHeaderOf(sqInt oop);
sqInt restoreHeadersFromtofromandtofrom(sqInt firstIn, sqInt lastIn, sqInt hdrBaseIn, sqInt firstOut, sqInt lastOut, sqInt hdrBaseOut);
sqInt resume(sqInt aProcess);
sqInt reverseDisplayFromto(sqInt startIndex, sqInt endIndex);
sqInt rewriteMethodCacheSelclassprimIndex(sqInt selector, sqInt class, sqInt localPrimIndex);
sqInt rewriteMethodCacheSelclassprimIndexprimFunction(sqInt selector, sqInt class, sqInt localPrimIndex, void (*localPrimAddress)(void));
#pragma export on
EXPORT(sqInt) sendInvokeCallbackStackRegistersJmpbuf(sqInt thunkPtr, sqInt stackPtr, sqInt regsPtr, sqInt jmpBufPtr);
#pragma export off
sqInt setCompilerInitialized(sqInt newFlag);
sqInt setFullScreenFlag(sqInt value);
sqInt setInterruptCheckCounter(sqInt value);
sqInt setInterruptKeycode(sqInt value);
sqInt setInterruptPending(sqInt value);
sqInt setMicroSecondsandOffset(sqLong *microSeconds, int *utcOffset);
sqInt setNextWakeupTick(sqInt value);
sqInt setSavedWindowSize(sqInt value);
sqInt shortentoIndexableSize(sqInt obj, sqInt nSlots);
sqInt showDisplayBitsLeftTopRightBottom(sqInt aForm, sqInt l, sqInt t, sqInt r, sqInt b);
sqInt signalSemaphoreWithIndex(sqInt index);
sqInt signed32BitIntegerFor(int integerValue);
int signed32BitValueOf(sqInt oop);
sqInt signed64BitIntegerFor(sqLong integerValue);
sqLong signed64BitValueOf(sqInt oop);
sqInt sizeBitsOf(sqInt oop);
sqInt sizeOfSTArrayFromCPrimitive(void *cPtr);
sqInt slotSizeOf(sqInt oop);
sqInt snapshot(sqInt embedded);
sqInt splObj(sqInt index);
sqInt stObjectat(sqInt array, sqInt index);
sqInt stObjectatput(sqInt array, sqInt index, sqInt value);
sqInt stSizeOf(sqInt oop);
double stackFloatValue(sqInt offset);
sqInt stackIntegerValue(sqInt offset);
sqInt stackObjectValue(sqInt offset);
sqInt stackTop(void);
sqInt stackValue(sqInt offset);
sqInt storeIntegerofObjectwithValue(sqInt fieldIndex, sqInt objectPointer, sqInt integerValue);
sqInt storePointerofObjectwithValue(sqInt fieldIndex, sqInt oop, sqInt valuePointer);
sqInt success(sqInt successBoolean);
sqInt successful(void);
sqInt sufficientSpaceAfterGC(usqInt minFree);
sqInt sufficientSpaceToAllocate(usqInt bytes);
sqInt superclassOf(sqInt classPointer);
sqInt sweepPhase(void);
sqInt synchronousSignal(sqInt aSemaphore);
sqInt tenuringIncrementalGC(void);
sqInt topRemappableOop(void);
sqInt transferTo(sqInt aProc);
sqInt trueObject(void);
sqInt updatePointersInRangeFromto(sqInt memStart, sqInt memEnd);
sqInt updatePointersInRootObjectsFromto(sqInt memStart, sqInt memEnd);
sqInt validateRoots(void);
sqInt verifyCleanHeaders(void);
sqInt vmEndianness(void);
sqInt wakeHighestPriority(void);
sqInt wordSwapped(sqInt w);
sqInt writeImageFile(sqInt imageBytes);
sqInt writeImageFileIO(sqInt imageBytes);
/*** Variables ***/
usqInt activeContext;
sqInt allocationCount;
sqInt allocationsBetweenGCs;
sqInt argumentCount;
sqInt atCache[65];
usqInt compEnd;
usqInt compStart;
sqInt (*compilerHooks[16])();
sqInt compilerInitialized;
sqInt deferDisplayUpdates;
usqInt endOfMemory;
void (*externalPrimitiveTable[4097])(void);
sqInt extraRootCount;
sqInt* extraRoots[2049];
sqInt extraVMMemory;
sqInt falseObj;
sqInt forceTenureFlag;
usqInt freeBlock;
sqInt freeContexts;
sqInt freeLargeContexts;
sqInt fullScreenFlag;
usqInt fwdTableLast;
usqInt fwdTableNext;
sqInt gcBiasToGrow;
sqInt gcBiasToGrowGCLimit;
usqInt gcBiasToGrowThreshold;
sqInt gcSemaphoreIndex;
sqInt gcStartUsecs;
sqInt globalSessionID;
usqInt growHeadroom;
sqInt headerTypeBytes[4];
sqInt imageFormatInitialVersion = 0;
sqInt imageFormatVersionNumber = 0;
usqInt instructionPointer;
struct VirtualMachine* interpreterProxy;
const char *interpreterVersion = "Squeak4.5 of 26 June 2014 [latest update: #13687]";
sqInt interruptCheckCounter;
sqInt interruptCheckCounterFeedBackReset;
sqInt interruptChecksEveryNms;
sqInt interruptKeycode;
sqInt interruptPending;
jmp_buf jmpBuf[33];
sqInt jmpDepth;
sqInt jmpMax;
sqInt lastHash;
sqInt lastTick;
sqInt lkupClass;
sqInt lowSpaceThreshold;
usqInt memory;
usqInt memoryLimit;
sqInt messageSelector;
usqInt method;
long methodCache[4097];
sqInt methodClass;
usqInt newMethod;
sqInt newNativeMethod;
sqInt nextPollTick;
sqInt nextWakeupTick;
sqInt nilObj;
sqInt pendingFinalizationSignals;
sqInt primFailCode;
void (*primitiveFunctionPointer)(void);
sqInt primitiveIndex;
void (*primitiveTable[577] )(void)= {
	/* 0*/ (void (*)(void))primitiveFail,
	/* 1*/ (void (*)(void))primitiveAdd,
	/* 2*/ (void (*)(void))primitiveSubtract,
	/* 3*/ (void (*)(void))primitiveLessThan,
	/* 4*/ (void (*)(void))primitiveGreaterThan,
	/* 5*/ (void (*)(void))primitiveLessOrEqual,
	/* 6*/ (void (*)(void))primitiveGreaterOrEqual,
	/* 7*/ (void (*)(void))primitiveEqual,
	/* 8*/ (void (*)(void))primitiveNotEqual,
	/* 9*/ (void (*)(void))primitiveMultiply,
	/* 10*/ (void (*)(void))primitiveDivide,
	/* 11*/ (void (*)(void))primitiveMod,
	/* 12*/ (void (*)(void))primitiveDiv,
	/* 13*/ (void (*)(void))primitiveQuo,
	/* 14*/ (void (*)(void))primitiveBitAnd,
	/* 15*/ (void (*)(void))primitiveBitOr,
	/* 16*/ (void (*)(void))primitiveBitXor,
	/* 17*/ (void (*)(void))primitiveBitShift,
	/* 18*/ (void (*)(void))primitiveMakePoint,
	/* 19*/ (void (*)(void))primitiveFail,
	/* 20*/ (void (*)(void))primitiveRemLargeIntegers,
	/* 21*/ (void (*)(void))primitiveAddLargeIntegers,
	/* 22*/ (void (*)(void))primitiveSubtractLargeIntegers,
	/* 23*/ (void (*)(void))primitiveLessThanLargeIntegers,
	/* 24*/ (void (*)(void))primitiveGreaterThanLargeIntegers,
	/* 25*/ (void (*)(void))primitiveLessOrEqualLargeIntegers,
	/* 26*/ (void (*)(void))primitiveGreaterOrEqualLargeIntegers,
	/* 27*/ (void (*)(void))primitiveEqualLargeIntegers,
	/* 28*/ (void (*)(void))primitiveNotEqualLargeIntegers,
	/* 29*/ (void (*)(void))primitiveMultiplyLargeIntegers,
	/* 30*/ (void (*)(void))primitiveDivideLargeIntegers,
	/* 31*/ (void (*)(void))primitiveModLargeIntegers,
	/* 32*/ (void (*)(void))primitiveDivLargeIntegers,
	/* 33*/ (void (*)(void))primitiveQuoLargeIntegers,
	/* 34*/ (void (*)(void))primitiveBitAndLargeIntegers,
	/* 35*/ (void (*)(void))primitiveBitOrLargeIntegers,
	/* 36*/ (void (*)(void))primitiveBitXorLargeIntegers,
	/* 37*/ (void (*)(void))primitiveBitShiftLargeIntegers,
	/* 38*/ (void (*)(void))primitiveFloatAt,
	/* 39*/ (void (*)(void))primitiveFloatAtPut,
	/* 40*/ (void (*)(void))primitiveAsFloat,
	/* 41*/ (void (*)(void))primitiveFloatAdd,
	/* 42*/ (void (*)(void))primitiveFloatSubtract,
	/* 43*/ (void (*)(void))primitiveFloatLessThan,
	/* 44*/ (void (*)(void))primitiveFloatGreaterThan,
	/* 45*/ (void (*)(void))primitiveFloatLessOrEqual,
	/* 46*/ (void (*)(void))primitiveFloatGreaterOrEqual,
	/* 47*/ (void (*)(void))primitiveFloatEqual,
	/* 48*/ (void (*)(void))primitiveFloatNotEqual,
	/* 49*/ (void (*)(void))primitiveFloatMultiply,
	/* 50*/ (void (*)(void))primitiveFloatDivide,
	/* 51*/ (void (*)(void))primitiveTruncated,
	/* 52*/ (void (*)(void))primitiveFractionalPart,
	/* 53*/ (void (*)(void))primitiveExponent,
	/* 54*/ (void (*)(void))primitiveTimesTwoPower,
	/* 55*/ (void (*)(void))primitiveSquareRoot,
	/* 56*/ (void (*)(void))primitiveSine,
	/* 57*/ (void (*)(void))primitiveArctan,
	/* 58*/ (void (*)(void))primitiveLogN,
	/* 59*/ (void (*)(void))primitiveExp,
	/* 60*/ (void (*)(void))primitiveAt,
	/* 61*/ (void (*)(void))primitiveAtPut,
	/* 62*/ (void (*)(void))primitiveSize,
	/* 63*/ (void (*)(void))primitiveStringAt,
	/* 64*/ (void (*)(void))primitiveStringAtPut,
	/* 65*/ (void (*)(void))primitiveFail,
	/* 66*/ (void (*)(void))primitiveFail,
	/* 67*/ (void (*)(void))primitiveFail,
	/* 68*/ (void (*)(void))primitiveObjectAt,
	/* 69*/ (void (*)(void))primitiveObjectAtPut,
	/* 70*/ (void (*)(void))primitiveNew,
	/* 71*/ (void (*)(void))primitiveNewWithArg,
	/* 72*/ (void (*)(void))primitiveArrayBecomeOneWay,
	/* 73*/ (void (*)(void))primitiveInstVarAt,
	/* 74*/ (void (*)(void))primitiveInstVarAtPut,
	/* 75*/ (void (*)(void))primitiveAsOop,
	/* 76*/ (void (*)(void))primitiveStoreStackp,
	/* 77*/ (void (*)(void))primitiveSomeInstance,
	/* 78*/ (void (*)(void))primitiveNextInstance,
	/* 79*/ (void (*)(void))primitiveNewMethod,
	/* 80*/ (void (*)(void))primitiveBlockCopy,
	/* 81*/ (void (*)(void))primitiveValue,
	/* 82*/ (void (*)(void))primitiveValueWithArgs,
	/* 83*/ (void (*)(void))primitivePerform,
	/* 84*/ (void (*)(void))primitivePerformWithArgs,
	/* 85*/ (void (*)(void))primitiveSignal,
	/* 86*/ (void (*)(void))primitiveWait,
	/* 87*/ (void (*)(void))primitiveResume,
	/* 88*/ (void (*)(void))primitiveSuspend,
	/* 89*/ (void (*)(void))primitiveFlushCache,
	/* 90*/ (void (*)(void))primitiveMousePoint,
	/* 91*/ (void (*)(void))primitiveTestDisplayDepth,
	/* 92*/ (void (*)(void))primitiveSetDisplayMode,
	/* 93*/ (void (*)(void))primitiveInputSemaphore,
	/* 94*/ (void (*)(void))primitiveGetNextEvent,
	/* 95*/ (void (*)(void))primitiveInputWord,
	/* 96*/ (void (*)(void))primitiveFail,
	/* 97*/ (void (*)(void))primitiveSnapshot,
	/* 98*/ (void (*)(void))primitiveStoreImageSegment,
	/* 99*/ (void (*)(void))primitiveLoadImageSegment,
	/* 100*/ (void (*)(void))primitivePerformInSuperclass,
	/* 101*/ (void (*)(void))primitiveBeCursor,
	/* 102*/ (void (*)(void))primitiveBeDisplay,
	/* 103*/ (void (*)(void))primitiveScanCharacters,
	/* 104*/ (void (*)(void))primitiveFail,
	/* 105*/ (void (*)(void))primitiveStringReplace,
	/* 106*/ (void (*)(void))primitiveScreenSize,
	/* 107*/ (void (*)(void))primitiveMouseButtons,
	/* 108*/ (void (*)(void))primitiveKbdNext,
	/* 109*/ (void (*)(void))primitiveKbdPeek,
	/* 110*/ (void (*)(void))primitiveIdentical,
	/* 111*/ (void (*)(void))primitiveClass,
	/* 112*/ (void (*)(void))primitiveBytesLeft,
	/* 113*/ (void (*)(void))primitiveQuit,
	/* 114*/ (void (*)(void))primitiveExitToDebugger,
	/* 115*/ (void (*)(void))primitiveChangeClass,
	/* 116*/ (void (*)(void))primitiveFlushCacheByMethod,
	/* 117*/ (void (*)(void))primitiveExternalCall,
	/* 118*/ (void (*)(void))primitiveDoPrimitiveWithArgs,
	/* 119*/ (void (*)(void))primitiveFlushCacheBySelector,
	/* 120*/ (void (*)(void))primitiveCalloutToFFI,
	/* 121*/ (void (*)(void))primitiveImageName,
	/* 122*/ (void (*)(void))primitiveNoop,
	/* 123*/ (void (*)(void))primitiveValueUninterruptably,
	/* 124*/ (void (*)(void))primitiveLowSpaceSemaphore,
	/* 125*/ (void (*)(void))primitiveSignalAtBytesLeft,
	/* 126*/ (void (*)(void))primitiveDeferDisplayUpdates,
	/* 127*/ (void (*)(void))primitiveShowDisplayRect,
	/* 128*/ (void (*)(void))primitiveArrayBecome,
	/* 129*/ (void (*)(void))primitiveSpecialObjectsOop,
	/* 130*/ (void (*)(void))primitiveFullGC,
	/* 131*/ (void (*)(void))primitiveIncrementalGC,
	/* 132*/ (void (*)(void))primitiveObjectPointsTo,
	/* 133*/ (void (*)(void))primitiveSetInterruptKey,
	/* 134*/ (void (*)(void))primitiveInterruptSemaphore,
	/* 135*/ (void (*)(void))primitiveMillisecondClock,
	/* 136*/ (void (*)(void))primitiveSignalAtMilliseconds,
	/* 137*/ (void (*)(void))primitiveSecondsClock,
	/* 138*/ (void (*)(void))primitiveSomeObject,
	/* 139*/ (void (*)(void))primitiveNextObject,
	/* 140*/ (void (*)(void))primitiveBeep,
	/* 141*/ (void (*)(void))primitiveClipboardText,
	/* 142*/ (void (*)(void))primitiveVMPath,
	/* 143*/ (void (*)(void))primitiveShortAt,
	/* 144*/ (void (*)(void))primitiveShortAtPut,
	/* 145*/ (void (*)(void))primitiveConstantFill,
	/* 146*/ (void (*)(void))primitiveFail,
	/* 147*/ (void (*)(void))primitiveFail,
	/* 148*/ (void (*)(void))primitiveClone,
	/* 149*/ (void (*)(void))primitiveGetAttribute,
	/* 150*/ (void (*)(void))primitiveFail,
	/* 151*/ (void (*)(void))primitiveFail,
	/* 152*/ (void (*)(void))primitiveFail,
	/* 153*/ (void (*)(void))primitiveFail,
	/* 154*/ (void (*)(void))primitiveFail,
	/* 155*/ (void (*)(void))primitiveFail,
	/* 156*/ (void (*)(void))primitiveFail,
	/* 157*/ (void (*)(void))primitiveFail,
	/* 158*/ (void (*)(void))primitiveFail,
	/* 159*/ (void (*)(void))primitiveFail,
	/* 160*/ (void (*)(void))primitiveAdoptInstance,
	/* 161*/ (void (*)(void))primitiveSetIdentityHash,
	/* 162*/ (void (*)(void))primitiveFail,
	/* 163*/ (void (*)(void))primitiveFail,
	/* 164*/ (void (*)(void))primitiveFail,
	/* 165*/ (void (*)(void))primitiveIntegerAt,
	/* 166*/ (void (*)(void))primitiveIntegerAtPut,
	/* 167*/ (void (*)(void))primitiveYield,
	/* 168*/ (void (*)(void))primitiveCopyObject,
	/* 169*/ (void (*)(void))primitiveNotIdentical,
	/* 170*/ (void (*)(void))primitiveFail,
	/* 171*/ (void (*)(void))primitiveFail,
	/* 172*/ (void (*)(void))primitiveFail,
	/* 173*/ (void (*)(void))primitiveFail,
	/* 174*/ (void (*)(void))primitiveFail,
	/* 175*/ (void (*)(void))primitiveBehaviorHash,
	/* 176*/ (void (*)(void))primitiveMaxIdentityHash,
	/* 177*/ (void (*)(void))primitiveFail,
	/* 178*/ (void (*)(void))primitiveFail,
	/* 179*/ (void (*)(void))primitiveFail,
	/* 180*/ (void (*)(void))primitiveFail,
	/* 181*/ (void (*)(void))primitiveFail,
	/* 182*/ (void (*)(void))primitiveFail,
	/* 183*/ (void (*)(void))primitiveFail,
	/* 184*/ (void (*)(void))primitiveFail,
	/* 185*/ (void (*)(void))primitiveFail,
	/* 186*/ (void (*)(void))primitiveFail,
	/* 187*/ (void (*)(void))primitiveFail,
	/* 188*/ (void (*)(void))primitiveExecuteMethodArgsArray,
	/* 189*/ (void (*)(void))primitiveExecuteMethod,
	/* 190*/ (void (*)(void))primitiveFail,
	/* 191*/ (void (*)(void))primitiveFail,
	/* 192*/ (void (*)(void))primitiveFail,
	/* 193*/ (void (*)(void))primitiveFail,
	/* 194*/ (void (*)(void))primitiveFail,
	/* 195*/ (void (*)(void))primitiveFindNextUnwindContext,
	/* 196*/ (void (*)(void))primitiveTerminateTo,
	/* 197*/ (void (*)(void))primitiveFindHandlerContext,
	/* 198*/ (void (*)(void))primitiveMarkUnwindMethod,
	/* 199*/ (void (*)(void))primitiveMarkHandlerMethod,
	/* 200*/ (void (*)(void))primitiveClosureCopyWithCopiedValues,
	/* 201*/ (void (*)(void))primitiveClosureValue,
	/* 202*/ (void (*)(void))primitiveClosureValue,
	/* 203*/ (void (*)(void))primitiveClosureValue,
	/* 204*/ (void (*)(void))primitiveClosureValue,
	/* 205*/ (void (*)(void))primitiveClosureValue,
	/* 206*/ (void (*)(void))primitiveClosureValueWithArgs,
	/* 207*/ (void (*)(void))primitiveFail,
	/* 208*/ (void (*)(void))primitiveFail,
	/* 209*/ (void (*)(void))primitiveFail,
	/* 210*/ (void (*)(void))primitiveAt,
	/* 211*/ (void (*)(void))primitiveAtPut,
	/* 212*/ (void (*)(void))primitiveSize,
	/* 213*/ (void (*)(void))primitiveFail,
	/* 214*/ (void (*)(void))primitiveFail,
	/* 215*/ (void (*)(void))primitiveFail,
	/* 216*/ (void (*)(void))primitiveFail,
	/* 217*/ (void (*)(void))primitiveFail,
	/* 218*/ (void (*)(void))primitiveFail,
	/* 219*/ (void (*)(void))primitiveFail,
	/* 220*/ (void (*)(void))primitiveFail,
	/* 221*/ (void (*)(void))primitiveClosureValueNoContextSwitch,
	/* 222*/ (void (*)(void))primitiveClosureValueNoContextSwitch,
	/* 223*/ (void (*)(void))primitiveFail,
	/* 224*/ (void (*)(void))primitiveFail,
	/* 225*/ (void (*)(void))primitiveFail,
	/* 226*/ (void (*)(void))primitiveFail,
	/* 227*/ (void (*)(void))primitiveFail,
	/* 228*/ (void (*)(void))primitiveFail,
	/* 229*/ (void (*)(void))primitiveFail,
	/* 230*/ (void (*)(void))primitiveRelinquishProcessor,
	/* 231*/ (void (*)(void))primitiveForceDisplayUpdate,
	/* 232*/ (void (*)(void))primitiveFormPrint,
	/* 233*/ (void (*)(void))primitiveSetFullScreen,
	/* 234*/ (void (*)(void))primitiveFail,
	/* 235*/ (void (*)(void))primitiveFail,
	/* 236*/ (void (*)(void))primitiveFail,
	/* 237*/ (void (*)(void))primitiveFail,
	/* 238*/ (void (*)(void))primitiveFail,
	/* 239*/ (void (*)(void))primitiveFail,
	/* 240*/ (void (*)(void))primitiveUTCMicrosecondClock,
	/* 241*/ (void (*)(void))primitiveLocalMicrosecondClock,
	/* 242*/ (void (*)(void))primitiveFail,
	/* 243*/ (void (*)(void))primitiveFail,
	/* 244*/ (void (*)(void))primitiveFail,
	/* 245*/ (void (*)(void))primitiveFail,
	/* 246*/ (void (*)(void))primitiveFail,
	/* 247*/ (void (*)(void))primitiveSnapshotEmbedded,
	/* 248*/ (void (*)(void))primitiveInvokeObjectAsMethod,
	/* 249*/ (void (*)(void))primitiveArrayBecomeOneWayCopyHash,
	/* 250*/ (void (*)(void))clearProfile,
	/* 251*/ (void (*)(void))dumpProfile,
	/* 252*/ (void (*)(void))startProfiling,
	/* 253*/ (void (*)(void))stopProfiling,
	/* 254*/ (void (*)(void))primitiveVMParameter,
	/* 255*/ (void (*)(void))primitiveFail,
	/* 256*/ (void (*)(void))primitivePushSelf,
	/* 257*/ (void (*)(void))primitivePushTrue,
	/* 258*/ (void (*)(void))primitivePushFalse,
	/* 259*/ (void (*)(void))primitivePushNil,
	/* 260*/ (void (*)(void))primitivePushMinusOne,
	/* 261*/ (void (*)(void))primitivePushZero,
	/* 262*/ (void (*)(void))primitivePushOne,
	/* 263*/ (void (*)(void))primitivePushTwo,
	/* 264*/ (void (*)(void))primitiveLoadInstVar,
	/* 265*/ (void (*)(void))primitiveLoadInstVar,
	/* 266*/ (void (*)(void))primitiveLoadInstVar,
	/* 267*/ (void (*)(void))primitiveLoadInstVar,
	/* 268*/ (void (*)(void))primitiveLoadInstVar,
	/* 269*/ (void (*)(void))primitiveLoadInstVar,
	/* 270*/ (void (*)(void))primitiveLoadInstVar,
	/* 271*/ (void (*)(void))primitiveLoadInstVar,
	/* 272*/ (void (*)(void))primitiveLoadInstVar,
	/* 273*/ (void (*)(void))primitiveLoadInstVar,
	/* 274*/ (void (*)(void))primitiveLoadInstVar,
	/* 275*/ (void (*)(void))primitiveLoadInstVar,
	/* 276*/ (void (*)(void))primitiveLoadInstVar,
	/* 277*/ (void (*)(void))primitiveLoadInstVar,
	/* 278*/ (void (*)(void))primitiveLoadInstVar,
	/* 279*/ (void (*)(void))primitiveLoadInstVar,
	/* 280*/ (void (*)(void))primitiveLoadInstVar,
	/* 281*/ (void (*)(void))primitiveLoadInstVar,
	/* 282*/ (void (*)(void))primitiveLoadInstVar,
	/* 283*/ (void (*)(void))primitiveLoadInstVar,
	/* 284*/ (void (*)(void))primitiveLoadInstVar,
	/* 285*/ (void (*)(void))primitiveLoadInstVar,
	/* 286*/ (void (*)(void))primitiveLoadInstVar,
	/* 287*/ (void (*)(void))primitiveLoadInstVar,
	/* 288*/ (void (*)(void))primitiveLoadInstVar,
	/* 289*/ (void (*)(void))primitiveLoadInstVar,
	/* 290*/ (void (*)(void))primitiveLoadInstVar,
	/* 291*/ (void (*)(void))primitiveLoadInstVar,
	/* 292*/ (void (*)(void))primitiveLoadInstVar,
	/* 293*/ (void (*)(void))primitiveLoadInstVar,
	/* 294*/ (void (*)(void))primitiveLoadInstVar,
	/* 295*/ (void (*)(void))primitiveLoadInstVar,
	/* 296*/ (void (*)(void))primitiveLoadInstVar,
	/* 297*/ (void (*)(void))primitiveLoadInstVar,
	/* 298*/ (void (*)(void))primitiveLoadInstVar,
	/* 299*/ (void (*)(void))primitiveLoadInstVar,
	/* 300*/ (void (*)(void))primitiveLoadInstVar,
	/* 301*/ (void (*)(void))primitiveLoadInstVar,
	/* 302*/ (void (*)(void))primitiveLoadInstVar,
	/* 303*/ (void (*)(void))primitiveLoadInstVar,
	/* 304*/ (void (*)(void))primitiveLoadInstVar,
	/* 305*/ (void (*)(void))primitiveLoadInstVar,
	/* 306*/ (void (*)(void))primitiveLoadInstVar,
	/* 307*/ (void (*)(void))primitiveLoadInstVar,
	/* 308*/ (void (*)(void))primitiveLoadInstVar,
	/* 309*/ (void (*)(void))primitiveLoadInstVar,
	/* 310*/ (void (*)(void))primitiveLoadInstVar,
	/* 311*/ (void (*)(void))primitiveLoadInstVar,
	/* 312*/ (void (*)(void))primitiveLoadInstVar,
	/* 313*/ (void (*)(void))primitiveLoadInstVar,
	/* 314*/ (void (*)(void))primitiveLoadInstVar,
	/* 315*/ (void (*)(void))primitiveLoadInstVar,
	/* 316*/ (void (*)(void))primitiveLoadInstVar,
	/* 317*/ (void (*)(void))primitiveLoadInstVar,
	/* 318*/ (void (*)(void))primitiveLoadInstVar,
	/* 319*/ (void (*)(void))primitiveLoadInstVar,
	/* 320*/ (void (*)(void))primitiveLoadInstVar,
	/* 321*/ (void (*)(void))primitiveLoadInstVar,
	/* 322*/ (void (*)(void))primitiveLoadInstVar,
	/* 323*/ (void (*)(void))primitiveLoadInstVar,
	/* 324*/ (void (*)(void))primitiveLoadInstVar,
	/* 325*/ (void (*)(void))primitiveLoadInstVar,
	/* 326*/ (void (*)(void))primitiveLoadInstVar,
	/* 327*/ (void (*)(void))primitiveLoadInstVar,
	/* 328*/ (void (*)(void))primitiveLoadInstVar,
	/* 329*/ (void (*)(void))primitiveLoadInstVar,
	/* 330*/ (void (*)(void))primitiveLoadInstVar,
	/* 331*/ (void (*)(void))primitiveLoadInstVar,
	/* 332*/ (void (*)(void))primitiveLoadInstVar,
	/* 333*/ (void (*)(void))primitiveLoadInstVar,
	/* 334*/ (void (*)(void))primitiveLoadInstVar,
	/* 335*/ (void (*)(void))primitiveLoadInstVar,
	/* 336*/ (void (*)(void))primitiveLoadInstVar,
	/* 337*/ (void (*)(void))primitiveLoadInstVar,
	/* 338*/ (void (*)(void))primitiveLoadInstVar,
	/* 339*/ (void (*)(void))primitiveLoadInstVar,
	/* 340*/ (void (*)(void))primitiveLoadInstVar,
	/* 341*/ (void (*)(void))primitiveLoadInstVar,
	/* 342*/ (void (*)(void))primitiveLoadInstVar,
	/* 343*/ (void (*)(void))primitiveLoadInstVar,
	/* 344*/ (void (*)(void))primitiveLoadInstVar,
	/* 345*/ (void (*)(void))primitiveLoadInstVar,
	/* 346*/ (void (*)(void))primitiveLoadInstVar,
	/* 347*/ (void (*)(void))primitiveLoadInstVar,
	/* 348*/ (void (*)(void))primitiveLoadInstVar,
	/* 349*/ (void (*)(void))primitiveLoadInstVar,
	/* 350*/ (void (*)(void))primitiveLoadInstVar,
	/* 351*/ (void (*)(void))primitiveLoadInstVar,
	/* 352*/ (void (*)(void))primitiveLoadInstVar,
	/* 353*/ (void (*)(void))primitiveLoadInstVar,
	/* 354*/ (void (*)(void))primitiveLoadInstVar,
	/* 355*/ (void (*)(void))primitiveLoadInstVar,
	/* 356*/ (void (*)(void))primitiveLoadInstVar,
	/* 357*/ (void (*)(void))primitiveLoadInstVar,
	/* 358*/ (void (*)(void))primitiveLoadInstVar,
	/* 359*/ (void (*)(void))primitiveLoadInstVar,
	/* 360*/ (void (*)(void))primitiveLoadInstVar,
	/* 361*/ (void (*)(void))primitiveLoadInstVar,
	/* 362*/ (void (*)(void))primitiveLoadInstVar,
	/* 363*/ (void (*)(void))primitiveLoadInstVar,
	/* 364*/ (void (*)(void))primitiveLoadInstVar,
	/* 365*/ (void (*)(void))primitiveLoadInstVar,
	/* 366*/ (void (*)(void))primitiveLoadInstVar,
	/* 367*/ (void (*)(void))primitiveLoadInstVar,
	/* 368*/ (void (*)(void))primitiveLoadInstVar,
	/* 369*/ (void (*)(void))primitiveLoadInstVar,
	/* 370*/ (void (*)(void))primitiveLoadInstVar,
	/* 371*/ (void (*)(void))primitiveLoadInstVar,
	/* 372*/ (void (*)(void))primitiveLoadInstVar,
	/* 373*/ (void (*)(void))primitiveLoadInstVar,
	/* 374*/ (void (*)(void))primitiveLoadInstVar,
	/* 375*/ (void (*)(void))primitiveLoadInstVar,
	/* 376*/ (void (*)(void))primitiveLoadInstVar,
	/* 377*/ (void (*)(void))primitiveLoadInstVar,
	/* 378*/ (void (*)(void))primitiveLoadInstVar,
	/* 379*/ (void (*)(void))primitiveLoadInstVar,
	/* 380*/ (void (*)(void))primitiveLoadInstVar,
	/* 381*/ (void (*)(void))primitiveLoadInstVar,
	/* 382*/ (void (*)(void))primitiveLoadInstVar,
	/* 383*/ (void (*)(void))primitiveLoadInstVar,
	/* 384*/ (void (*)(void))primitiveLoadInstVar,
	/* 385*/ (void (*)(void))primitiveLoadInstVar,
	/* 386*/ (void (*)(void))primitiveLoadInstVar,
	/* 387*/ (void (*)(void))primitiveLoadInstVar,
	/* 388*/ (void (*)(void))primitiveLoadInstVar,
	/* 389*/ (void (*)(void))primitiveLoadInstVar,
	/* 390*/ (void (*)(void))primitiveLoadInstVar,
	/* 391*/ (void (*)(void))primitiveLoadInstVar,
	/* 392*/ (void (*)(void))primitiveLoadInstVar,
	/* 393*/ (void (*)(void))primitiveLoadInstVar,
	/* 394*/ (void (*)(void))primitiveLoadInstVar,
	/* 395*/ (void (*)(void))primitiveLoadInstVar,
	/* 396*/ (void (*)(void))primitiveLoadInstVar,
	/* 397*/ (void (*)(void))primitiveLoadInstVar,
	/* 398*/ (void (*)(void))primitiveLoadInstVar,
	/* 399*/ (void (*)(void))primitiveLoadInstVar,
	/* 400*/ (void (*)(void))primitiveLoadInstVar,
	/* 401*/ (void (*)(void))primitiveLoadInstVar,
	/* 402*/ (void (*)(void))primitiveLoadInstVar,
	/* 403*/ (void (*)(void))primitiveLoadInstVar,
	/* 404*/ (void (*)(void))primitiveLoadInstVar,
	/* 405*/ (void (*)(void))primitiveLoadInstVar,
	/* 406*/ (void (*)(void))primitiveLoadInstVar,
	/* 407*/ (void (*)(void))primitiveLoadInstVar,
	/* 408*/ (void (*)(void))primitiveLoadInstVar,
	/* 409*/ (void (*)(void))primitiveLoadInstVar,
	/* 410*/ (void (*)(void))primitiveLoadInstVar,
	/* 411*/ (void (*)(void))primitiveLoadInstVar,
	/* 412*/ (void (*)(void))primitiveLoadInstVar,
	/* 413*/ (void (*)(void))primitiveLoadInstVar,
	/* 414*/ (void (*)(void))primitiveLoadInstVar,
	/* 415*/ (void (*)(void))primitiveLoadInstVar,
	/* 416*/ (void (*)(void))primitiveLoadInstVar,
	/* 417*/ (void (*)(void))primitiveLoadInstVar,
	/* 418*/ (void (*)(void))primitiveLoadInstVar,
	/* 419*/ (void (*)(void))primitiveLoadInstVar,
	/* 420*/ (void (*)(void))primitiveLoadInstVar,
	/* 421*/ (void (*)(void))primitiveLoadInstVar,
	/* 422*/ (void (*)(void))primitiveLoadInstVar,
	/* 423*/ (void (*)(void))primitiveLoadInstVar,
	/* 424*/ (void (*)(void))primitiveLoadInstVar,
	/* 425*/ (void (*)(void))primitiveLoadInstVar,
	/* 426*/ (void (*)(void))primitiveLoadInstVar,
	/* 427*/ (void (*)(void))primitiveLoadInstVar,
	/* 428*/ (void (*)(void))primitiveLoadInstVar,
	/* 429*/ (void (*)(void))primitiveLoadInstVar,
	/* 430*/ (void (*)(void))primitiveLoadInstVar,
	/* 431*/ (void (*)(void))primitiveLoadInstVar,
	/* 432*/ (void (*)(void))primitiveLoadInstVar,
	/* 433*/ (void (*)(void))primitiveLoadInstVar,
	/* 434*/ (void (*)(void))primitiveLoadInstVar,
	/* 435*/ (void (*)(void))primitiveLoadInstVar,
	/* 436*/ (void (*)(void))primitiveLoadInstVar,
	/* 437*/ (void (*)(void))primitiveLoadInstVar,
	/* 438*/ (void (*)(void))primitiveLoadInstVar,
	/* 439*/ (void (*)(void))primitiveLoadInstVar,
	/* 440*/ (void (*)(void))primitiveLoadInstVar,
	/* 441*/ (void (*)(void))primitiveLoadInstVar,
	/* 442*/ (void (*)(void))primitiveLoadInstVar,
	/* 443*/ (void (*)(void))primitiveLoadInstVar,
	/* 444*/ (void (*)(void))primitiveLoadInstVar,
	/* 445*/ (void (*)(void))primitiveLoadInstVar,
	/* 446*/ (void (*)(void))primitiveLoadInstVar,
	/* 447*/ (void (*)(void))primitiveLoadInstVar,
	/* 448*/ (void (*)(void))primitiveLoadInstVar,
	/* 449*/ (void (*)(void))primitiveLoadInstVar,
	/* 450*/ (void (*)(void))primitiveLoadInstVar,
	/* 451*/ (void (*)(void))primitiveLoadInstVar,
	/* 452*/ (void (*)(void))primitiveLoadInstVar,
	/* 453*/ (void (*)(void))primitiveLoadInstVar,
	/* 454*/ (void (*)(void))primitiveLoadInstVar,
	/* 455*/ (void (*)(void))primitiveLoadInstVar,
	/* 456*/ (void (*)(void))primitiveLoadInstVar,
	/* 457*/ (void (*)(void))primitiveLoadInstVar,
	/* 458*/ (void (*)(void))primitiveLoadInstVar,
	/* 459*/ (void (*)(void))primitiveLoadInstVar,
	/* 460*/ (void (*)(void))primitiveLoadInstVar,
	/* 461*/ (void (*)(void))primitiveLoadInstVar,
	/* 462*/ (void (*)(void))primitiveLoadInstVar,
	/* 463*/ (void (*)(void))primitiveLoadInstVar,
	/* 464*/ (void (*)(void))primitiveLoadInstVar,
	/* 465*/ (void (*)(void))primitiveLoadInstVar,
	/* 466*/ (void (*)(void))primitiveLoadInstVar,
	/* 467*/ (void (*)(void))primitiveLoadInstVar,
	/* 468*/ (void (*)(void))primitiveLoadInstVar,
	/* 469*/ (void (*)(void))primitiveLoadInstVar,
	/* 470*/ (void (*)(void))primitiveLoadInstVar,
	/* 471*/ (void (*)(void))primitiveLoadInstVar,
	/* 472*/ (void (*)(void))primitiveLoadInstVar,
	/* 473*/ (void (*)(void))primitiveLoadInstVar,
	/* 474*/ (void (*)(void))primitiveLoadInstVar,
	/* 475*/ (void (*)(void))primitiveLoadInstVar,
	/* 476*/ (void (*)(void))primitiveLoadInstVar,
	/* 477*/ (void (*)(void))primitiveLoadInstVar,
	/* 478*/ (void (*)(void))primitiveLoadInstVar,
	/* 479*/ (void (*)(void))primitiveLoadInstVar,
	/* 480*/ (void (*)(void))primitiveLoadInstVar,
	/* 481*/ (void (*)(void))primitiveLoadInstVar,
	/* 482*/ (void (*)(void))primitiveLoadInstVar,
	/* 483*/ (void (*)(void))primitiveLoadInstVar,
	/* 484*/ (void (*)(void))primitiveLoadInstVar,
	/* 485*/ (void (*)(void))primitiveLoadInstVar,
	/* 486*/ (void (*)(void))primitiveLoadInstVar,
	/* 487*/ (void (*)(void))primitiveLoadInstVar,
	/* 488*/ (void (*)(void))primitiveLoadInstVar,
	/* 489*/ (void (*)(void))primitiveLoadInstVar,
	/* 490*/ (void (*)(void))primitiveLoadInstVar,
	/* 491*/ (void (*)(void))primitiveLoadInstVar,
	/* 492*/ (void (*)(void))primitiveLoadInstVar,
	/* 493*/ (void (*)(void))primitiveLoadInstVar,
	/* 494*/ (void (*)(void))primitiveLoadInstVar,
	/* 495*/ (void (*)(void))primitiveLoadInstVar,
	/* 496*/ (void (*)(void))primitiveLoadInstVar,
	/* 497*/ (void (*)(void))primitiveLoadInstVar,
	/* 498*/ (void (*)(void))primitiveLoadInstVar,
	/* 499*/ (void (*)(void))primitiveLoadInstVar,
	/* 500*/ (void (*)(void))primitiveLoadInstVar,
	/* 501*/ (void (*)(void))primitiveLoadInstVar,
	/* 502*/ (void (*)(void))primitiveLoadInstVar,
	/* 503*/ (void (*)(void))primitiveLoadInstVar,
	/* 504*/ (void (*)(void))primitiveLoadInstVar,
	/* 505*/ (void (*)(void))primitiveLoadInstVar,
	/* 506*/ (void (*)(void))primitiveLoadInstVar,
	/* 507*/ (void (*)(void))primitiveLoadInstVar,
	/* 508*/ (void (*)(void))primitiveLoadInstVar,
	/* 509*/ (void (*)(void))primitiveLoadInstVar,
	/* 510*/ (void (*)(void))primitiveLoadInstVar,
	/* 511*/ (void (*)(void))primitiveLoadInstVar,
	/* 512*/ (void (*)(void))primitiveLoadInstVar,
	/* 513*/ (void (*)(void))primitiveLoadInstVar,
	/* 514*/ (void (*)(void))primitiveLoadInstVar,
	/* 515*/ (void (*)(void))primitiveLoadInstVar,
	/* 516*/ (void (*)(void))primitiveLoadInstVar,
	/* 517*/ (void (*)(void))primitiveLoadInstVar,
	/* 518*/ (void (*)(void))primitiveLoadInstVar,
	/* 519*/ (void (*)(void))primitiveLoadInstVar,
	/* 520*/ (void (*)(void))primitiveFail,
	/* 521*/ (void (*)(void))primitiveFail,
	/* 522*/ (void (*)(void))primitiveFail,
	/* 523*/ (void (*)(void))primitiveFail,
	/* 524*/ (void (*)(void))primitiveFail,
	/* 525*/ (void (*)(void))primitiveFail,
	/* 526*/ (void (*)(void))primitiveFail,
	/* 527*/ (void (*)(void))primitiveFail,
	/* 528*/ (void (*)(void))primitiveFail,
	/* 529*/ (void (*)(void))primitiveFail,
	/* 530*/ (void (*)(void))primitiveFail,
	/* 531*/ (void (*)(void))primitiveFail,
	/* 532*/ (void (*)(void))primitiveFail,
	/* 533*/ (void (*)(void))primitiveFail,
	/* 534*/ (void (*)(void))primitiveFail,
	/* 535*/ (void (*)(void))primitiveFail,
	/* 536*/ (void (*)(void))primitiveFail,
	/* 537*/ (void (*)(void))primitiveFail,
	/* 538*/ (void (*)(void))primitiveFail,
	/* 539*/ (void (*)(void))primitiveFail,
	/* 540*/ (void (*)(void))primitiveFail,
	/* 541*/ (void (*)(void))primitiveFail,
	/* 542*/ (void (*)(void))primitiveFail,
	/* 543*/ (void (*)(void))primitiveFail,
	/* 544*/ (void (*)(void))primitiveFail,
	/* 545*/ (void (*)(void))primitiveFail,
	/* 546*/ (void (*)(void))primitiveFail,
	/* 547*/ (void (*)(void))primitiveFail,
	/* 548*/ (void (*)(void))primitiveFail,
	/* 549*/ (void (*)(void))primitiveFail,
	/* 550*/ (void (*)(void))primitiveFail,
	/* 551*/ (void (*)(void))primitiveFail,
	/* 552*/ (void (*)(void))primitiveFail,
	/* 553*/ (void (*)(void))primitiveFail,
	/* 554*/ (void (*)(void))primitiveFail,
	/* 555*/ (void (*)(void))primitiveFail,
	/* 556*/ (void (*)(void))primitiveFail,
	/* 557*/ (void (*)(void))primitiveFail,
	/* 558*/ (void (*)(void))primitiveFail,
	/* 559*/ (void (*)(void))primitiveFail,
	/* 560*/ (void (*)(void))primitiveFail,
	/* 561*/ (void (*)(void))primitiveFail,
	/* 562*/ (void (*)(void))primitiveFail,
	/* 563*/ (void (*)(void))primitiveFail,
	/* 564*/ (void (*)(void))primitiveFail,
	/* 565*/ (void (*)(void))primitiveFail,
	/* 566*/ (void (*)(void))primitiveFail,
	/* 567*/ (void (*)(void))primitiveFail,
	/* 568*/ (void (*)(void))primitiveFail,
	/* 569*/ (void (*)(void))primitiveFail,
	/* 570*/ (void (*)(void))primitiveFlushExternalPrimitives,
	/* 571*/ (void (*)(void))primitiveUnloadModule,
	/* 572*/ (void (*)(void))primitiveListBuiltinModule,
	/* 573*/ (void (*)(void))primitiveListExternalModule,
	/* 574*/ (void (*)(void))primitiveFail,
	/* 575*/ (void (*)(void))primitiveFail,
 0 };
sqInt receiver;
sqInt receiverClass;
sqInt reclaimableContextCount;
sqInt remapBuffer[26];
sqInt remapBufferCount;
sqInt rootTable[2501];
sqInt rootTableCount;
sqInt rootTableOverflowed;
sqInt savedWindowSize;
sqInt semaphoresToSignalA[501];
sqInt semaphoresToSignalB[501];
sqInt semaphoresToSignalCountA;
sqInt semaphoresToSignalCountB;
sqInt semaphoresUseBufferA;
void* showSurfaceFn;
usqInt shrinkThreshold;
sqInt signalLowSpace;
sqInt specialObjectsOop;
usqInt stackPointer;
sqInt statAllocationCount;
sqInt statCompMoveCount;
sqLong statFullGCMSecs;
sqInt statFullGCUsecs;
sqInt statFullGCs;
sqLong statGCTime;
sqInt statGrowMemory;
sqLong statIGCDeltaTime;
sqInt statIGCDeltaUsecs;
sqLong statIncrGCMSecs;
sqInt statIncrGCUsecs;
sqInt statIncrGCs;
sqInt statMarkCount;
sqInt statMkFwdCount;
sqInt statRootTableCount;
sqInt statRootTableOverflows;
sqInt statShrinkMemory;
sqInt statSpecialMarkCount;
sqInt statSurvivorCount;
sqInt statSweepCount;
sqInt statTenures;
sqInt statpendingFinalizationSignals;
sqInt suspendedCallbacks[33];
sqInt suspendedMethods[33];
sqInt tenuringThreshold;
usqInt theHomeContext;
sqInt totalObjectCount;
sqInt trueObj;
sqInt weakRootCount;
sqInt weakRoots[2625];
usqInt youngStart;



/*	Similar to activateNewMethod but for Closure and newMethod. */

sqInt activateNewClosureMethod(sqInt blockClosure) {
    sqInt closureMethod;
    sqInt i;
    sqInt methodHeader;
    sqInt newContext;
    sqInt numCopied;
    sqInt outerContext;
    sqInt theBlockClosure;
    sqInt where;
    sqInt oop;
    sqInt tmp;
    sqInt valuePointer;

	if (DoAssertionChecks) {
		okayOop(blockClosure);
	}
	outerContext = longAt((blockClosure + (BASE_HEADER_SIZE)) + (ClosureOuterContextIndex << (SHIFT_FOR_WORD)));
	if (DoAssertionChecks) {
		okayOop(outerContext);
	}
	closureMethod = longAt((outerContext + (BASE_HEADER_SIZE)) + (MethodIndex << (SHIFT_FOR_WORD)));
	methodHeader = longAt((closureMethod + (BASE_HEADER_SIZE)) + (HeaderIndex << (SHIFT_FOR_WORD)));
	/* begin pushRemappableOop: */
	remapBuffer[(remapBufferCount += 1)] = blockClosure;

	/* All for one, and one for all! */
	/* allocateOrRecycleContext: may cause a GC; restore blockClosure and refetch outerContext et al */

	newContext = allocateOrRecycleContext(methodHeader & LargeContextBit);
	/* begin popRemappableOop */
	oop = remapBuffer[remapBufferCount];
	remapBufferCount -= 1;
	theBlockClosure = oop;
	outerContext = longAt((theBlockClosure + (BASE_HEADER_SIZE)) + (ClosureOuterContextIndex << (SHIFT_FOR_WORD)));

	/* Assume: newContext will be recorded as a root if necessary by the
	 call to newActiveContext: below, so we can use unchecked stores. */

	numCopied = (fetchWordLengthOf(theBlockClosure)) - ClosureFirstCopiedValueIndex;
	where = newContext + (BASE_HEADER_SIZE);
	longAtput(where + (SenderIndex << (SHIFT_FOR_WORD)), activeContext);
	longAtput(where + (InstructionPointerIndex << (SHIFT_FOR_WORD)), longAt((theBlockClosure + (BASE_HEADER_SIZE)) + (ClosureStartPCIndex << (SHIFT_FOR_WORD))));
	longAtput(where + (StackPointerIndex << (SHIFT_FOR_WORD)), (((argumentCount + numCopied) << 1) | 1));
	longAtput(where + (MethodIndex << (SHIFT_FOR_WORD)), longAt((outerContext + (BASE_HEADER_SIZE)) + (MethodIndex << (SHIFT_FOR_WORD))));
	longAtput(where + (ClosureIndex << (SHIFT_FOR_WORD)), theBlockClosure);
	longAtput(where + (ReceiverIndex << (SHIFT_FOR_WORD)), longAt((outerContext + (BASE_HEADER_SIZE)) + (ReceiverIndex << (SHIFT_FOR_WORD))));
	for (i = 1; i <= argumentCount; i += 1) {
		longAtput(where + ((ReceiverIndex + i) << (SHIFT_FOR_WORD)), longAt(stackPointer - ((argumentCount - i) * (BYTES_PER_WORD))));
	}
	where = (newContext + (BASE_HEADER_SIZE)) + (((ReceiverIndex + 1) + argumentCount) << (SHIFT_FOR_WORD));
	for (i = 0; i <= (numCopied - 1); i += 1) {
		longAtput(where + (i << (SHIFT_FOR_WORD)), longAt((theBlockClosure + (BASE_HEADER_SIZE)) + ((i + ClosureFirstCopiedValueIndex) << (SHIFT_FOR_WORD))));
	}
	/* begin pop: */
	stackPointer -= (argumentCount + 1) * (BYTES_PER_WORD);
	/* begin newActiveContext: */
	/* begin storeContextRegisters: */
	longAtput((activeContext + (BASE_HEADER_SIZE)) + (InstructionPointerIndex << (SHIFT_FOR_WORD)), ((((instructionPointer - method) - ((BASE_HEADER_SIZE) - 2)) << 1) | 1));
	/* begin storePointerUnchecked:ofObject:withValue: */
	valuePointer = (((((((usqInt) ((stackPointer - activeContext) - (BASE_HEADER_SIZE))) >> (SHIFT_FOR_WORD)) - TempFrameStart) + 1) << 1) | 1);
	longAtput((activeContext + (BASE_HEADER_SIZE)) + (StackPointerIndex << (SHIFT_FOR_WORD)), valuePointer);
	if ((((usqInt) newContext)) < (((usqInt) youngStart))) {
		beRootIfOld(newContext);
	}
	activeContext = newContext;
	/* begin fetchContextRegisters: */
	tmp = longAt((newContext + (BASE_HEADER_SIZE)) + (MethodIndex << (SHIFT_FOR_WORD)));
	if ((tmp & 1)) {
		tmp = longAt((newContext + (BASE_HEADER_SIZE)) + (HomeIndex << (SHIFT_FOR_WORD)));
		if ((((usqInt) tmp)) < (((usqInt) youngStart))) {
			beRootIfOld(tmp);
		}
	} else {
		tmp = newContext;
	}
	theHomeContext = tmp;
	receiver = longAt((tmp + (BASE_HEADER_SIZE)) + (ReceiverIndex << (SHIFT_FOR_WORD)));
	method = (usqInt)longAt((tmp + (BASE_HEADER_SIZE)) + (MethodIndex << (SHIFT_FOR_WORD)));
	tmp = ((longAt((newContext + (BASE_HEADER_SIZE)) + (InstructionPointerIndex << (SHIFT_FOR_WORD)))) >> 1);
	instructionPointer = (usqInt)((method + tmp) + (BASE_HEADER_SIZE)) - 2;
	tmp = ((longAt((newContext + (BASE_HEADER_SIZE)) + (StackPointerIndex << (SHIFT_FOR_WORD)))) >> 1);
	stackPointer = (usqInt)(newContext + (BASE_HEADER_SIZE)) + (((TempFrameStart + tmp) - 1) * (BYTES_PER_WORD));
	return null;
}

sqInt activateNewMethod(void) {
    sqInt i;
    sqInt initialIP;
    sqInt methodHeader;
    sqInt newContext;
    sqInt nilOop;
    sqInt tempCount;
    sqInt where;
    sqInt tmp;
    sqInt valuePointer;

	methodHeader = longAt((newMethod + (BASE_HEADER_SIZE)) + (HeaderIndex << (SHIFT_FOR_WORD)));
	newContext = allocateOrRecycleContext(methodHeader & LargeContextBit);
	initialIP = ((LiteralStart + ((((usqInt) methodHeader) >> 10) & 255)) * (BYTES_PER_WORD)) + 1;

	/* Assume: newContext will be recorded as a root if necessary by the
	 call to newActiveContext: below, so we can use unchecked stores. */

	tempCount = (((usqInt) methodHeader) >> 19) & 63;
	where = newContext + (BASE_HEADER_SIZE);
	longAtput(where + (SenderIndex << (SHIFT_FOR_WORD)), activeContext);
	longAtput(where + (InstructionPointerIndex << (SHIFT_FOR_WORD)), ((initialIP << 1) | 1));
	longAtput(where + (StackPointerIndex << (SHIFT_FOR_WORD)), ((tempCount << 1) | 1));
	longAtput(where + (MethodIndex << (SHIFT_FOR_WORD)), newMethod);
	longAtput(where + (ClosureIndex << (SHIFT_FOR_WORD)), nilObj);
	for (i = 0; i <= argumentCount; i += 1) {
		longAtput(where + ((ReceiverIndex + i) << (SHIFT_FOR_WORD)), longAt(stackPointer - ((argumentCount - i) * (BYTES_PER_WORD))));
	}
	nilOop = nilObj;
	for (i = ((argumentCount + 1) + ReceiverIndex); i <= (tempCount + ReceiverIndex); i += 1) {
		longAtput(where + (i << (SHIFT_FOR_WORD)), nilOop);
	}
	/* begin pop: */
	stackPointer -= (argumentCount + 1) * (BYTES_PER_WORD);
	reclaimableContextCount += 1;
	/* begin newActiveContext: */
	/* begin storeContextRegisters: */
	longAtput((activeContext + (BASE_HEADER_SIZE)) + (InstructionPointerIndex << (SHIFT_FOR_WORD)), ((((instructionPointer - method) - ((BASE_HEADER_SIZE) - 2)) << 1) | 1));
	/* begin storePointerUnchecked:ofObject:withValue: */
	valuePointer = (((((((usqInt) ((stackPointer - activeContext) - (BASE_HEADER_SIZE))) >> (SHIFT_FOR_WORD)) - TempFrameStart) + 1) << 1) | 1);
	longAtput((activeContext + (BASE_HEADER_SIZE)) + (StackPointerIndex << (SHIFT_FOR_WORD)), valuePointer);
	if ((((usqInt) newContext)) < (((usqInt) youngStart))) {
		beRootIfOld(newContext);
	}
	activeContext = newContext;
	/* begin fetchContextRegisters: */
	tmp = longAt((newContext + (BASE_HEADER_SIZE)) + (MethodIndex << (SHIFT_FOR_WORD)));
	if ((tmp & 1)) {
		tmp = longAt((newContext + (BASE_HEADER_SIZE)) + (HomeIndex << (SHIFT_FOR_WORD)));
		if ((((usqInt) tmp)) < (((usqInt) youngStart))) {
			beRootIfOld(tmp);
		}
	} else {
		tmp = newContext;
	}
	theHomeContext = tmp;
	receiver = longAt((tmp + (BASE_HEADER_SIZE)) + (ReceiverIndex << (SHIFT_FOR_WORD)));
	method = (usqInt)longAt((tmp + (BASE_HEADER_SIZE)) + (MethodIndex << (SHIFT_FOR_WORD)));
	tmp = ((longAt((newContext + (BASE_HEADER_SIZE)) + (InstructionPointerIndex << (SHIFT_FOR_WORD)))) >> 1);
	instructionPointer = (usqInt)((method + tmp) + (BASE_HEADER_SIZE)) - 2;
	tmp = ((longAt((newContext + (BASE_HEADER_SIZE)) + (StackPointerIndex << (SHIFT_FOR_WORD)))) >> 1);
	stackPointer = (usqInt)(newContext + (BASE_HEADER_SIZE)) + (((TempFrameStart + tmp) - 1) * (BYTES_PER_WORD));
	return null;
}


/*	Declared in Cross/sqVirtualMachine but not implemented in platform support */
/*	void  (*addHighPriorityTickee)(void (*ticker)(void), unsigned periodms); */

EXPORT(sqInt) addHighPriorityTickee(void *ticker, unsigned periodms) {
	flag("FIXME");
	return 1;
}


/*	Declared in Cross/sqVirtualMachine but not implemented in platform support */
/*	void  (*addSynchronousTickee)(void (*ticker)(void), unsigned periodms, unsigned roundms); */

EXPORT(sqInt) addSynchronousTickee(void *ticker, unsigned periodms, unsigned roundms) {
	flag("FIXME");
	return 1;
}


/*	Add the given variable location to the extra roots table */

EXPORT(sqInt) addGCRoot(sqInt *varLoc) {
	if (extraRootCount >= ExtraRootSize) {
		return 0;
	}
	extraRoots[(extraRootCount += 1)] = varLoc;
	return 1;
}


/*	Add the given entry to the method cache.
	The policy is as follows:
		Look for an empty entry anywhere in the reprobe chain.
		If found, install the new entry there.
		If not found, then install the new entry at the first probe position
			and delete the entries in the rest of the reprobe chain.
		This has two useful purposes:
			If there is active contention over the first slot, the second
				or third will likely be free for reentry after ejection.
			Also, flushing is good when reprobe chains are getting full. */

sqInt addNewMethodToCache(void) {
    sqInt hash;
    sqInt p;
    sqInt probe;

	compilerInitialized && (compilerTranslateMethod());

	/* drop low-order zeros from addresses */

	hash = messageSelector ^ lkupClass;
	primitiveFunctionPointer = primitiveTable[primitiveIndex];
	for (p = 0; p <= (CacheProbeMax - 1); p += 1) {
		probe = (((usqInt) hash) >> p) & MethodCacheMask;
		if ((methodCache[probe + MethodCacheSelector]) == 0) {

			/* Found an empty entry -- use it */

			methodCache[probe + MethodCacheSelector] = messageSelector;
			methodCache[probe + MethodCacheClass] = lkupClass;
			methodCache[probe + MethodCacheMethod] = newMethod;
			methodCache[probe + MethodCachePrim] = primitiveIndex;
			methodCache[probe + MethodCacheNative] = newNativeMethod;
			methodCache[probe + MethodCachePrimFunction] = (((long) primitiveFunctionPointer));
			return null;
		}
	}

	/* first probe */

	probe = hash & MethodCacheMask;
	methodCache[probe + MethodCacheSelector] = messageSelector;
	methodCache[probe + MethodCacheClass] = lkupClass;
	methodCache[probe + MethodCacheMethod] = newMethod;
	methodCache[probe + MethodCachePrim] = primitiveIndex;
	methodCache[probe + MethodCacheNative] = newNativeMethod;
	methodCache[probe + MethodCachePrimFunction] = (((long) primitiveFunctionPointer));
	for (p = 1; p <= (CacheProbeMax - 1); p += 1) {
		probe = (((usqInt) hash) >> p) & MethodCacheMask;
		methodCache[probe + MethodCacheSelector] = 0;
	}
	return null;
}


/*	Add the given function address to the external primitive table and return the index where it's stored. This function doesn't need to be fast since it is only called when an external primitive has been looked up (which takes quite a bit of time itself). So there's nothing specifically complicated here.
	Note: Return index will be one-based (ST convention) */

sqInt addToExternalPrimitiveTable(void (*functionAddress)(void)) {
    sqInt i;

	for (i = 0; i <= (MaxExternalPrimitiveTableSize - 1); i += 1) {
		if ((externalPrimitiveTable[i]) == 0) {
			externalPrimitiveTable[i] = functionAddress;
			return i + 1;
		}
	}
	return 0;
}


/*	Answer if address appears to be that of an object, which implies it is
	 safe to fetch the class and size. For code disassembly and assertions. */

sqInt addressCouldBeObj(sqInt address) {
	return ((address & 3) == 0) && (((((usqInt)address)) >= memory) && (((((usqInt)address)) < freeBlock) && (((longAt(address)) & TypeMask) != HeaderTypeGC)));
}


/*	Adjust all oop references by the given number of bytes. This 
	is done just after reading in an image when the new base 
	address of the object heap is different from the base address 
	in the image. */
/*	di 11/18/2000 - return number of objects found */

sqInt adjustAllOopsBy(sqInt bytesToShift) {
    sqInt oop;
    sqInt totalObjects;
    sqInt classHeader;
    sqInt fieldAddr;
    sqInt fieldOop;
    sqInt newClassOop;
    sqInt sz;
    sqInt header;

	if (bytesToShift == 0) {
		return 300000;
	}
	totalObjects = 0;
	oop = memory + (headerTypeBytes[(longAt(memory)) & TypeMask]);
	while ((((usqInt) oop)) < (((usqInt) endOfMemory))) {
		if (!(((longAt(oop)) & TypeMask) == HeaderTypeFree)) {
			totalObjects += 1;
			/* begin adjustFieldsAndClassOf:by: */
			if (bytesToShift == 0) {
				goto l1;
			}
			fieldAddr = oop + (lastPointerOf(oop));
			while ((((usqInt) fieldAddr)) > (((usqInt) oop))) {
				fieldOop = longAt(fieldAddr);
				if (!((fieldOop & 1))) {
					longAtput(fieldAddr, fieldOop + bytesToShift);
				}
				fieldAddr -= BYTES_PER_WORD;
			}
			if (((longAt(oop)) & TypeMask) != HeaderTypeShort) {
				classHeader = longAt(oop - (BYTES_PER_WORD));
				newClassOop = (classHeader & (ALL_BUT_TYPE_MASK)) + bytesToShift;
				longAtput(oop - (BYTES_PER_WORD), newClassOop | (classHeader & TypeMask));
			}
		l1:	/* end adjustFieldsAndClassOf:by: */;
		}
		/* begin objectAfter: */
		if (DoAssertionChecks) {
			if ((((usqInt) oop)) >= (((usqInt) endOfMemory))) {
				error("no objects after the end of memory");
			}
		}
		if (((longAt(oop)) & TypeMask) == HeaderTypeFree) {
			sz = (longAt(oop)) & (ALL_BUT_TYPE_MASK);
		} else {
			/* begin sizeBitsOf: */
			header = longAt(oop);
			if ((header & TypeMask) == HeaderTypeSizeAndClass) {
				sz = (longAt(oop - ((BYTES_PER_WORD) * 2))) & (LONG_SIZE_MASK);
				goto l2;
			} else {
				sz = header & (SIZE_MASK);
				goto l2;
			}
		l2:	/* end sizeBitsOf: */;
		}
		oop = (oop + sz) + (headerTypeBytes[(longAt(oop + sz)) & TypeMask]);
	}
	return totalObjects;
}


/*	Return true if all the oops in both arrays, and the arrays 
	themselves, are in the young object space. */

sqInt allYoungand(sqInt array1, sqInt array2) {
    sqInt fieldOffset;
    sqInt contextSize;
    sqInt fmt;
    sqInt header;
    sqInt methodHeader;
    sqInt sz;
    sqInt sp;
    sqInt header1;
    sqInt type;

	if ((((usqInt) array1)) < (((usqInt) youngStart))) {
		return 0;
	}
	if ((((usqInt) array2)) < (((usqInt) youngStart))) {
		return 0;
	}
	/* begin lastPointerOf: */
	header = longAt(array1);
	fmt = (((usqInt) header) >> 8) & 15;
	if (fmt <= 4) {
		if ((fmt == 3) && ((((((usqInt) header) >> 12) & 31) == 13) || ((((((usqInt) header) >> 12) & 31) == 14) || (((((usqInt) header) >> 12) & 31) == 4)))) {
			/* begin fetchStackPointerOf: */
			sp = longAt((array1 + (BASE_HEADER_SIZE)) + (StackPointerIndex << (SHIFT_FOR_WORD)));
			if (!((sp & 1))) {
				contextSize = 0;
				goto l1;
			}
			contextSize = (sp >> 1);
		l1:	/* end fetchStackPointerOf: */;
			fieldOffset = (CtxtTempFrameStart + contextSize) * (BYTES_PER_WORD);
			goto l2;
		}
		/* begin sizeBitsOfSafe: */
		header1 = longAt(array1);
		/* begin rightType: */
		if ((header1 & (SIZE_MASK)) == 0) {
			type = HeaderTypeSizeAndClass;
			goto l3;
		} else {
			if ((header1 & CompactClassMask) == 0) {
				type = HeaderTypeClass;
				goto l3;
			} else {
				type = HeaderTypeShort;
				goto l3;
			}
		}
	l3:	/* end rightType: */;
		if (type == HeaderTypeSizeAndClass) {
			sz = (longAt(array1 - ((BYTES_PER_WORD) * 2))) & (ALL_BUT_TYPE_MASK);
			goto l4;
		} else {
			sz = header1 & (SIZE_MASK);
			goto l4;
		}
	l4:	/* end sizeBitsOfSafe: */;
		fieldOffset = sz - (BASE_HEADER_SIZE);
		goto l2;
	}
	if (fmt < 12) {
		fieldOffset = 0;
		goto l2;
	}
	methodHeader = longAt(array1 + (BASE_HEADER_SIZE));
	fieldOffset = (((((usqInt) methodHeader) >> 10) & 255) * (BYTES_PER_WORD)) + (BASE_HEADER_SIZE);
l2:	/* end lastPointerOf: */;
	while (fieldOffset >= (BASE_HEADER_SIZE)) {
		if ((((usqInt) (longAt(array1 + fieldOffset)))) < (((usqInt) youngStart))) {
			return 0;
		}
		if ((((usqInt) (longAt(array2 + fieldOffset)))) < (((usqInt) youngStart))) {
			return 0;
		}
		fieldOffset -= BYTES_PER_WORD;
	}
	return 1;
}


/*	Allocate a chunk of the given size. Sender must be sure that  the requested size includes enough space for the header  word(s).  */
/*	Details: To limit the time per incremental GC, do one every so many allocations. The number is settable via primitiveVMParameter to tune your memory system */

sqInt allocateChunk(sqInt byteSize) {
    sqInt enoughSpace;
    sqInt newChunk;
    sqInt newFreeSize;
    usqInt minFree;
    sqInt currentProc;
    sqInt lastSavedProcess;
    sqInt sched;
    sqInt oop;

	if (allocationCount >= allocationsBetweenGCs) {

		/* do an incremental GC every so many allocations to  keep pauses short */

		incrementalGC();
	}
	/* begin sufficientSpaceToAllocate: */
	minFree = (lowSpaceThreshold + byteSize) + (BASE_HEADER_SIZE);
	if (oopisGreaterThanOrEqualTo((longAt(freeBlock)) & (ALL_BUT_TYPE_MASK), minFree)) {
		enoughSpace = 1;
		goto l1;
	} else {
		enoughSpace = sufficientSpaceAfterGC(minFree);
		goto l1;
	}
l1:	/* end sufficientSpaceToAllocate: */;
	if (!(enoughSpace)) {

		/* signal that space is running low, but proceed with allocation if possible */

		signalLowSpace = 1;

		/* disable additional interrupts until lowSpaceThreshold is reset by image */

		lowSpaceThreshold = 0;
		/* begin saveProcessSignalingLowSpace */
		lastSavedProcess = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ProcessSignalingLowSpace << (SHIFT_FOR_WORD)));
		if (lastSavedProcess == nilObj) {
			/* begin fetchPointer:ofObject: */
			oop = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (SchedulerAssociation << (SHIFT_FOR_WORD)));
			sched = longAt((oop + (BASE_HEADER_SIZE)) + (ValueIndex << (SHIFT_FOR_WORD)));
			currentProc = longAt((sched + (BASE_HEADER_SIZE)) + (ActiveProcessIndex << (SHIFT_FOR_WORD)));
			/* begin storePointer:ofObject:withValue: */
			if ((((usqInt) specialObjectsOop)) < (((usqInt) youngStart))) {
				possibleRootStoreIntovalue(specialObjectsOop, currentProc);
			}
			longAtput((specialObjectsOop + (BASE_HEADER_SIZE)) + (ProcessSignalingLowSpace << (SHIFT_FOR_WORD)), currentProc);
		}
		/* begin forceInterruptCheck */
		interruptCheckCounter = -1000;
		nextPollTick = 0;
	}
	if (oopisLessThan((longAt(freeBlock)) & (ALL_BUT_TYPE_MASK), byteSize + (BASE_HEADER_SIZE))) {
		error("out of memory");
	}
	newFreeSize = ((longAt(freeBlock)) & (ALL_BUT_TYPE_MASK)) - byteSize;
	newChunk = freeBlock;

	/* Assume: client will initialize object header of free chunk, so following is not needed: */
	/* self setSizeOfFree: newChunk to: byteSize. */

	freeBlock += byteSize;
	/* begin setSizeOfFree:to: */
	longAtput(freeBlock, (newFreeSize & (ALL_BUT_TYPE_MASK)) | HeaderTypeFree);
	allocationCount += 1;
	return newChunk;
}


/*	Return a recycled context or a newly allocated one if none is available for recycling. */

sqInt allocateOrRecycleContext(sqInt needsLarge) {
    sqInt cntxt;

	if (needsLarge == 0) {
		if (freeContexts != NilContext) {
			cntxt = freeContexts;
			freeContexts = longAt((cntxt + (BASE_HEADER_SIZE)) + (0 << (SHIFT_FOR_WORD)));
			return cntxt;
		}
	} else {
		if (freeLargeContexts != NilContext) {
			cntxt = freeLargeContexts;
			freeLargeContexts = longAt((cntxt + (BASE_HEADER_SIZE)) + (0 << (SHIFT_FOR_WORD)));
			return cntxt;
		}
	}
	if (needsLarge == 0) {
		cntxt = instantiateContextsizeInBytes(longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassMethodContext << (SHIFT_FOR_WORD))), SMALL_CONTEXT_SIZE);
	} else {
		cntxt = instantiateContextsizeInBytes(longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassMethodContext << (SHIFT_FOR_WORD))), LARGE_CONTEXT_SIZE);
	}
	longAtput((cntxt + (BASE_HEADER_SIZE)) + (4 << (SHIFT_FOR_WORD)), nilObj);
	return cntxt;
}


/*	Declared in Cross/sqVirtualMachine but not implemented in platform support */
/*	extern sqInt amInVMThread(void); */

EXPORT(sqInt) amInVMThread(void) {
	flag("FIXME");
	return 1;
}

sqInt argumentCountOf(sqInt methodPointer) {
	return (((usqInt) (longAt((methodPointer + (BASE_HEADER_SIZE)) + (HeaderIndex << (SHIFT_FOR_WORD))))) >> 25) & 15;
}


/*	Return the address of first indexable field of resulting array object, or fail if the instance variable does not contain an indexable bytes or words object. */
/*	Note: May be called by translated primitive code. */

void * arrayValueOf(sqInt arrayOop) {
	if ((!((arrayOop & 1))) && (((arrayOop & 1) == 0) && (isWordsOrBytesNonInt(arrayOop)))) {
		return pointerForOop(arrayOop + (BASE_HEADER_SIZE));
	}
	/* begin primitiveFail */
	if (primFailCode == 0) {
		primFailCode = 1;
	}
	return null;
}


/*	Returns an integer object */

sqInt asciiOfCharacter(sqInt characterObj) {
    sqInt classOop;
    sqInt ccIndex;
    sqInt cl;
    sqInt oop1;

	/* begin assertClassOf:is: */
	classOop = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassCharacter << (SHIFT_FOR_WORD)));
	if ((characterObj & 1)) {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		goto l1;
	}
	ccIndex = (((usqInt) (longAt(characterObj))) >> 12) & 31;
	if (ccIndex == 0) {
		cl = (longAt(characterObj - (BASE_HEADER_SIZE))) & (ALL_BUT_TYPE_MASK);
	} else {
		/* begin fetchPointer:ofObject: */
		oop1 = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (CompactClasses << (SHIFT_FOR_WORD)));
		cl = longAt((oop1 + (BASE_HEADER_SIZE)) + ((ccIndex - 1) << (SHIFT_FOR_WORD)));
	}
	/* begin success: */
	if (!(cl == classOop)) {
		if (!primFailCode) {
			primFailCode = 1;
		}
	}
l1:	/* end assertClassOf:is: */;
	if (!primFailCode) {
		return longAt((characterObj + (BASE_HEADER_SIZE)) + (CharacterValueIndex << (SHIFT_FOR_WORD)));
	} else {
		return ConstZero;
	}
	return null;
}


/*	Return true if the stack is still balanced after executing primitive primIndex with nArgs args. Delta is 'stackPointer - activeContext' which is a relative measure for the stack pointer (so we don't have to relocate it during the primitive) */

sqInt balancedStackafterPrimitivewithArgs(sqInt delta, sqInt primIdx, sqInt nArgs) {
	if ((primIdx >= 81) && (primIdx <= 88)) {
		return 1;
	}
	if (!primFailCode) {

		/* Successful prim, stack must have exactly nArgs arguments popped off */

		return ((stackPointer - activeContext) + (nArgs * (BYTES_PER_WORD))) == delta;
	}
	return (stackPointer - activeContext) == delta;
}


/*	If this object is old, mark it as a root (because a new object 
	may be stored into it) */

sqInt beRootIfOld(sqInt oop) {
    sqInt header;

	if (((((usqInt) oop)) < (((usqInt) youngStart))) && (!((oop & 1)))) {

		/* Yes, oop is an old object */

		/* begin noteAsRoot:headerLoc: */
		header = longAt(oop);
		if ((header & (ROOT_BIT)) == 0) {
			if (rootTableCount < RootTableRedZone) {
				rootTableCount += 1;
				rootTable[rootTableCount] = oop;
				longAtput(oop, header | (ROOT_BIT));
			} else {
				if (rootTableCount < RootTableSize) {
					rootTableCount += 1;
					rootTable[rootTableCount] = oop;
					longAtput(oop, header | (ROOT_BIT));
					allocationCount = allocationsBetweenGCs + 1;
				}
			}
		}
	}
	return null;
}


/*	Record that the given oop in the old object area points to an object in the young area when oop may be forwarded. */
/*	Warning: No young objects should be recorded as roots. Callers are responsible for ensuring this constraint is not violated. */

sqInt beRootWhileForwarding(sqInt oop) {
    sqInt fwdBlock;
    sqInt header;
    sqInt header1;
    sqInt header2;

	header = longAt(oop);
	if ((header & (MARK_BIT)) != 0) {

		/* This oop is forwarded */

		fwdBlock = (header & (ALL_BUT_MARK_BIT_AND_TYPE_MASK)) << 1;
		if (DoAssertionChecks) {
			/* begin fwdBlockValidate: */
			if (!(((((usqInt) fwdBlock)) > (((usqInt) endOfMemory))) && (((((usqInt) fwdBlock)) <= (((usqInt) fwdTableNext))) && ((fwdBlock & 3) == 0)))) {
				error("invalid fwd table entry");
			}
		}
		/* begin noteAsRoot:headerLoc: */
		header1 = longAt(fwdBlock + (BYTES_PER_WORD));
		if ((header1 & (ROOT_BIT)) == 0) {
			if (rootTableCount < RootTableRedZone) {
				rootTableCount += 1;
				rootTable[rootTableCount] = oop;
				longAtput(fwdBlock + (BYTES_PER_WORD), header1 | (ROOT_BIT));
			} else {
				if (rootTableCount < RootTableSize) {
					rootTableCount += 1;
					rootTable[rootTableCount] = oop;
					longAtput(fwdBlock + (BYTES_PER_WORD), header1 | (ROOT_BIT));
					allocationCount = allocationsBetweenGCs + 1;
				}
			}
		}
	} else {

		/* Normal -- no forwarding */

		/* begin noteAsRoot:headerLoc: */
		header2 = longAt(oop);
		if ((header2 & (ROOT_BIT)) == 0) {
			if (rootTableCount < RootTableRedZone) {
				rootTableCount += 1;
				rootTable[rootTableCount] = oop;
				longAtput(oop, header2 | (ROOT_BIT));
			} else {
				if (rootTableCount < RootTableSize) {
					rootTableCount += 1;
					rootTable[rootTableCount] = oop;
					longAtput(oop, header2 | (ROOT_BIT));
					allocationCount = allocationsBetweenGCs + 1;
				}
			}
		}
	}
	return null;
}

sqInt becomewith(sqInt array1, sqInt array2) {
	return becomewithtwoWaycopyHash(array1, array2, 1, 1);
}


/*	All references to each object in array1 are swapped with all references to the corresponding object in array2. That is, all pointers to one object are replaced with with pointers to the other. The arguments must be arrays of the same length. 
	Returns true if the primitive succeeds. */
/*	Implementation: Uses forwarding blocks to update references as done in compaction. */

sqInt becomewithtwoWaycopyHash(sqInt array1, sqInt array2, sqInt twoWayFlag, sqInt copyHashFlag) {
    sqInt fieldOffset;
    sqInt hdr1;
    sqInt hdr2;
    sqInt oop1;
    sqInt oop2;
    sqInt fwdBlock;
    sqInt hdr11;
    sqInt hdr21;
    sqInt oop11;
    sqInt oop21;
    sqInt contextSize;
    sqInt fmt;
    sqInt header;
    sqInt methodHeader;
    sqInt sz;
    sqInt sp;
    sqInt header1;
    sqInt type;

	if (!(((array1 & 1) == 0) && (((((usqInt) (longAt(array1))) >> 8) & 15) == 2))) {
		return 0;
	}
	if (!(((array2 & 1) == 0) && (((((usqInt) (longAt(array2))) >> 8) & 15) == 2))) {
		return 0;
	}
	if (!((lastPointerOf(array1)) == (lastPointerOf(array2)))) {
		return 0;
	}
	if (!(containOnlyOopsand(array1, array2))) {
		return 0;
	}
	if (!(prepareForwardingTableForBecomingwithtwoWay(array1, array2, twoWayFlag))) {
		return 0;
	}
	if (allYoungand(array1, array2)) {

		/* sweep only the young objects plus the roots */

		mapPointersInObjectsFromto((sqInt)youngStart, (sqInt)endOfMemory);
	} else {

		/* sweep all objects */

		mapPointersInObjectsFromto((sqInt)memory, (sqInt)endOfMemory);
	}
	if (twoWayFlag) {
		/* begin restoreHeadersAfterBecoming:with: */
		/* begin lastPointerOf: */
		header = longAt(array1);
		fmt = (((usqInt) header) >> 8) & 15;
		if (fmt <= 4) {
			if ((fmt == 3) && ((((((usqInt) header) >> 12) & 31) == 13) || ((((((usqInt) header) >> 12) & 31) == 14) || (((((usqInt) header) >> 12) & 31) == 4)))) {
				/* begin fetchStackPointerOf: */
				sp = longAt((array1 + (BASE_HEADER_SIZE)) + (StackPointerIndex << (SHIFT_FOR_WORD)));
				if (!((sp & 1))) {
					contextSize = 0;
					goto l1;
				}
				contextSize = (sp >> 1);
			l1:	/* end fetchStackPointerOf: */;
				fieldOffset = (CtxtTempFrameStart + contextSize) * (BYTES_PER_WORD);
				goto l2;
			}
			/* begin sizeBitsOfSafe: */
			header1 = longAt(array1);
			/* begin rightType: */
			if ((header1 & (SIZE_MASK)) == 0) {
				type = HeaderTypeSizeAndClass;
				goto l3;
			} else {
				if ((header1 & CompactClassMask) == 0) {
					type = HeaderTypeClass;
					goto l3;
				} else {
					type = HeaderTypeShort;
					goto l3;
				}
			}
		l3:	/* end rightType: */;
			if (type == HeaderTypeSizeAndClass) {
				sz = (longAt(array1 - ((BYTES_PER_WORD) * 2))) & (ALL_BUT_TYPE_MASK);
				goto l4;
			} else {
				sz = header1 & (SIZE_MASK);
				goto l4;
			}
		l4:	/* end sizeBitsOfSafe: */;
			fieldOffset = sz - (BASE_HEADER_SIZE);
			goto l2;
		}
		if (fmt < 12) {
			fieldOffset = 0;
			goto l2;
		}
		methodHeader = longAt(array1 + (BASE_HEADER_SIZE));
		fieldOffset = (((((usqInt) methodHeader) >> 10) & 255) * (BYTES_PER_WORD)) + (BASE_HEADER_SIZE);
	l2:	/* end lastPointerOf: */;
		while (fieldOffset >= (BASE_HEADER_SIZE)) {
			oop1 = longAt(array1 + fieldOffset);
			oop2 = longAt(array2 + fieldOffset);
			if (!(oop1 == oop2)) {
				restoreHeaderOf(oop1);
				restoreHeaderOf(oop2);
				hdr1 = longAt(oop1);
				hdr2 = longAt(oop2);
				longAtput(oop1, (hdr1 & (ALL_BUT_HASH_BITS)) | (hdr2 & HashBits));
				longAtput(oop2, (hdr2 & (ALL_BUT_HASH_BITS)) | (hdr1 & HashBits));
			}
			fieldOffset -= BYTES_PER_WORD;
		}
	} else {
		/* begin restoreHeadersAfterForwardBecome: */
		fwdBlock = ((endOfMemory + (BASE_HEADER_SIZE)) + 7) & ((WORD_MASK) - 7);
		flag("Dan");
		fwdBlock += (BYTES_PER_WORD) * 4;
		while ((((usqInt) fwdBlock)) <= (((usqInt) fwdTableNext))) {
			oop11 = longAt(fwdBlock + ((BYTES_PER_WORD) * 2));
			oop21 = longAt(fwdBlock);
			restoreHeaderOf(oop11);
			if (copyHashFlag) {
				hdr11 = longAt(oop11);
				hdr21 = longAt(oop21);
				longAtput(oop21, (hdr21 & (ALL_BUT_HASH_BITS)) | (hdr11 & HashBits));
			}
			fwdBlock += (BYTES_PER_WORD) * 4;
		}
	}
	initializeMemoryFirstFree(freeBlock);
	/* begin forceInterruptCheck */
	interruptCheckCounter = -1000;
	nextPollTick = 0;
	return 1;
}

sqInt biasToGrow(void) {
    usqInt growSize;

	growSize = (((sqInt) (growHeadroom * 3) >> 1)) - ((longAt(freeBlock)) & (ALL_BUT_TYPE_MASK));
	if (growSize > 0) {
		growObjectMemory(growSize);
	}
	return null;
}


/*	convert true and false (Smalltalk) to true or false(C) */

sqInt booleanValueOf(sqInt obj) {
	if (obj == trueObj) {
		return 1;
	}
	if (obj == falseObj) {
		return 0;
	}
	/* begin primitiveFail */
	if (primFailCode == 0) {
		primFailCode = 1;
	}
	return null;
}

sqInt byteSizeOf(sqInt oop) {
    sqInt slots;
    sqInt header;
    sqInt sz;

	flag("Dan");
	if ((oop & 1)) {
		return 0;
	}
	/* begin slotSizeOf: */
	if ((oop & 1)) {
		slots = 0;
		goto l1;
	}
	/* begin lengthOf: */
	header = longAt(oop);
	/* begin lengthOf:baseHeader:format: */
	if ((header & TypeMask) == HeaderTypeSizeAndClass) {
		sz = (longAt(oop - ((BYTES_PER_WORD) * 2))) & (LONG_SIZE_MASK);
	} else {
		sz = header & (SIZE_MASK);
	}
	sz -= header & (SIZE_4_BIT);
	if (((((usqInt) header) >> 8) & 15) <= 4) {
		slots = ((usqInt) (sz - (BASE_HEADER_SIZE))) >> (SHIFT_FOR_WORD);
		goto l2;
	}
	if (((((usqInt) header) >> 8) & 15) < 8) {
		slots = ((usqInt) (sz - (BASE_HEADER_SIZE))) >> 2;
		goto l2;
	} else {
		slots = (sz - (BASE_HEADER_SIZE)) - (((((usqInt) header) >> 8) & 15) & 3);
		goto l2;
	}
l2:	/* end lengthOf:baseHeader:format: */;
l1:	/* end slotSizeOf: */;
	if (((((usqInt) (longAt(oop))) >> 8) & 15) >= 8) {
		return slots;
	} else {
		return slots * 4;
	}
	return null;
}


/*	Byte-swap the words of all bytes objects in a range of the 
	image, including Strings, ByteArrays, and CompiledMethods. 
	This returns these objects to their original byte ordering 
	after blindly byte-swapping the entire image. For compiled 
	methods, byte-swap only their bytecodes part. */

sqInt byteSwapByteObjectsFromto(sqInt startOop, sqInt stopAddr) {
    sqInt fmt;
    sqInt methodHeader;
    sqInt oop;
    sqInt wordAddr;
    sqInt stopAddr1;
    sqInt addr;
    sqInt stopAddr2;
    sqInt addr1;
    sqInt sz;
    sqInt header;

	oop = startOop;
	while ((((usqInt) oop)) < (((usqInt) stopAddr))) {
		if (!(((longAt(oop)) & TypeMask) == HeaderTypeFree)) {
			fmt = (((usqInt) (longAt(oop))) >> 8) & 15;
			if (fmt >= 8) {

				/* oop contains bytes */

				wordAddr = oop + (BASE_HEADER_SIZE);
				if (fmt >= 12) {

					/* compiled method; start after methodHeader and literals */

					methodHeader = longAt(oop + (BASE_HEADER_SIZE));
					wordAddr = (wordAddr + (BYTES_PER_WORD)) + (((((usqInt) methodHeader) >> 10) & 255) * (BYTES_PER_WORD));
				}
				/* begin reverseBytesFrom:to: */
				stopAddr1 = oop + (sizeBitsOf(oop));
				flag("Dan");
				addr = wordAddr;
				while ((((usqInt) addr)) < (((usqInt) stopAddr1))) {
					longAtput(addr, byteSwapped(longAt(addr)));
					addr += BYTES_PER_WORD;
				}
			}
			if ((fmt == 6) && ((BYTES_PER_WORD) == 8)) {

				/* Object contains 32-bit half-words packed into 64-bit machine words. */

				wordAddr = oop + (BASE_HEADER_SIZE);
				/* begin reverseWordsFrom:to: */
				stopAddr2 = oop + (sizeBitsOf(oop));
				addr1 = wordAddr;
				while ((((usqInt) addr1)) < (((usqInt) stopAddr2))) {
					longAtput(addr1, wordSwapped(longAt(addr1)));
					addr1 += BYTES_PER_WORD;
				}
			}
		}
		/* begin objectAfter: */
		if (DoAssertionChecks) {
			if ((((usqInt) oop)) >= (((usqInt) endOfMemory))) {
				error("no objects after the end of memory");
			}
		}
		if (((longAt(oop)) & TypeMask) == HeaderTypeFree) {
			sz = (longAt(oop)) & (ALL_BUT_TYPE_MASK);
		} else {
			/* begin sizeBitsOf: */
			header = longAt(oop);
			if ((header & TypeMask) == HeaderTypeSizeAndClass) {
				sz = (longAt(oop - ((BYTES_PER_WORD) * 2))) & (LONG_SIZE_MASK);
				goto l1;
			} else {
				sz = header & (SIZE_MASK);
				goto l1;
			}
		l1:	/* end sizeBitsOf: */;
		}
		oop = (oop + sz) + (headerTypeBytes[(longAt(oop + sz)) & TypeMask]);
	}
	return null;
}


/*	Answer the given integer with its bytes in the reverse order. */

sqInt byteSwapped(sqInt w) {
	
# if (BYTES_PER_WORD == 4)  // swap bytes in an object word
	return ((((((usqInt) w >> 24)) & Byte0Mask) + ((((usqInt) w >> 8)) & Byte1Mask)) + ((((usqInt) w << 8)) & Byte2Mask)) + ((((usqInt) w << 24)) & Byte3Mask);
# else
	return ((((((((((usqInt) w >> 56)) & Byte0Mask) + ((((usqInt) w >> 40)) & Byte1Mask)) + ((((usqInt) w >> 24)) & Byte2Mask)) + ((((usqInt) w >> 8)) & Byte3Mask)) + ((((usqInt) w << 8)) & Byte4Mask)) + ((((usqInt) w << 24)) & Byte5Mask)) + ((((usqInt) w << 40)) & Byte6Mask)) + ((((usqInt) w << 56)) & Byte7Mask);
# endif  // BYTES_PER_WORD == 4
	
	return null;
}


/*	Call the external plugin function identified. In the VM this is an address, see 	InterpreterSimulator for it's version.  */

sqInt callExternalPrimitive(void (*functionID)(void)) {
	dispatchFunctionPointer(functionID);
	return null;
}


/*	External call into the interpreter */

EXPORT(sqInt) callInterpreter(void) {
	interpret();
	return null;
}


/*	Re-enter the interpreter for executing a callback */

EXPORT(sqInt) callbackEnter(sqInt *callbackID) {
    sqInt activeProc;
    sqInt result;
    sqInt oop;
    sqInt oop1;
    sqInt oop2;
    sqInt oop3;
    sqInt priority;
    sqInt processList;
    sqInt processLists;
    sqInt oop4;
    sqInt oop11;
    sqInt lastLink;


	/* For now, do not allow a callback unless we're in a primitiveResponse */

	if (primitiveIndex == 0) {
		return 0;
	}
	if (jmpDepth >= jmpMax) {
		return 0;
	}

	/* Suspend the currently active process */

	jmpDepth += 1;
	/* begin fetchPointer:ofObject: */
	/* begin fetchPointer:ofObject: */
	oop2 = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (SchedulerAssociation << (SHIFT_FOR_WORD)));
	oop = longAt((oop2 + (BASE_HEADER_SIZE)) + (ValueIndex << (SHIFT_FOR_WORD)));
	activeProc = longAt((oop + (BASE_HEADER_SIZE)) + (ActiveProcessIndex << (SHIFT_FOR_WORD)));
	suspendedCallbacks[jmpDepth] = activeProc;
	suspendedMethods[jmpDepth] = newMethod;
	transferTo(wakeHighestPriority());
	/* begin forceInterruptCheck */
	interruptCheckCounter = -1000;
	nextPollTick = 0;
	result = setjmp(jmpBuf[jmpDepth]);
	if (result == 0) {

		/* Fill in callbackID */

		callbackID[0] = jmpDepth;
		interpret();
	}
	/* begin fetchPointer:ofObject: */
	/* begin fetchPointer:ofObject: */
	oop3 = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (SchedulerAssociation << (SHIFT_FOR_WORD)));
	oop1 = longAt((oop3 + (BASE_HEADER_SIZE)) + (ValueIndex << (SHIFT_FOR_WORD)));
	activeProc = longAt((oop1 + (BASE_HEADER_SIZE)) + (ActiveProcessIndex << (SHIFT_FOR_WORD)));
	/* begin putToSleep: */
	priority = ((longAt((activeProc + (BASE_HEADER_SIZE)) + (PriorityIndex << (SHIFT_FOR_WORD)))) >> 1);
	/* begin fetchPointer:ofObject: */
	/* begin fetchPointer:ofObject: */
	oop11 = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (SchedulerAssociation << (SHIFT_FOR_WORD)));
	oop4 = longAt((oop11 + (BASE_HEADER_SIZE)) + (ValueIndex << (SHIFT_FOR_WORD)));
	processLists = longAt((oop4 + (BASE_HEADER_SIZE)) + (ProcessListsIndex << (SHIFT_FOR_WORD)));
	processList = longAt((processLists + (BASE_HEADER_SIZE)) + ((priority - 1) << (SHIFT_FOR_WORD)));
	/* begin addLastLink:toList: */
	if ((longAt((processList + (BASE_HEADER_SIZE)) + (FirstLinkIndex << (SHIFT_FOR_WORD)))) == nilObj) {
		/* begin storePointer:ofObject:withValue: */
		if ((((usqInt) processList)) < (((usqInt) youngStart))) {
			possibleRootStoreIntovalue(processList, activeProc);
		}
		longAtput((processList + (BASE_HEADER_SIZE)) + (FirstLinkIndex << (SHIFT_FOR_WORD)), activeProc);
	} else {
		lastLink = longAt((processList + (BASE_HEADER_SIZE)) + (LastLinkIndex << (SHIFT_FOR_WORD)));
		/* begin storePointer:ofObject:withValue: */
		if ((((usqInt) lastLink)) < (((usqInt) youngStart))) {
			possibleRootStoreIntovalue(lastLink, activeProc);
		}
		longAtput((lastLink + (BASE_HEADER_SIZE)) + (NextLinkIndex << (SHIFT_FOR_WORD)), activeProc);
	}
	/* begin storePointer:ofObject:withValue: */
	if ((((usqInt) processList)) < (((usqInt) youngStart))) {
		possibleRootStoreIntovalue(processList, activeProc);
	}
	longAtput((processList + (BASE_HEADER_SIZE)) + (LastLinkIndex << (SHIFT_FOR_WORD)), activeProc);
	/* begin storePointer:ofObject:withValue: */
	if ((((usqInt) activeProc)) < (((usqInt) youngStart))) {
		possibleRootStoreIntovalue(activeProc, processList);
	}
	longAtput((activeProc + (BASE_HEADER_SIZE)) + (MyListIndex << (SHIFT_FOR_WORD)), processList);
	activeProc = suspendedCallbacks[jmpDepth];

	/* see comment above */

	newMethod = (usqInt)suspendedMethods[jmpDepth];
	transferTo(activeProc);
	jmpDepth -= 1;
	return 1;
}


/*	Leave from a previous callback */
/*	For now, do not allow a callback unless we're in a primitiveResponse */

EXPORT(sqInt) callbackLeave(sqInt cbID) {
	if (primitiveIndex == 0) {
		return 0;
	}
	if (!(cbID == jmpDepth)) {
		return 0;
	}
	if (cbID < 1) {
		return 0;
	}
	longjmp(jmpBuf[jmpDepth], 1);
	return null;
}


/*	Change the class of the receiver into the class specified by the argument given that the format of the receiver matches the format of the argument. Fail if receiver or argument are SmallIntegers, or the receiver is an instance of a compact class and the argument isn't, or when the argument's class is compact and the receiver isn't, or when the format of the receiver is different from the format of the argument's class, or when the arguments class is fixed and the receiver's size differs from the size that an instance of the argument's class should have. */
/*	Check what the format of the class says */

sqInt changeClassOfto(sqInt rcvr, sqInt argClass) {
    sqInt argFormat;
    sqInt byteSize;
    sqInt ccIndex;
    sqInt classHdr;
    sqInt rcvrFormat;
    sqInt sizeHiBits;


	/* Low 2 bits are 0 */
	/* Compute the size of instances of the class (used for fixed field classes only) */

	classHdr = (longAt((argClass + (BASE_HEADER_SIZE)) + (InstanceSpecificationIndex << (SHIFT_FOR_WORD)))) - 1;
	sizeHiBits = ((usqInt) (classHdr & 393216)) >> 9;
	classHdr = classHdr & 131071;

	/* size in bytes -- low 2 bits are 0 */
	/* Check the receiver's format against that of the class */

	byteSize = (classHdr & (SIZE_MASK)) + sizeHiBits;
	argFormat = (((usqInt) classHdr) >> 8) & 15;
	rcvrFormat = (((usqInt) (longAt(rcvr))) >> 8) & 15;
	if (!(argFormat == rcvrFormat)) {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		return null;
	}
	if (argFormat < 2) {
		if (!((byteSize - (BASE_HEADER_SIZE)) == (byteSizeOf(rcvr)))) {
			/* begin primitiveFail */
			if (primFailCode == 0) {
				primFailCode = 1;
			}
			return null;
		}
	}
	if (((longAt(rcvr)) & TypeMask) == HeaderTypeShort) {

		/* Compact classes. Check if the arg's class is compact and exchange ccIndex */

		ccIndex = classHdr & CompactClassMask;
		if (ccIndex == 0) {
			/* begin primitiveFail */
			if (primFailCode == 0) {
				primFailCode = 1;
			}
			return null;
		}
		longAtput(rcvr, ((longAt(rcvr)) & (~CompactClassMask)) | ccIndex);
	} else {

		/* Exchange the class pointer, which could make rcvr a root for argClass */

		longAtput(rcvr - (BASE_HEADER_SIZE), argClass | ((longAt(rcvr)) & TypeMask));
		if ((((usqInt) rcvr)) < (((usqInt) youngStart))) {
			possibleRootStoreIntovalue(rcvr, argClass);
		}
	}
	return null;
}


/*	Arg must lie in range 0-255! */

sqInt characterForAscii(sqInt ascii) {
    sqInt oop;

	/* begin fetchPointer:ofObject: */
	oop = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (CharacterTable << (SHIFT_FOR_WORD)));
	return longAt((oop + (BASE_HEADER_SIZE)) + (ascii << (SHIFT_FOR_WORD)));
}

sqInt characterTable(void) {
	return longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (CharacterTable << (SHIFT_FOR_WORD)));
}


/*	Check for possible interrupts and handle one if necessary. */

sqInt checkForInterrupts(void) {
    sqInt now;
    sqInt sema;
    sqInt i;
    sqInt index;
    sqInt sema1;
    sqInt xArray;
    sqInt xSize;


	/* Mask so same wrapping as primitiveMillisecondClock */

	now = (ioMSecs()) & MillisecondClockMask;
	if (!(interruptCheckCounter < -100)) {

		/* don't play with the feedback if we forced a check. It only makes life difficult */

		if ((now - lastTick) < interruptChecksEveryNms) {

			/* wrapping is not a concern, it'll get caught quickly  
				enough. This clause is trying to keep a reasonable  
				guess of how many times per 	interruptChecksEveryNms we are calling  
				quickCheckForInterrupts. Not sure how effective it really is. */

			interruptCheckCounterFeedBackReset += 10;
		} else {
			if (interruptCheckCounterFeedBackReset <= 1000) {
				interruptCheckCounterFeedBackReset = 1000;
			} else {
				interruptCheckCounterFeedBackReset -= 12;
			}
		}
	}
	interruptCheckCounter = interruptCheckCounterFeedBackReset;
	if (signalLowSpace) {
		/* begin setSignalLowSpace: */
		signalLowSpace = 0;
		sema = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (TheLowSpaceSemaphore << (SHIFT_FOR_WORD)));
		if (!(sema == nilObj)) {
			synchronousSignal(sema);
		}
	}
	if (now < lastTick) {

		/* millisecond clock wrapped so correct the nextPollTick */

		nextPollTick = (nextPollTick - MillisecondClockMask) - 1;
	}
	if (now >= nextPollTick) {
		ioProcessEvents();

		/* msecs to wait before next call to ioProcessEvents.  
			Note that strictly speaking we might need to update  
			'now' at this point since ioProcessEvents could take a  
			very long time on some platforms */

		nextPollTick = now + 200;
	}
	if (interruptPending) {

		/* reset interrupt flag */

		interruptPending = 0;
		sema = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (TheInterruptSemaphore << (SHIFT_FOR_WORD)));
		if (!(sema == nilObj)) {
			synchronousSignal(sema);
		}
	}
	if (nextWakeupTick != 0) {
		if (now < lastTick) {

			/* the clock has wrapped. Subtract the wrap  
					interval from nextWakeupTick - this might just  
					possibly result in 0. Since this is used as a flag  
					value for 'no timer' we do the 0 check above */

			nextWakeupTick = (nextWakeupTick - MillisecondClockMask) - 1;
		}
		if (now >= nextWakeupTick) {

			/* set timer interrupt to 0 for 'no timer' */

			nextWakeupTick = 0;
			sema = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (TheTimerSemaphore << (SHIFT_FOR_WORD)));
			if (!(sema == nilObj)) {
				synchronousSignal(sema);
			}
		}
	}
	if (pendingFinalizationSignals > 0) {
		sema = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (TheFinalizationSemaphore << (SHIFT_FOR_WORD)));
		if ((fetchClassOf(sema)) == (longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassSemaphore << (SHIFT_FOR_WORD))))) {
			synchronousSignal(sema);
		}
		pendingFinalizationSignals = 0;
	}
	if ((semaphoresToSignalCountA > 0) || (semaphoresToSignalCountB > 0)) {
		/* begin signalExternalSemaphores */
		semaphoresUseBufferA = !semaphoresUseBufferA;
		xArray = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ExternalObjectsArray << (SHIFT_FOR_WORD)));
		xSize = stSizeOf(xArray);
		if (semaphoresUseBufferA) {
			for (i = 1; i <= semaphoresToSignalCountB; i += 1) {
				index = semaphoresToSignalB[i];
				if (index <= xSize) {
					sema1 = longAt((xArray + (BASE_HEADER_SIZE)) + ((index - 1) << (SHIFT_FOR_WORD)));
					if ((fetchClassOf(sema1)) == (longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassSemaphore << (SHIFT_FOR_WORD))))) {
						synchronousSignal(sema1);
					}
				}
			}
			semaphoresToSignalCountB = 0;
		} else {
			for (i = 1; i <= semaphoresToSignalCountA; i += 1) {
				index = semaphoresToSignalA[i];
				if (index <= xSize) {
					sema1 = longAt((xArray + (BASE_HEADER_SIZE)) + ((index - 1) << (SHIFT_FOR_WORD)));
					if ((fetchClassOf(sema1)) == (longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassSemaphore << (SHIFT_FOR_WORD))))) {
						synchronousSignal(sema1);
					}
				}
			}
			semaphoresToSignalCountA = 0;
		}
	}
	lastTick = now;
	return null;
}


/*	Read and verify the image file version number and return true if the the given image file needs to be byte-swapped. As a side effect, position the file stream just after the version number of the image header. This code prints a warning and does a hard-exit if it cannot find a valid version number. */
/*	This code is based on C code by Ian Piumarta. */

sqInt checkImageVersionFromstartingAt(sqImageFile  f, squeakFileOffsetType  imageOffset) {
    sqInt firstVersion;


	/* check the version number */

	sqImageFileSeek(f, imageOffset);
	imageFormatInitialVersion = (firstVersion = getLongFromFileswap(f, 0));
	if (readableFormat(imageFormatInitialVersion)) {
		return 0;
	}
	sqImageFileSeek(f, imageOffset);
	imageFormatInitialVersion = getLongFromFileswap(f, 1);
	if (readableFormat(imageFormatInitialVersion)) {
		return 1;
	}
	if (imageOffset == 0) {

		/* try skipping the first 512 bytes (prepended by certain Mac file transfer utilities) */

		sqImageFileSeek(f, 512);
		imageFormatInitialVersion = getLongFromFileswap(f, 0);
		if (readableFormat(imageFormatInitialVersion)) {
			return 0;
		}
		sqImageFileSeek(f, 512);
		imageFormatInitialVersion = getLongFromFileswap(f, 1);
		if (readableFormat(imageFormatInitialVersion)) {
			return 1;
		}
	}
	print("This interpreter (vers. ");
	printNum(imageFormatVersionNumber);
	print(") cannot read image file (vers. ");
	printNum(firstVersion);
	print(").");
	/* begin cr */
	printf("\n");
	print("Press CR to quit...");
	getchar();
	ioExit();
	return null;
}


/*	Note: May be called by translated primitive code. */

sqInt checkedIntegerValueOf(sqInt intOop) {
	if ((intOop & 1)) {
		return (intOop >> 1);
	} else {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		return 0;
	}
	return null;
}


/*	Assumes zero-based array indexing. For testing in Smalltalk, this method should be overridden in a subclass. */

sqInt checkedLongAt(sqInt byteAddress) {
	/* begin checkAddress: */
	if ((((usqInt) byteAddress)) < (((usqInt) memory))) {
		error("bad address: negative");
	}
	if ((((usqInt) byteAddress)) >= (((usqInt) memoryLimit))) {
		error("bad address: past end of heap");
	}
	/* begin checkAddress: */
	if ((((usqInt) (byteAddress + 3))) < (((usqInt) memory))) {
		error("bad address: negative");
	}
	if ((((usqInt) (byteAddress + 3))) >= (((usqInt) memoryLimit))) {
		error("bad address: past end of heap");
	}
	return longAt(byteAddress);
}

sqInt classAlien(void) {
	return longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassAlien << (SHIFT_FOR_WORD)));
}

sqInt classArray(void) {
	return longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassArray << (SHIFT_FOR_WORD)));
}

sqInt classBitmap(void) {
	return longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassBitmap << (SHIFT_FOR_WORD)));
}

sqInt classByteArray(void) {
	return longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassByteArray << (SHIFT_FOR_WORD)));
}

sqInt classCharacter(void) {
	return longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassCharacter << (SHIFT_FOR_WORD)));
}

sqInt classExternalAddress(void) {
	return longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassExternalAddress << (SHIFT_FOR_WORD)));
}

sqInt classExternalData(void) {
	return longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassExternalData << (SHIFT_FOR_WORD)));
}

sqInt classExternalFunction(void) {
	return longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassExternalFunction << (SHIFT_FOR_WORD)));
}

sqInt classExternalLibrary(void) {
	return longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassExternalLibrary << (SHIFT_FOR_WORD)));
}

sqInt classExternalStructure(void) {
	return longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassExternalStructure << (SHIFT_FOR_WORD)));
}

sqInt classFloat(void) {
	return longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassFloat << (SHIFT_FOR_WORD)));
}

sqInt classLargeNegativeInteger(void) {
	return longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassLargeNegativeInteger << (SHIFT_FOR_WORD)));
}

sqInt classLargePositiveInteger(void) {
	return longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassLargePositiveInteger << (SHIFT_FOR_WORD)));
}


/*	Check if aClass's name is className */

sqInt classNameOfIs(sqInt aClass, char *className) {
    sqInt i;
    sqInt length;
    sqInt name;
    char *srcName;

	if ((lengthOf(aClass)) <= 6) {
		return 0;
	}
	name = longAt((aClass + (BASE_HEADER_SIZE)) + (6 << (SHIFT_FOR_WORD)));
	if (!(((name & 1) == 0) && (((((usqInt) (longAt(name))) >> 8) & 15) >= 8))) {
		return 0;
	}
	length = stSizeOf(name);
	srcName = ((char *) (arrayValueOf(name)));
	for (i = 0; i <= (length - 1); i += 1) {
		if (!((srcName[i]) == (className[i]))) {
			return 0;
		}
	}
	return (className[length]) == 0;
}

sqInt classPoint(void) {
	return longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassPoint << (SHIFT_FOR_WORD)));
}

sqInt classSemaphore(void) {
	return longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassSemaphore << (SHIFT_FOR_WORD)));
}

sqInt classSmallInteger(void) {
	return longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassInteger << (SHIFT_FOR_WORD)));
}

sqInt classString(void) {
	return longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassString << (SHIFT_FOR_WORD)));
}

sqInt classUnsafeAlien(void) {
	return longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassUnsafeAlien << (SHIFT_FOR_WORD)));
}


/*	Return a shallow copy of the given object. May cause GC */
/*	Assume: Oop is a real object, not a small integer. */

sqInt clone(sqInt oop) {
    usqInt bytes;
    sqInt extraHdrBytes;
    usqInt fromIndex;
    sqInt hash;
    sqInt header;
    usqInt lastFrom;
    sqInt newChunk;
    sqInt newOop;
    sqInt remappedOop;
    sqInt toIndex;
    sqInt header1;
    sqInt oop1;
    sqInt enoughSpace;
    sqInt newChunk1;
    sqInt newFreeSize;
    usqInt minFree;
    sqInt currentProc;
    sqInt lastSavedProcess;
    sqInt sched;
    sqInt oop2;

	extraHdrBytes = headerTypeBytes[(longAt(oop)) & TypeMask];
	/* begin sizeBitsOf: */
	header1 = longAt(oop);
	if ((header1 & TypeMask) == HeaderTypeSizeAndClass) {
		bytes = (longAt(oop - ((BYTES_PER_WORD) * 2))) & (LONG_SIZE_MASK);
		goto l1;
	} else {
		bytes = header1 & (SIZE_MASK);
		goto l1;
	}
l1:	/* end sizeBitsOf: */;

	/* allocate space for the copy, remapping oop in case of a GC */

	bytes += extraHdrBytes;
	/* begin pushRemappableOop: */
	remapBuffer[(remapBufferCount += 1)] = oop;
	if (!(sufficientSpaceToAllocate(2500 + bytes))) {
		return 0;
	}
	/* begin allocateChunk: */
	if (allocationCount >= allocationsBetweenGCs) {
		incrementalGC();
	}
	/* begin sufficientSpaceToAllocate: */
	minFree = (lowSpaceThreshold + bytes) + (BASE_HEADER_SIZE);
	if (oopisGreaterThanOrEqualTo((longAt(freeBlock)) & (ALL_BUT_TYPE_MASK), minFree)) {
		enoughSpace = 1;
		goto l2;
	} else {
		enoughSpace = sufficientSpaceAfterGC(minFree);
		goto l2;
	}
l2:	/* end sufficientSpaceToAllocate: */;
	if (!(enoughSpace)) {
		signalLowSpace = 1;
		lowSpaceThreshold = 0;
		/* begin saveProcessSignalingLowSpace */
		lastSavedProcess = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ProcessSignalingLowSpace << (SHIFT_FOR_WORD)));
		if (lastSavedProcess == nilObj) {
			/* begin fetchPointer:ofObject: */
			oop2 = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (SchedulerAssociation << (SHIFT_FOR_WORD)));
			sched = longAt((oop2 + (BASE_HEADER_SIZE)) + (ValueIndex << (SHIFT_FOR_WORD)));
			currentProc = longAt((sched + (BASE_HEADER_SIZE)) + (ActiveProcessIndex << (SHIFT_FOR_WORD)));
			/* begin storePointer:ofObject:withValue: */
			if ((((usqInt) specialObjectsOop)) < (((usqInt) youngStart))) {
				possibleRootStoreIntovalue(specialObjectsOop, currentProc);
			}
			longAtput((specialObjectsOop + (BASE_HEADER_SIZE)) + (ProcessSignalingLowSpace << (SHIFT_FOR_WORD)), currentProc);
		}
		/* begin forceInterruptCheck */
		interruptCheckCounter = -1000;
		nextPollTick = 0;
	}
	if (oopisLessThan((longAt(freeBlock)) & (ALL_BUT_TYPE_MASK), bytes + (BASE_HEADER_SIZE))) {
		error("out of memory");
	}
	newFreeSize = ((longAt(freeBlock)) & (ALL_BUT_TYPE_MASK)) - bytes;
	newChunk1 = freeBlock;
	freeBlock += bytes;
	/* begin setSizeOfFree:to: */
	longAtput(freeBlock, (newFreeSize & (ALL_BUT_TYPE_MASK)) | HeaderTypeFree);
	allocationCount += 1;
	newChunk = newChunk1;
	/* begin popRemappableOop */
	oop1 = remapBuffer[remapBufferCount];
	remapBufferCount -= 1;
	remappedOop = oop1;

	/* loop below uses pre-increment */

	toIndex = newChunk - (BYTES_PER_WORD);
	fromIndex = (remappedOop - extraHdrBytes) - (BYTES_PER_WORD);
	lastFrom = fromIndex + bytes;
	while (fromIndex < lastFrom) {
		longAtput((toIndex += BYTES_PER_WORD), longAt((fromIndex += BYTES_PER_WORD)));
	}

	/* convert from chunk to oop */
	/* fix base header: compute new hash and clear Mark and Root bits */

	newOop = newChunk + extraHdrBytes;
	/* begin newObjectHash */
	lastHash = (13849 + (27181 * lastHash)) & 65535;
	hash = lastHash;

	/* use old ccIndex, format, size, and header-type fields */

	header = (longAt(newOop)) & 131071;
	header = header | ((hash << 17) & 536739840);
	longAtput(newOop, header);
	return newOop;
}


/*	This code is called if the receiver responds primitively to at:.
	If this is so, it will be installed in the atCache so that subsequent calls of at:
	or next may be handled immediately in bytecode primitive routines. */

sqInt commonAt(sqInt stringy) {
    sqInt atIx;
    sqInt index;
    sqInt rcvr;
    sqInt result;
    sqInt sp;
    sqInt oop;
    sqInt sp1;


	/* Sets primFailCode */

	index = positive32BitValueOf(longAt(stackPointer));
	rcvr = longAt(stackPointer - (1 * (BYTES_PER_WORD)));
	if (!((!primFailCode) && (!((rcvr & 1))))) {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		return null;
	}
	if ((messageSelector == (fetchPointerofObject(16 * 2, longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (SpecialSelectors << (SHIFT_FOR_WORD)))))) && (lkupClass == (fetchClassOfNonInt(rcvr)))) {

		/* OK -- look in the at-cache */


		/* Index into atCache = 4N, for N = 0 ... 7 */

		atIx = rcvr & AtCacheMask;
		if (!((atCache[atIx + AtCacheOop]) == rcvr)) {

			/* Rcvr not in cache.  Install it... */

			installinAtCacheatstring(rcvr, (sqInt  *)atCache, atIx, stringy);
		}
		if (!primFailCode) {
			result = commonVariableatcacheIndex(rcvr, index, atIx);
		}
		if (!primFailCode) {
			/* begin pop:thenPush: */
			longAtput((sp = stackPointer - (((argumentCount + 1) - 1) * (BYTES_PER_WORD))), result);
			stackPointer = sp;
			return null;
		}
	}
	/* begin initPrimCall */
	primFailCode = 0;
	result = stObjectat(rcvr, index);
	if (!primFailCode) {
		if (stringy) {
			/* begin fetchPointer:ofObject: */
			oop = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (CharacterTable << (SHIFT_FOR_WORD)));
			result = longAt((oop + (BASE_HEADER_SIZE)) + (((result >> 1)) << (SHIFT_FOR_WORD)));
		}
		/* begin pop:thenPush: */
		longAtput((sp1 = stackPointer - (((argumentCount + 1) - 1) * (BYTES_PER_WORD))), result);
		stackPointer = sp1;
		return null;
	}
	return null;
}


/*	This code is called if the receiver responds primitively to at:Put:.
	If this is so, it will be installed in the atPutCache so that subsequent calls of at:
	or  next may be handled immediately in bytecode primitive routines. */

sqInt commonAtPut(sqInt stringy) {
    sqInt atIx;
    sqInt index;
    sqInt rcvr;
    sqInt value;
    sqInt sp;
    sqInt sp1;
    sqInt fixedFields;
    sqInt fmt;
    sqInt stSize;
    sqInt valToPut;

	value = longAt(stackPointer);

	/* Sets primFailCode */

	index = positive32BitValueOf(longAt(stackPointer - (1 * (BYTES_PER_WORD))));
	rcvr = longAt(stackPointer - (2 * (BYTES_PER_WORD)));
	if (!((!primFailCode) && (!((rcvr & 1))))) {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		return null;
	}
	if ((messageSelector == (fetchPointerofObject(17 * 2, longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (SpecialSelectors << (SHIFT_FOR_WORD)))))) && (lkupClass == (fetchClassOfNonInt(rcvr)))) {

		/* OK -- look in the at-cache */


		/* Index into atPutCache */

		atIx = (rcvr & AtCacheMask) + AtPutBase;
		if (!((atCache[atIx + AtCacheOop]) == rcvr)) {

			/* Rcvr not in cache.  Install it... */

			installinAtCacheatstring(rcvr, (sqInt  *)atCache, atIx, stringy);
		}
		if (!primFailCode) {
			/* begin commonVariable:at:put:cacheIndex: */
			stSize = atCache[atIx + AtCacheSize];
			if (((((usqInt) index)) >= (((usqInt) 1))) && ((((usqInt) index)) <= (((usqInt) stSize)))) {
				fmt = atCache[atIx + AtCacheFmt];
				if (fmt <= 4) {
					fixedFields = atCache[atIx + AtCacheFixedFields];
					/* begin storePointer:ofObject:withValue: */
					if ((((usqInt) rcvr)) < (((usqInt) youngStart))) {
						possibleRootStoreIntovalue(rcvr, value);
					}
					longAtput((rcvr + (BASE_HEADER_SIZE)) + (((index + fixedFields) - 1) << (SHIFT_FOR_WORD)), value);
					goto l1;
				}
				if (fmt < 8) {
					valToPut = positive32BitValueOf(value);
					if (!primFailCode) {
						long32Atput((rcvr + (BASE_HEADER_SIZE)) + ((index - 1) << 2), valToPut);
					}
					goto l1;
				}
				if (fmt >= 16) {
					valToPut = asciiOfCharacter(value);
					if (!(!primFailCode)) {
						goto l1;
					}
				} else {
					valToPut = value;
				}
				if ((valToPut & 1)) {
					valToPut = (valToPut >> 1);
					if (!((valToPut >= 0) && (valToPut <= 255))) {
						/* begin primitiveFail */
						if (primFailCode == 0) {
							primFailCode = 1;
						}
						goto l1;
					}
					byteAtput((rcvr + (BASE_HEADER_SIZE)) + (index - 1), valToPut);
					goto l1;
				}
			}
			/* begin primitiveFail */
			if (primFailCode == 0) {
				primFailCode = 1;
			}
		l1:	/* end commonVariable:at:put:cacheIndex: */;
		}
		if (!primFailCode) {
			/* begin pop:thenPush: */
			longAtput((sp = stackPointer - (((argumentCount + 1) - 1) * (BYTES_PER_WORD))), value);
			stackPointer = sp;
			return null;
		}
	}
	/* begin initPrimCall */
	primFailCode = 0;
	if (stringy) {
		stObjectatput(rcvr, index, asciiOfCharacter(value));
	} else {
		stObjectatput(rcvr, index, value);
	}
	if (!primFailCode) {
		/* begin pop:thenPush: */
		longAtput((sp1 = stackPointer - (((argumentCount + 1) - 1) * (BYTES_PER_WORD))), value);
		stackPointer = sp1;
		return null;
	}
	return null;
}


/*	This code assumes the receiver has been identified at location atIx in the atCache. */

sqInt commonVariableatcacheIndex(sqInt rcvr, sqInt index, sqInt atIx) {
    sqInt fixedFields;
    sqInt fmt;
    sqInt result;
    sqInt stSize;
    sqInt oop;

	stSize = atCache[atIx + AtCacheSize];
	if (((((usqInt) index)) >= (((usqInt) 1))) && ((((usqInt) index)) <= (((usqInt) stSize)))) {
		fmt = atCache[atIx + AtCacheFmt];
		if (fmt <= 4) {
			fixedFields = atCache[atIx + AtCacheFixedFields];
			return longAt((rcvr + (BASE_HEADER_SIZE)) + (((index + fixedFields) - 1) << (SHIFT_FOR_WORD)));
		}
		if (fmt < 8) {

			/* Bitmap */

			result = long32At((rcvr + (BASE_HEADER_SIZE)) + ((index - 1) << 2));
			result = positive32BitIntegerFor(result);
			return result;
		}
		if (fmt >= 16) {

			/* Note fmt >= 16 is an artificial flag for strings */
			/* String */

			/* begin fetchPointer:ofObject: */
			oop = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (CharacterTable << (SHIFT_FOR_WORD)));
			return longAt((oop + (BASE_HEADER_SIZE)) + ((byteAt((rcvr + (BASE_HEADER_SIZE)) + (index - 1))) << (SHIFT_FOR_WORD)));
		} else {

			/* ByteArray */

			return (((byteAt((rcvr + (BASE_HEADER_SIZE)) + (index - 1))) << 1) | 1);
		}
	}
	/* begin primitiveFail */
	if (primFailCode == 0) {
		primFailCode = 1;
	}
	return null;
}


/*	May set success to false */
/*	First compare two ST integers... */

sqInt compare31or32Bitsequal(sqInt obj1, sqInt obj2) {
	if (((obj1 & 1)) && ((obj2 & 1))) {
		return obj1 == obj2;
	}
	return (positive32BitValueOf(obj1)) == (positive32BitValueOf(obj2));
}

sqInt compilerCreateActualMessagestoringArgs(sqInt aMessage, sqInt argArray) {
	return compilerHooks[14](aMessage, argArray);
}

sqInt compilerFlushCache(sqInt aCompiledMethod) {
	return compilerHooks[2](aCompiledMethod);
}

sqInt compilerMapFromto(sqInt memStart, sqInt memEnd) {
	return compilerHooks[4](memStart, memEnd);
}

sqInt compilerMark(void) {
	return compilerHooks[9]();
}

sqInt compilerPostGC(void) {
	return compilerHooks[5]();
}

sqInt compilerPostSnapshot(void) {
	return compilerHooks[8]();
}

sqInt compilerPreGC(sqInt fullGCFlag) {
	return compilerHooks[3](fullGCFlag);
}

sqInt compilerPreSnapshot(void) {
	return compilerHooks[7]();
}

sqInt compilerProcessChange(void) {
	return compilerHooks[6]();
}

sqInt compilerProcessChangeto(sqInt oldProc, sqInt newProc) {
	return compilerHooks[6](oldProc, newProc);
}

sqInt compilerTranslateMethod(void) {
	return compilerHooks[1]();
}


/*	Return true if neither array contains a small integer. You 
	can't become: integers! */

sqInt containOnlyOopsand(sqInt array1, sqInt array2) {
    sqInt fieldOffset;
    sqInt contextSize;
    sqInt fmt;
    sqInt header;
    sqInt methodHeader;
    sqInt sz;
    sqInt sp;
    sqInt header1;
    sqInt type;

	/* begin lastPointerOf: */
	header = longAt(array1);
	fmt = (((usqInt) header) >> 8) & 15;
	if (fmt <= 4) {
		if ((fmt == 3) && ((((((usqInt) header) >> 12) & 31) == 13) || ((((((usqInt) header) >> 12) & 31) == 14) || (((((usqInt) header) >> 12) & 31) == 4)))) {
			/* begin fetchStackPointerOf: */
			sp = longAt((array1 + (BASE_HEADER_SIZE)) + (StackPointerIndex << (SHIFT_FOR_WORD)));
			if (!((sp & 1))) {
				contextSize = 0;
				goto l1;
			}
			contextSize = (sp >> 1);
		l1:	/* end fetchStackPointerOf: */;
			fieldOffset = (CtxtTempFrameStart + contextSize) * (BYTES_PER_WORD);
			goto l2;
		}
		/* begin sizeBitsOfSafe: */
		header1 = longAt(array1);
		/* begin rightType: */
		if ((header1 & (SIZE_MASK)) == 0) {
			type = HeaderTypeSizeAndClass;
			goto l3;
		} else {
			if ((header1 & CompactClassMask) == 0) {
				type = HeaderTypeClass;
				goto l3;
			} else {
				type = HeaderTypeShort;
				goto l3;
			}
		}
	l3:	/* end rightType: */;
		if (type == HeaderTypeSizeAndClass) {
			sz = (longAt(array1 - ((BYTES_PER_WORD) * 2))) & (ALL_BUT_TYPE_MASK);
			goto l4;
		} else {
			sz = header1 & (SIZE_MASK);
			goto l4;
		}
	l4:	/* end sizeBitsOfSafe: */;
		fieldOffset = sz - (BASE_HEADER_SIZE);
		goto l2;
	}
	if (fmt < 12) {
		fieldOffset = 0;
		goto l2;
	}
	methodHeader = longAt(array1 + (BASE_HEADER_SIZE));
	fieldOffset = (((((usqInt) methodHeader) >> 10) & 255) * (BYTES_PER_WORD)) + (BASE_HEADER_SIZE);
l2:	/* end lastPointerOf: */;
	while (fieldOffset >= (BASE_HEADER_SIZE)) {
		if (((longAt(array1 + fieldOffset)) & 1)) {
			return 0;
		}
		if (((longAt(array2 + fieldOffset)) & 1)) {
			return 0;
		}
		fieldOffset -= BYTES_PER_WORD;
	}
	return 1;
}


/*	Does thisCntx have aContext in its sender chain? */

sqInt contexthasSender(sqInt thisCntx, sqInt aContext) {
    sqInt nilOop;
    sqInt s;

	if (thisCntx == aContext) {
		return 0;
	}
	nilOop = nilObj;
	s = longAt((thisCntx + (BASE_HEADER_SIZE)) + (SenderIndex << (SHIFT_FOR_WORD)));
	while (!(s == nilOop)) {
		if (s == aContext) {
			return 1;
		}
		s = longAt((s + (BASE_HEADER_SIZE)) + (SenderIndex << (SHIFT_FOR_WORD)));
	}
	return 0;
}


/*	This entry point needs to be implemented for the interpreter proxy.
	Since BitBlt is now a plugin we need to look up BitBltPlugin:=copyBits
	and call it. This entire mechanism should eventually go away and be
	replaced with a dynamic lookup from BitBltPlugin itself but for backward
	compatibility this stub is provided */

sqInt copyBits(void) {
    void *fn;

	fn = ioLoadFunctionFrom("copyBits", "BitBltPlugin");
	if (fn == 0) {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		return null;
	}
	return ((sqInt (*)(void))fn)();
}


/*	This entry point needs to be implemented for the interpreter proxy.
	Since BitBlt is now a plugin we need to look up BitBltPlugin:=copyBitsFrom:to:at:
	and call it. This entire mechanism should eventually go away and be
	replaced with a dynamic lookup from BitBltPlugin itself but for backward
	compatibility this stub is provided */

sqInt copyBitsFromtoat(sqInt x0, sqInt x1, sqInt y) {
    void *fn;

	fn = ioLoadFunctionFrom("copyBitsFromtoat", "BitBltPlugin");
	if (fn == 0) {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		return null;
	}
	return ((sqInt (*)(sqInt, sqInt, sqInt))fn)(x0, x1, y);
}


/*	Copy this object into the segment beginning at lastSeg.
	Install a forwarding pointer, and save oop and header.
	Fail if out of space.  Return the next segmentAddr if successful. */
/*	Copy the object... */

sqInt copyObjtoSegmentaddrstopAtsaveOopAtheaderAt(sqInt oop, sqInt segmentWordArray, sqInt lastSeg, sqInt stopAddr, sqInt oopPtr, sqInt hdrPtr) {
    sqInt bodySize;
    sqInt extraSize;
    sqInt hdrAddr;
    sqInt header;
    sqInt in;
    sqInt lastIn;
    sqInt out;

	flag("Dan");
	if (!(!primFailCode)) {
		return lastSeg;
	}
	extraSize = headerTypeBytes[(longAt(oop)) & TypeMask];
	/* begin sizeBitsOf: */
	header = longAt(oop);
	if ((header & TypeMask) == HeaderTypeSizeAndClass) {
		bodySize = (longAt(oop - ((BYTES_PER_WORD) * 2))) & (LONG_SIZE_MASK);
		goto l1;
	} else {
		bodySize = header & (SIZE_MASK);
		goto l1;
	}
l1:	/* end sizeBitsOf: */;
	if ((((usqInt) ((lastSeg + extraSize) + bodySize))) >= (((usqInt) stopAddr))) {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		return null;
	}
	/* begin transfer:from:to: */
	flag("Dan");
	in = (oop - extraSize) - (BYTES_PER_WORD);
	lastIn = in + (((extraSize + bodySize) / (BYTES_PER_WORD)) * (BYTES_PER_WORD));
	out = (lastSeg + (BYTES_PER_WORD)) - (BYTES_PER_WORD);
	while ((((usqInt) in)) < (((usqInt) lastIn))) {
		longAtput((out += BYTES_PER_WORD), longAt((in += BYTES_PER_WORD)));
	}
	hdrAddr = (lastSeg + (BYTES_PER_WORD)) + extraSize;
	longAtput(hdrAddr, (longAt(hdrAddr)) & ((ALL_BUT_ROOT_BIT) - (MARK_BIT)));
	/* begin forward:to:savingOopAt:andHeaderAt: */
	longAtput(oopPtr, oop);
	longAtput(hdrPtr, longAt(oop));
	longAtput(oop, (((lastSeg + (BYTES_PER_WORD)) + extraSize) - segmentWordArray) + HeaderTypeFree);
	return (lastSeg + extraSize) + bodySize;
}


/*	Bundle up the selector, arguments and lookupClass into a Message object. 
	In the process it pops the arguments off the stack, and pushes the message object. 
	This can then be presented as the argument of e.g. #doesNotUnderstand:. 
	ikp 11/20/1999 03:59 -- added hook for external runtime compilers. */
/*	remap lookupClass in case GC happens during allocation */

sqInt createActualMessageTo(sqInt aClass) {
    sqInt argumentArray;
    sqInt lookupClass;
    sqInt message;
    sqInt in;
    sqInt lastIn;
    sqInt out;
    sqInt sp;
    sqInt oop;
    sqInt oop1;

	/* begin pushRemappableOop: */
	remapBuffer[(remapBufferCount += 1)] = aClass;

	/* remap argumentArray in case GC happens during allocation */

	argumentArray = instantiateClassindexableSize(longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassArray << (SHIFT_FOR_WORD))), argumentCount);
	/* begin pushRemappableOop: */
	remapBuffer[(remapBufferCount += 1)] = argumentArray;
	message = instantiateClassindexableSize(longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassMessage << (SHIFT_FOR_WORD))), 0);
	/* begin popRemappableOop */
	oop = remapBuffer[remapBufferCount];
	remapBufferCount -= 1;
	argumentArray = oop;
	/* begin popRemappableOop */
	oop1 = remapBuffer[remapBufferCount];
	remapBufferCount -= 1;
	lookupClass = oop1;
	beRootIfOld(argumentArray);
	if (compilerInitialized) {
		compilerCreateActualMessagestoringArgs(message, argumentArray);
	} else {
		/* begin transfer:from:to: */
		flag("Dan");
		in = (stackPointer - ((argumentCount - 1) * (BYTES_PER_WORD))) - (BYTES_PER_WORD);
		lastIn = in + (argumentCount * (BYTES_PER_WORD));
		out = (argumentArray + (BASE_HEADER_SIZE)) - (BYTES_PER_WORD);
		while ((((usqInt) in)) < (((usqInt) lastIn))) {
			longAtput((out += BYTES_PER_WORD), longAt((in += BYTES_PER_WORD)));
		}
		/* begin pop:thenPush: */
		longAtput((sp = stackPointer - ((argumentCount - 1) * (BYTES_PER_WORD))), message);
		stackPointer = sp;
	}
	argumentCount = 1;
	/* begin storePointer:ofObject:withValue: */
	if ((((usqInt) message)) < (((usqInt) youngStart))) {
		possibleRootStoreIntovalue(message, messageSelector);
	}
	longAtput((message + (BASE_HEADER_SIZE)) + (MessageSelectorIndex << (SHIFT_FOR_WORD)), messageSelector);
	/* begin storePointer:ofObject:withValue: */
	if ((((usqInt) message)) < (((usqInt) youngStart))) {
		possibleRootStoreIntovalue(message, argumentArray);
	}
	longAtput((message + (BASE_HEADER_SIZE)) + (MessageArgumentsIndex << (SHIFT_FOR_WORD)), argumentArray);
	if ((lastPointerOf(message)) >= ((MessageLookupClassIndex * (BYTES_PER_WORD)) + (BASE_HEADER_SIZE))) {

		/* Only store lookupClass if message has 3 fields (old images don't) */

		/* begin storePointer:ofObject:withValue: */
		if ((((usqInt) message)) < (((usqInt) youngStart))) {
			possibleRootStoreIntovalue(message, lookupClass);
		}
		longAtput((message + (BASE_HEADER_SIZE)) + (MessageLookupClassIndex << (SHIFT_FOR_WORD)), lookupClass);
	}
	return null;
}

sqInt dispatchFunctionPointer(void (*aFunctionPointer)(void)) {
	(aFunctionPointer)();
	return null;
}


/*	Call the primitive at index primIdx in the primitiveTable. */

sqInt dispatchFunctionPointerOnin(sqInt primIdx, void (*primTable[])(void)) {
	return dispatchFunctionPointer(primTable[primIdx]);
}


/*	Repaint the portion of the Smalltalk screen bounded by the affected rectangle. Used to synchronize the screen after a Bitblt to the Smalltalk Display object. */

sqInt displayBitsOfLeftTopRightBottom(sqInt aForm, sqInt l, sqInt t, sqInt r, sqInt b) {
    sqInt bottom;
    sqInt d;
    sqInt dispBits;
    sqInt dispBitsIndex;
    sqInt displayObj;
    sqInt h;
    sqInt left;
    sqInt right;
    sqInt surfaceHandle;
    sqInt top;
    sqInt w;
    sqInt successBoolean;

	displayObj = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (TheDisplay << (SHIFT_FOR_WORD)));
	if (!(aForm == displayObj)) {
		return null;
	}
	/* begin success: */
	successBoolean = (((displayObj & 1) == 0) && (((((usqInt) (longAt(displayObj))) >> 8) & 15) <= 4)) && ((lengthOf(displayObj)) >= 4);
	if (!(successBoolean)) {
		if (!primFailCode) {
			primFailCode = 1;
		}
	}
	if (!primFailCode) {
		dispBits = longAt((displayObj + (BASE_HEADER_SIZE)) + (0 << (SHIFT_FOR_WORD)));
		w = fetchIntegerofObject(1, displayObj);
		h = fetchIntegerofObject(2, displayObj);
		d = fetchIntegerofObject(3, displayObj);
	}
	if (l < 0) {
		left = 0;
	} else {
		left = l;
	}
	if (r > w) {
		right = w;
	} else {
		right = r;
	}
	if (t < 0) {
		top = 0;
	} else {
		top = t;
	}
	if (b > h) {
		bottom = h;
	} else {
		bottom = b;
	}
	if (!((left <= right) && (top <= bottom))) {
		return null;
	}
	if (!primFailCode) {
		if ((dispBits & 1)) {
			surfaceHandle = (dispBits >> 1);
			if (showSurfaceFn == 0) {
				showSurfaceFn = ioLoadFunctionFrom("ioShowSurface", "SurfacePlugin");
				if (showSurfaceFn == 0) {
					/* begin success: */
					if (!(0)) {
						if (!primFailCode) {
							primFailCode = 1;
						}
					}
					return null;
				}
			}
			((sqInt (*)(sqInt, sqInt, sqInt, sqInt, sqInt))showSurfaceFn)(surfaceHandle, left, top, right-left, bottom-top);
		} else {

			/* index in memory byte array */

			dispBitsIndex = dispBits + (BASE_HEADER_SIZE);
			ioShowDisplay(dispBitsIndex, w, h, d, left, right, top, bottom);
		}
	}
	return null;
}

sqInt displayObject(void) {
	return longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (TheDisplay << (SHIFT_FOR_WORD)));
}


/*	Rounds negative results towards negative infinity, rather than zero. */

sqInt doPrimitiveDivby(sqInt rcvr, sqInt arg) {
    sqInt integerArg;
    sqInt integerRcvr;
    sqInt posArg;
    sqInt posRcvr;
    sqInt result;
    sqInt successBoolean;

	if (((rcvr & arg) & 1) != 0) {
		integerRcvr = (rcvr >> 1);
		integerArg = (arg >> 1);
		/* begin success: */
		if (!(integerArg != 0)) {
			if (!primFailCode) {
				primFailCode = 1;
			}
		}
	} else {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
	}
	if (!(!primFailCode)) {
		return 1;
	}
	if (integerRcvr > 0) {
		if (integerArg > 0) {
			result = integerRcvr / integerArg;
		} else {

			/* round negative result toward negative infinity */

			posArg = 0 - integerArg;
			result = 0 - ((integerRcvr + (posArg - 1)) / posArg);
		}
	} else {
		posRcvr = 0 - integerRcvr;
		if (integerArg > 0) {

			/* round negative result toward negative infinity */

			result = 0 - ((posRcvr + (integerArg - 1)) / integerArg);
		} else {
			posArg = 0 - integerArg;
			result = posRcvr / posArg;
		}
	}
	/* begin success: */
	successBoolean = 
# ifdef SQ_HOST32  // cast to int for 64 bit image on 32 bit host
		(((((int) result)) ^ ((((int) result)) << 1)) >= 0)
# else
		((result >= -1073741824) && (result <= 1073741823))
# endif  // SQ_HOST32
	;
	if (!(successBoolean)) {
		if (!primFailCode) {
			primFailCode = 1;
		}
	}
	return result;
}

sqInt doPrimitiveModby(sqInt rcvr, sqInt arg) {
    sqInt integerArg;
    sqInt integerRcvr;
    sqInt integerResult;
    sqInt successBoolean;

	if (((rcvr & arg) & 1) != 0) {
		integerRcvr = (rcvr >> 1);
		integerArg = (arg >> 1);
		/* begin success: */
		if (!(integerArg != 0)) {
			if (!primFailCode) {
				primFailCode = 1;
			}
		}
	} else {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
	}
	if (!(!primFailCode)) {
		return 1;
	}

	/* ensure that the result has the same sign as the integerArg */

	integerResult = integerRcvr % integerArg;
	if (integerArg < 0) {
		if (integerResult > 0) {
			integerResult += integerArg;
		}
	} else {
		if (integerResult < 0) {
			integerResult += integerArg;
		}
	}
	/* begin success: */
	successBoolean = 
# ifdef SQ_HOST32  // cast to int for 64 bit image on 32 bit host
		(((((int) integerResult)) ^ ((((int) integerResult)) << 1)) >= 0)
# else
		((integerResult >= -1073741824) && (integerResult <= 1073741823))
# endif  // SQ_HOST32
	;
	if (!(successBoolean)) {
		if (!primFailCode) {
			primFailCode = 1;
		}
	}
	return integerResult;
}

sqInt dummyReferToProxy(void) {
	interpreterProxy = interpreterProxy;
	return null;
}


/*	Dump the entire image out to the given file. Intended for debugging only. */

EXPORT(sqInt) dumpImage(char *fileName) {
    sqInt dataSize;
    sqImageFile f;
    sqInt result;

	f = sqImageFileOpen(fileName, "wb");
	if (f == null) {
		return -1;
	}
	dataSize = endOfMemory - memory;
	result = sqImageFileWrite(pointerForOop(memory), sizeof(unsigned char), dataSize, f);
	sqImageFileClose(f);
	return result;
}


/*	execute a method found in the mCache - which means that 
	primitiveIndex & primitiveFunctionPointer are already set. Any sender 
	needs to have previously sent findMethodInClass: or equivalent */

sqInt executeNewMethodFromCache(void) {
    sqInt delta;
    sqInt nArgs;

	if (primitiveIndex > 0) {
		if (DoBalanceChecks) {

			/* check stack balance */

			nArgs = argumentCount;
			delta = stackPointer - activeContext;
		}
		/* begin initPrimCall */
		primFailCode = 0;
		dispatchFunctionPointer(primitiveFunctionPointer);
		if (DoBalanceChecks) {
			if (!(balancedStackafterPrimitivewithArgs(delta, primitiveIndex, nArgs))) {
				printUnbalancedStack(primitiveIndex);
			}
		}
		if (!primFailCode) {
			return null;
		}
	}
	activateNewMethod();
	/* begin quickCheckForInterrupts */
	if (((interruptCheckCounter -= 1)) <= 0) {
		checkForInterrupts();
	}
	return null;
}


/*	Return the number of extra bytes used by the given object's header. */
/*	Warning: This method should not be used during marking, when the header type bits of an object may be incorrect. */
/*	JMM should be an array lookup! */

EXPORT(sqInt) extraHeaderBytes(sqInt oopOrChunk) {
	return headerTypeBytes[(longAt(oopOrChunk)) & TypeMask];
}


/*	In C, non-zero is true, so avoid computation by simply answering primFailCode in the C version. */

sqInt failed(void) {
	return primFailCode;
}

sqInt falseObject(void) {
	return falseObj;
}


/*	Fetch the instance variable at the given index of the given object. Return the address of first indexable field of resulting array object, or fail if the instance variable does not contain an indexable bytes or words object. */
/*	Note: May be called by translated primitive code. */

void * fetchArrayofObject(sqInt fieldIndex, sqInt objectPointer) {
    sqInt arrayOop;

	arrayOop = longAt((objectPointer + (BASE_HEADER_SIZE)) + (fieldIndex << (SHIFT_FOR_WORD)));
	/* begin arrayValueOf: */
	if ((!((arrayOop & 1))) && (((arrayOop & 1) == 0) && (isWordsOrBytesNonInt(arrayOop)))) {
		return pointerForOop(arrayOop + (BASE_HEADER_SIZE));
	}
	/* begin primitiveFail */
	if (primFailCode == 0) {
		primFailCode = 1;
	}
	return null;
}

sqInt fetchClassOf(sqInt oop) {
    sqInt ccIndex;
    sqInt oop1;

	if ((oop & 1)) {
		return longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassInteger << (SHIFT_FOR_WORD)));
	}
	ccIndex = (((usqInt) (longAt(oop))) >> 12) & 31;
	if (ccIndex == 0) {
		return (longAt(oop - (BASE_HEADER_SIZE))) & (ALL_BUT_TYPE_MASK);
	} else {

		/* look up compact class */

		/* begin fetchPointer:ofObject: */
		oop1 = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (CompactClasses << (SHIFT_FOR_WORD)));
		return longAt((oop1 + (BASE_HEADER_SIZE)) + ((ccIndex - 1) << (SHIFT_FOR_WORD)));
	}
	return null;
}

sqInt fetchClassOfNonInt(sqInt oop) {
    sqInt ccIndex;
    sqInt oop1;

	ccIndex = (((usqInt) (longAt(oop))) >> 12) & 31;
	if (ccIndex == 0) {
		return (longAt(oop - (BASE_HEADER_SIZE))) & (ALL_BUT_TYPE_MASK);
	} else {

		/* look up compact class */

		/* begin fetchPointer:ofObject: */
		oop1 = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (CompactClasses << (SHIFT_FOR_WORD)));
		return longAt((oop1 + (BASE_HEADER_SIZE)) + ((ccIndex - 1) << (SHIFT_FOR_WORD)));
	}
	return null;
}


/*	Fetch the instance variable at the given index of the given object. Return the C double precision floating point value of that instance variable, or fail if it is not a Float. */
/*	Note: May be called by translated primitive code. */

double fetchFloatofObject(sqInt fieldIndex, sqInt objectPointer) {
    sqInt floatOop;

	floatOop = longAt((objectPointer + (BASE_HEADER_SIZE)) + (fieldIndex << (SHIFT_FOR_WORD)));
	return floatValueOf(floatOop);
}


/*	Note: May be called by translated primitive code. */

sqInt fetchIntegerofObject(sqInt fieldIndex, sqInt objectPointer) {
    sqInt intOop;

	intOop = longAt((objectPointer + (BASE_HEADER_SIZE)) + (fieldIndex << (SHIFT_FOR_WORD)));
	/* begin checkedIntegerValueOf: */
	if ((intOop & 1)) {
		return (intOop >> 1);
	} else {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		return 0;
	}
	return null;
}


/*	 index by 32-bit units, and return a 32-bit value. Intended to replace fetchWord:ofObject: */

sqInt fetchLong32ofObject(sqInt fieldIndex, sqInt oop) {
	return long32At((oop + (BASE_HEADER_SIZE)) + (fieldIndex << 2));
}


/*	index by word size, and return a pointer as long as the word size */

sqInt fetchPointerofObject(sqInt fieldIndex, sqInt oop) {
	return longAt((oop + (BASE_HEADER_SIZE)) + (fieldIndex << (SHIFT_FOR_WORD)));
}


/*	Return the stackPointer of a Context or BlockContext. */

sqInt fetchStackPointerOf(sqInt aContext) {
    sqInt sp;

	sp = longAt((aContext + (BASE_HEADER_SIZE)) + (StackPointerIndex << (SHIFT_FOR_WORD)));
	if (!((sp & 1))) {
		return 0;
	}
	return (sp >> 1);
}


/*	NOTE: this gives size appropriate for fetchPointer: n, but not in general for, eg, fetchLong32, etc. */

sqInt fetchWordLengthOf(sqInt objectPointer) {
    sqInt sz;
    sqInt header;

	/* begin sizeBitsOf: */
	header = longAt(objectPointer);
	if ((header & TypeMask) == HeaderTypeSizeAndClass) {
		sz = (longAt(objectPointer - ((BYTES_PER_WORD) * 2))) & (LONG_SIZE_MASK);
		goto l1;
	} else {
		sz = header & (SIZE_MASK);
		goto l1;
	}
l1:	/* end sizeBitsOf: */;
	return ((usqInt) (sz - (BASE_HEADER_SIZE))) >> (SHIFT_FOR_WORD);
}


/*	During sweep phase we have encountered a weak reference. 
	Check if  its object has gone away (or is about to) and if so, signal a 
	semaphore.  */
/*	Do *not* inline this in sweepPhase - it is quite an unlikely 
	case to run into a weak reference */

sqInt finalizeReference(usqInt oop) {
    sqInt chunk;
    sqInt firstField;
    sqInt i;
    sqInt lastField;
    sqInt nonWeakCnt;
    sqInt oopGone;
    usqInt weakOop;
    sqInt listItemOop;
    sqInt listOop;
    sqInt contextSize;
    sqInt fmt;
    sqInt header;
    sqInt methodHeader;
    sqInt sz;
    sqInt sp;
    sqInt header1;
    sqInt type;

	nonWeakCnt = nonWeakFieldsOf(oop);
	firstField = (BASE_HEADER_SIZE) + (nonWeakCnt << (SHIFT_FOR_WORD));
	/* begin lastPointerOf: */
	header = longAt(oop);
	fmt = (((usqInt) header) >> 8) & 15;
	if (fmt <= 4) {
		if ((fmt == 3) && ((((((usqInt) header) >> 12) & 31) == 13) || ((((((usqInt) header) >> 12) & 31) == 14) || (((((usqInt) header) >> 12) & 31) == 4)))) {
			/* begin fetchStackPointerOf: */
			sp = longAt((oop + (BASE_HEADER_SIZE)) + (StackPointerIndex << (SHIFT_FOR_WORD)));
			if (!((sp & 1))) {
				contextSize = 0;
				goto l1;
			}
			contextSize = (sp >> 1);
		l1:	/* end fetchStackPointerOf: */;
			lastField = (CtxtTempFrameStart + contextSize) * (BYTES_PER_WORD);
			goto l2;
		}
		/* begin sizeBitsOfSafe: */
		header1 = longAt(oop);
		/* begin rightType: */
		if ((header1 & (SIZE_MASK)) == 0) {
			type = HeaderTypeSizeAndClass;
			goto l3;
		} else {
			if ((header1 & CompactClassMask) == 0) {
				type = HeaderTypeClass;
				goto l3;
			} else {
				type = HeaderTypeShort;
				goto l3;
			}
		}
	l3:	/* end rightType: */;
		if (type == HeaderTypeSizeAndClass) {
			sz = (longAt(oop - ((BYTES_PER_WORD) * 2))) & (ALL_BUT_TYPE_MASK);
			goto l4;
		} else {
			sz = header1 & (SIZE_MASK);
			goto l4;
		}
	l4:	/* end sizeBitsOfSafe: */;
		lastField = sz - (BASE_HEADER_SIZE);
		goto l2;
	}
	if (fmt < 12) {
		lastField = 0;
		goto l2;
	}
	methodHeader = longAt(oop + (BASE_HEADER_SIZE));
	lastField = (((((usqInt) methodHeader) >> 10) & 255) * (BYTES_PER_WORD)) + (BASE_HEADER_SIZE);
l2:	/* end lastPointerOf: */;
	for (i = firstField; i <= lastField; i += (BYTES_PER_WORD)) {

		/* ar 1/18/2005: Added oop < youngStart test to make sure we're not testing
			objects in non-GCable region. This could lead to a forward reference in
			old space with the oop pointed to not being marked and thus treated as free. */

		weakOop = longAt(oop + i);
		if (!((weakOop == nilObj) || (((weakOop & 1)) || (weakOop < youngStart)))) {

			/* Check if the object is being collected. 
					If the weak reference points  
					* backward: check if the weakOops chunk is free
					* forward: check if the weakOoop has been marked by GC */

			if (weakOop < oop) {
				chunk = weakOop - (headerTypeBytes[(longAt(weakOop)) & TypeMask]);
				oopGone = ((longAt(chunk)) & TypeMask) == HeaderTypeFree;
			} else {
				oopGone = ((longAt(weakOop)) & (MARK_BIT)) == 0;
			}
			if (oopGone) {

				/* Store nil in the pointer and signal the  interpreter  */

				longAtput(oop + i, nilObj);
				if (nonWeakCnt >= 2) {
					/* begin weakFinalizerCheck: */
					listOop = longAt((oop + (BASE_HEADER_SIZE)) + (0 << (SHIFT_FOR_WORD)));
					if ((fetchClassOf(listOop)) == (longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassWeakFinalizer << (SHIFT_FOR_WORD))))) {
						listItemOop = longAt((listOop + (BASE_HEADER_SIZE)) + (0 << (SHIFT_FOR_WORD)));
						/* begin storePointer:ofObject:withValue: */
						if ((((usqInt) oop)) < (((usqInt) youngStart))) {
							possibleRootStoreIntovalue(oop, listItemOop);
						}
						longAtput((oop + (BASE_HEADER_SIZE)) + (1 << (SHIFT_FOR_WORD)), listItemOop);
						/* begin storePointer:ofObject:withValue: */
						if ((((usqInt) listOop)) < (((usqInt) youngStart))) {
							possibleRootStoreIntovalue(listOop, oop);
						}
						longAtput((listOop + (BASE_HEADER_SIZE)) + (0 << (SHIFT_FOR_WORD)), oop);
					}
				}
				/* begin signalFinalization: */
				/* begin forceInterruptCheck */
				interruptCheckCounter = -1000;
				nextPollTick = 0;
				pendingFinalizationSignals += 1;
			}
		}
	}
	return null;
}

sqInt findClassOfMethodforReceiver(sqInt meth, sqInt rcvr) {
    sqInt classDict;
    sqInt classDictSize;
    sqInt currClass;
    sqInt done;
    sqInt i;
    sqInt methodArray;
    sqInt sz;
    sqInt header;
    sqInt ccIndex;
    sqInt oop1;
    sqInt ccIndex1;
    sqInt oop11;

	/* begin fetchClassOf: */
	if ((rcvr & 1)) {
		currClass = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassInteger << (SHIFT_FOR_WORD)));
		goto l2;
	}
	ccIndex = (((usqInt) (longAt(rcvr))) >> 12) & 31;
	if (ccIndex == 0) {
		currClass = (longAt(rcvr - (BASE_HEADER_SIZE))) & (ALL_BUT_TYPE_MASK);
		goto l2;
	} else {
		/* begin fetchPointer:ofObject: */
		oop1 = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (CompactClasses << (SHIFT_FOR_WORD)));
		currClass = longAt((oop1 + (BASE_HEADER_SIZE)) + ((ccIndex - 1) << (SHIFT_FOR_WORD)));
		goto l2;
	}
l2:	/* end fetchClassOf: */;
	done = 0;
	while (!(done)) {
		classDict = longAt((currClass + (BASE_HEADER_SIZE)) + (MessageDictionaryIndex << (SHIFT_FOR_WORD)));
		/* begin fetchWordLengthOf: */
		/* begin sizeBitsOf: */
		header = longAt(classDict);
		if ((header & TypeMask) == HeaderTypeSizeAndClass) {
			sz = (longAt(classDict - ((BYTES_PER_WORD) * 2))) & (LONG_SIZE_MASK);
			goto l1;
		} else {
			sz = header & (SIZE_MASK);
			goto l1;
		}
	l1:	/* end sizeBitsOf: */;
		classDictSize = ((usqInt) (sz - (BASE_HEADER_SIZE))) >> (SHIFT_FOR_WORD);
		methodArray = longAt((classDict + (BASE_HEADER_SIZE)) + (MethodArrayIndex << (SHIFT_FOR_WORD)));
		i = 0;
		while (i < (classDictSize - SelectorStart)) {
			if (meth == (longAt((methodArray + (BASE_HEADER_SIZE)) + (i << (SHIFT_FOR_WORD))))) {
				return currClass;
			}
			i += 1;
		}
		currClass = longAt((currClass + (BASE_HEADER_SIZE)) + (SuperclassIndex << (SHIFT_FOR_WORD)));
		done = currClass == nilObj;
	}
	/* begin fetchClassOf: */
	if ((rcvr & 1)) {
		return longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassInteger << (SHIFT_FOR_WORD)));
	}
	ccIndex1 = (((usqInt) (longAt(rcvr))) >> 12) & 31;
	if (ccIndex1 == 0) {
		return (longAt(rcvr - (BASE_HEADER_SIZE))) & (ALL_BUT_TYPE_MASK);
	} else {
		/* begin fetchPointer:ofObject: */
		oop11 = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (CompactClasses << (SHIFT_FOR_WORD)));
		return longAt((oop11 + (BASE_HEADER_SIZE)) + ((ccIndex1 - 1) << (SHIFT_FOR_WORD)));
	}
	return null;
}


/*	Find the compiled method to be run when the current 
	messageSelector is sent to the given class, setting the values 
	of 'newMethod' and 'primitiveIndex'. */

sqInt findNewMethodInClass(sqInt class) {
    sqInt ok;
    sqInt hash;
    sqInt probe;

	/* begin lookupInMethodCacheSel:class: */
	hash = messageSelector ^ class;
	probe = hash & MethodCacheMask;
	if (((methodCache[probe + MethodCacheSelector]) == messageSelector) && ((methodCache[probe + MethodCacheClass]) == class)) {
		newMethod = (usqInt)methodCache[probe + MethodCacheMethod];
		primitiveIndex = methodCache[probe + MethodCachePrim];
		newNativeMethod = methodCache[probe + MethodCacheNative];
		primitiveFunctionPointer = ((void (*)(void)) (methodCache[probe + MethodCachePrimFunction]));
		ok = 1;
		goto l1;
	}
	probe = (((usqInt) hash) >> 1) & MethodCacheMask;
	if (((methodCache[probe + MethodCacheSelector]) == messageSelector) && ((methodCache[probe + MethodCacheClass]) == class)) {
		newMethod = (usqInt)methodCache[probe + MethodCacheMethod];
		primitiveIndex = methodCache[probe + MethodCachePrim];
		newNativeMethod = methodCache[probe + MethodCacheNative];
		primitiveFunctionPointer = ((void (*)(void)) (methodCache[probe + MethodCachePrimFunction]));
		ok = 1;
		goto l1;
	}
	probe = (((usqInt) hash) >> 2) & MethodCacheMask;
	if (((methodCache[probe + MethodCacheSelector]) == messageSelector) && ((methodCache[probe + MethodCacheClass]) == class)) {
		newMethod = (usqInt)methodCache[probe + MethodCacheMethod];
		primitiveIndex = methodCache[probe + MethodCachePrim];
		newNativeMethod = methodCache[probe + MethodCacheNative];
		primitiveFunctionPointer = ((void (*)(void)) (methodCache[probe + MethodCachePrimFunction]));
		ok = 1;
		goto l1;
	}
	ok = 0;
l1:	/* end lookupInMethodCacheSel:class: */;
	if (!(ok)) {

		/* entry was not found in the cache; look it up the hard way  */

		lookupMethodInClass(class);
		lkupClass = class;
		addNewMethodToCache();
	}
	return null;
}

sqInt findSelectorOfMethodforReceiver(sqInt meth, sqInt rcvr) {
    sqInt classDict;
    sqInt classDictSize;
    sqInt currClass;
    sqInt done;
    sqInt i;
    sqInt methodArray;
    sqInt sz;
    sqInt header;
    sqInt ccIndex;
    sqInt oop1;

	/* begin fetchClassOf: */
	if ((rcvr & 1)) {
		currClass = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassInteger << (SHIFT_FOR_WORD)));
		goto l2;
	}
	ccIndex = (((usqInt) (longAt(rcvr))) >> 12) & 31;
	if (ccIndex == 0) {
		currClass = (longAt(rcvr - (BASE_HEADER_SIZE))) & (ALL_BUT_TYPE_MASK);
		goto l2;
	} else {
		/* begin fetchPointer:ofObject: */
		oop1 = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (CompactClasses << (SHIFT_FOR_WORD)));
		currClass = longAt((oop1 + (BASE_HEADER_SIZE)) + ((ccIndex - 1) << (SHIFT_FOR_WORD)));
		goto l2;
	}
l2:	/* end fetchClassOf: */;
	done = 0;
	while (!(done)) {
		classDict = longAt((currClass + (BASE_HEADER_SIZE)) + (MessageDictionaryIndex << (SHIFT_FOR_WORD)));
		/* begin fetchWordLengthOf: */
		/* begin sizeBitsOf: */
		header = longAt(classDict);
		if ((header & TypeMask) == HeaderTypeSizeAndClass) {
			sz = (longAt(classDict - ((BYTES_PER_WORD) * 2))) & (LONG_SIZE_MASK);
			goto l1;
		} else {
			sz = header & (SIZE_MASK);
			goto l1;
		}
	l1:	/* end sizeBitsOf: */;
		classDictSize = ((usqInt) (sz - (BASE_HEADER_SIZE))) >> (SHIFT_FOR_WORD);
		methodArray = longAt((classDict + (BASE_HEADER_SIZE)) + (MethodArrayIndex << (SHIFT_FOR_WORD)));
		i = 0;
		while (i <= (classDictSize - SelectorStart)) {
			if (meth == (longAt((methodArray + (BASE_HEADER_SIZE)) + (i << (SHIFT_FOR_WORD))))) {
				return longAt((classDict + (BASE_HEADER_SIZE)) + ((i + SelectorStart) << (SHIFT_FOR_WORD)));
			}
			i += 1;
		}
		currClass = longAt((currClass + (BASE_HEADER_SIZE)) + (SuperclassIndex << (SHIFT_FOR_WORD)));
		done = currClass == nilObj;
	}
	return nilObj;
}


/*	Return the first accessible object in the heap. */

sqInt firstAccessibleObject(void) {
    sqInt obj;
    sqInt sz;
    sqInt header;

	obj = memory + (headerTypeBytes[(longAt(memory)) & TypeMask]);
	while ((((usqInt) obj)) < (((usqInt) endOfMemory))) {
		if (!(((longAt(obj)) & TypeMask) == HeaderTypeFree)) {
			return obj;
		}
		/* begin objectAfter: */
		if (DoAssertionChecks) {
			if ((((usqInt) obj)) >= (((usqInt) endOfMemory))) {
				error("no objects after the end of memory");
			}
		}
		if (((longAt(obj)) & TypeMask) == HeaderTypeFree) {
			sz = (longAt(obj)) & (ALL_BUT_TYPE_MASK);
		} else {
			/* begin sizeBitsOf: */
			header = longAt(obj);
			if ((header & TypeMask) == HeaderTypeSizeAndClass) {
				sz = (longAt(obj - ((BYTES_PER_WORD) * 2))) & (LONG_SIZE_MASK);
				goto l1;
			} else {
				sz = header & (SIZE_MASK);
				goto l1;
			}
		l1:	/* end sizeBitsOf: */;
		}
		obj = (obj + sz) + (headerTypeBytes[(longAt(obj + sz)) & TypeMask]);
	}
	error("heap is empty");
	return null;
}

char * firstFixedField(sqInt oop) {
	return pointerForOop(oop + (BASE_HEADER_SIZE));
}


/*	NOTE: copied in InterpreterSimulator, so please duplicate any changes */

char * firstIndexableField(sqInt oop) {
    sqInt fixedFields;
    sqInt fmt;
    sqInt hdr;
    sqInt totalLength;
    sqInt sz;
    sqInt class;
    sqInt classFormat;
    sqInt ccIndex;
    sqInt oop1;

	hdr = longAt(oop);
	fmt = (((usqInt) hdr) >> 8) & 15;
	/* begin lengthOf:baseHeader:format: */
	if ((hdr & TypeMask) == HeaderTypeSizeAndClass) {
		sz = (longAt(oop - ((BYTES_PER_WORD) * 2))) & (LONG_SIZE_MASK);
	} else {
		sz = hdr & (SIZE_MASK);
	}
	sz -= hdr & (SIZE_4_BIT);
	if (fmt <= 4) {
		totalLength = ((usqInt) (sz - (BASE_HEADER_SIZE))) >> (SHIFT_FOR_WORD);
		goto l1;
	}
	if (fmt < 8) {
		totalLength = ((usqInt) (sz - (BASE_HEADER_SIZE))) >> 2;
		goto l1;
	} else {
		totalLength = (sz - (BASE_HEADER_SIZE)) - (fmt & 3);
		goto l1;
	}
l1:	/* end lengthOf:baseHeader:format: */;
	/* begin fixedFieldsOf:format:length: */
	if ((fmt > 4) || (fmt == 2)) {
		fixedFields = 0;
		goto l2;
	}
	if (fmt < 2) {
		fixedFields = totalLength;
		goto l2;
	}
	/* begin fetchClassOf: */
	if ((oop & 1)) {
		class = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassInteger << (SHIFT_FOR_WORD)));
		goto l3;
	}
	ccIndex = (((usqInt) (longAt(oop))) >> 12) & 31;
	if (ccIndex == 0) {
		class = (longAt(oop - (BASE_HEADER_SIZE))) & (ALL_BUT_TYPE_MASK);
		goto l3;
	} else {
		/* begin fetchPointer:ofObject: */
		oop1 = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (CompactClasses << (SHIFT_FOR_WORD)));
		class = longAt((oop1 + (BASE_HEADER_SIZE)) + ((ccIndex - 1) << (SHIFT_FOR_WORD)));
		goto l3;
	}
l3:	/* end fetchClassOf: */;
	classFormat = (longAt((class + (BASE_HEADER_SIZE)) + (InstanceSpecificationIndex << (SHIFT_FOR_WORD)))) - 1;
	fixedFields = (((((usqInt) classFormat) >> 11) & 192) + ((((usqInt) classFormat) >> 2) & 63)) - 1;
l2:	/* end fixedFieldsOf:format:length: */;
	if (fmt < 8) {
		if (fmt == 6) {

			/* 32 bit field objects */

			return pointerForOop((oop + (BASE_HEADER_SIZE)) + (fixedFields << 2));
		}
		return pointerForOop((oop + (BASE_HEADER_SIZE)) + (fixedFields << (SHIFT_FOR_WORD)));
	} else {

		/* Byte objects */

		return pointerForOop((oop + (BASE_HEADER_SIZE)) + fixedFields);
	}
	return null;
}


/*	Like #stackFloatValue: but access method arguments left-to-right */

double floatArg(sqInt index) {
    sqInt oop;

	oop = methodArg(index);
	if (oop == 0) {
		return 0.0;
	}
	return floatValueOf(oop);
}

sqInt floatObjectOf(double  aFloat) {
    sqInt newFloatObj;

	flag("Dan");
	newFloatObj = instantiateSmallClasssizeInBytes(longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassFloat << (SHIFT_FOR_WORD))), 8 + (BASE_HEADER_SIZE));
	storeFloatAtfrom(newFloatObj + (BASE_HEADER_SIZE), aFloat);
	return newFloatObj;
}


/*	Fetch the instance variable at the given index of the given object. Return the C double precision floating point value of that instance variable, or fail if it is not a Float. */
/*	Note: May be called by translated primitive code. */

double floatValueOf(sqInt oop) {
    double  result;
    sqInt classOop;
    sqInt ccIndex;
    sqInt cl;
    sqInt oop1;

	flag("Dan");
	/* begin assertClassOf:is: */
	classOop = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassFloat << (SHIFT_FOR_WORD)));
	if ((oop & 1)) {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		goto l1;
	}
	ccIndex = (((usqInt) (longAt(oop))) >> 12) & 31;
	if (ccIndex == 0) {
		cl = (longAt(oop - (BASE_HEADER_SIZE))) & (ALL_BUT_TYPE_MASK);
	} else {
		/* begin fetchPointer:ofObject: */
		oop1 = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (CompactClasses << (SHIFT_FOR_WORD)));
		cl = longAt((oop1 + (BASE_HEADER_SIZE)) + ((ccIndex - 1) << (SHIFT_FOR_WORD)));
	}
	/* begin success: */
	if (!(cl == classOop)) {
		if (!primFailCode) {
			primFailCode = 1;
		}
	}
l1:	/* end assertClassOf:is: */;
	if (!primFailCode) {
		;
		fetchFloatAtinto(oop + (BASE_HEADER_SIZE), result);
	} else {
		result = 0.0;
	}
	return result;
}


/*	methodPtr is a CompiledMethod containing an external primitive. Flush the function address and session ID of the CM */

sqInt flushExternalPrimitiveOf(sqInt methodPtr) {
    sqInt lit;

	if (!((literalCountOfHeader(longAt((methodPtr + (BASE_HEADER_SIZE)) + (HeaderIndex << (SHIFT_FOR_WORD))))) > 0)) {
		return null;
	}
	lit = longAt((methodPtr + (BASE_HEADER_SIZE)) + ((0 + LiteralStart) << (SHIFT_FOR_WORD)));
	if (!((((lit & 1) == 0) && (((((usqInt) (longAt(lit))) >> 8) & 15) == 2)) && ((lengthOf(lit)) == 4))) {
		return null;
	}
	longAtput((lit + (BASE_HEADER_SIZE)) + (2 << (SHIFT_FOR_WORD)), ConstZero);
	longAtput((lit + (BASE_HEADER_SIZE)) + (3 << (SHIFT_FOR_WORD)), ConstZero);
	return null;
}


/*	Flush the references to external functions from plugin 
	primitives. This will force a reload of those primitives when 
	accessed next. 
	Note: We must flush the method cache here so that any 
	failed primitives are looked up again. */

sqInt flushExternalPrimitives(void) {
    sqInt oop;
    sqInt primIdx;
    sqInt primBits;
    sqInt i;
    sqInt i1;
    sqInt i2;
    sqInt sz;
    sqInt header;

	oop = memory + (headerTypeBytes[(longAt(memory)) & TypeMask]);
	while ((((usqInt) oop)) < (((usqInt) endOfMemory))) {
		if (!(((longAt(oop)) & TypeMask) == HeaderTypeFree)) {
			if (((((usqInt) (longAt(oop))) >> 8) & 15) >= 12) {

				/* This is a compiled method */

				/* begin primitiveIndexOf: */
				primBits = (((usqInt) (longAt((oop + (BASE_HEADER_SIZE)) + (HeaderIndex << (SHIFT_FOR_WORD))))) >> 1) & 268435967;
				primIdx = (primBits & 511) + (((usqInt) primBits) >> 19);
				if (primIdx == PrimitiveExternalCallIndex) {

					/* It's primitiveExternalCall */

					flushExternalPrimitiveOf(oop);
				}
			}
		}
		/* begin objectAfter: */
		if (DoAssertionChecks) {
			if ((((usqInt) oop)) >= (((usqInt) endOfMemory))) {
				error("no objects after the end of memory");
			}
		}
		if (((longAt(oop)) & TypeMask) == HeaderTypeFree) {
			sz = (longAt(oop)) & (ALL_BUT_TYPE_MASK);
		} else {
			/* begin sizeBitsOf: */
			header = longAt(oop);
			if ((header & TypeMask) == HeaderTypeSizeAndClass) {
				sz = (longAt(oop - ((BYTES_PER_WORD) * 2))) & (LONG_SIZE_MASK);
				goto l1;
			} else {
				sz = header & (SIZE_MASK);
				goto l1;
			}
		l1:	/* end sizeBitsOf: */;
		}
		oop = (oop + sz) + (headerTypeBytes[(longAt(oop + sz)) & TypeMask]);
	}
	/* begin flushMethodCache */
	for (i = 1; i <= MethodCacheSize; i += 1) {
		methodCache[i] = 0;
	}
	/* begin flushAtCache */
	for (i1 = 1; i1 <= AtCacheTotalSize; i1 += 1) {
		atCache[i1] = 0;
	}
	/* begin flushExternalPrimitiveTable */
	for (i2 = 0; i2 <= (MaxExternalPrimitiveTableSize - 1); i2 += 1) {
		externalPrimitiveTable[i2] = 0;
	}
	return null;
}


/*	force an interrupt check ASAP - setting interruptCheckCounter to a large -ve number is used as a flag to skip messing with the feedback mechanism and nextPollTick resetting makes sure that ioProcess gets called as near immediately as we can manage */

sqInt forceInterruptCheck(void) {
	interruptCheckCounter = -1000;
	nextPollTick = 0;
	return null;
}


/*	Repaint the entire smalltalk screen, ignoring the affected rectangle. Used in some platform's code when the Smalltalk window is brought to the front or uncovered. */

sqInt fullDisplayUpdate(void) {
    sqInt displayObj;
    sqInt h;
    sqInt w;

	displayObj = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (TheDisplay << (SHIFT_FOR_WORD)));
	if ((((displayObj & 1) == 0) && (((((usqInt) (longAt(displayObj))) >> 8) & 15) <= 4)) && ((lengthOf(displayObj)) >= 4)) {
		w = fetchIntegerofObject(1, displayObj);
		h = fetchIntegerofObject(2, displayObj);
		displayBitsOfLeftTopRightBottom(displayObj, 0, 0, w, h);
		ioForceDisplayUpdate();
	}
	return null;
}


/*	Do a mark/sweep garbage collection of the entire object memory. Free inaccessible objects but do not move them. */

sqInt fullGC(void) {
    sqLong startTime;
    sqInt i;
    sqInt oop;
    sqInt sz;
    sqInt valuePointer;

	if (DoAssertionChecks) {
		reverseDisplayFromto(0, 7);
	}
	/* begin preGCAction: */
	if (compilerInitialized) {
		compilerPreGC(1);
	} else {
		/* begin storeContextRegisters: */
		longAtput((activeContext + (BASE_HEADER_SIZE)) + (InstructionPointerIndex << (SHIFT_FOR_WORD)), ((((instructionPointer - method) - ((BASE_HEADER_SIZE) - 2)) << 1) | 1));
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer = (((((((usqInt) ((stackPointer - activeContext) - (BASE_HEADER_SIZE))) >> (SHIFT_FOR_WORD)) - TempFrameStart) + 1) << 1) | 1);
		longAtput((activeContext + (BASE_HEADER_SIZE)) + (StackPointerIndex << (SHIFT_FOR_WORD)), valuePointer);
	}
	startTime = ioMicroSecondClock();
	statSweepCount = (statMarkCount = (statMkFwdCount = (statCompMoveCount = 0)));
	/* begin clearRootsTable */
	for (i = 1; i <= rootTableCount; i += 1) {
		oop = rootTable[i];
		longAtput(oop, (longAt(oop)) & (ALL_BUT_ROOT_BIT));
		rootTable[i] = 0;
	}
	rootTableCount = 0;

	/* process all of memory */

	youngStart = memory;
	markPhase();
	totalObjectCount = sweepPhase();
	/* begin fullCompaction */
	compStart = (usqInt)lowestFreeAfter((sqInt)memory);
	if (compStart == freeBlock) {
		initializeMemoryFirstFree(freeBlock);
		goto l1;
	}
	if (((sz = fwdTableSize(8))) < totalObjectCount) {
		growObjectMemory(((totalObjectCount - sz) + 10000) * 8);
	}
	while (compStart < freeBlock) {
		compStart = (usqInt)incCompBody();
	}
l1:	/* end fullCompaction */;
	allocationCount = 0;
	statFullGCs += 1;
	statGCTime = ioMicroSecondClock();
	statFullGCMSecs += statGCTime - startTime;
	/* begin capturePendingFinalizationSignals */
	/* begin setStatpendingFinalizationSignals: */
	statpendingFinalizationSignals = pendingFinalizationSignals;

	/* reset the young object boundary */

	youngStart = freeBlock;
	postGCAction();
	if (DoAssertionChecks) {
		reverseDisplayFromto(0, 7);
	}
	return null;
}


/*	Answer if the given address is a valid forward table entry. */

sqInt fwdBlockValid(sqInt addr) {
	return ((((usqInt) addr)) > (((usqInt) endOfMemory))) && (((((usqInt) addr)) <= (((usqInt) fwdTableNext))) && ((addr & 3) == 0));
}


/*	Set the limits for a table of two- or three-word forwarding blocks above the last used oop. The pointer fwdTableNext moves up to fwdTableLast. Used for compaction of memory and become-ing objects. Returns the number of forwarding blocks available. */

sqInt fwdTableInit(sqInt blkSize) {

	/* set endOfMemory to just after a minimum-sized free block */

	/* begin setSizeOfFree:to: */
	longAtput(freeBlock, ((BASE_HEADER_SIZE) & (ALL_BUT_TYPE_MASK)) | HeaderTypeFree);

	/* make a fake free chunk at endOfMemory for use as a sentinal in memory scans */

	endOfMemory = (usqInt)freeBlock + (BASE_HEADER_SIZE);
	/* begin setSizeOfFree:to: */
	longAtput(endOfMemory, ((BASE_HEADER_SIZE) & (ALL_BUT_TYPE_MASK)) | HeaderTypeFree);
	fwdTableNext = (usqInt)((endOfMemory + (BASE_HEADER_SIZE)) + 7) & ((WORD_MASK) - 7);
	flag("Dan");

	/* last forwarding table entry */
	/* return the number of forwarding blocks available */

	fwdTableLast = (usqInt)memoryLimit - blkSize;
	return (fwdTableLast - fwdTableNext) / blkSize;
}


/*	Estimate the number of forwarding blocks available for compaction */

sqInt fwdTableSize(sqInt blkSize) {
    sqInt eom;
    sqInt fwdFirst;
    sqInt fwdLast;


	/* use all memory free between freeBlock and memoryLimit for forwarding table */
	/* Note: Forward blocks must be quadword aligned. */

	eom = freeBlock + (BASE_HEADER_SIZE);
	fwdFirst = ((eom + (BASE_HEADER_SIZE)) + 7) & ((WORD_MASK) - 7);
	flag("Dan");

	/* last forwarding table entry */
	/* return the number of forwarding blocks available */

	fwdLast = memoryLimit - blkSize;
	return (fwdLast - fwdFirst) / blkSize;
}


/*	currentBytecode will be private to the main dispatch loop in the generated code. This method allows the currentBytecode to be retrieved from global variables. */

sqInt getCurrentBytecode(void) {
	return byteAt(instructionPointer);
}

sqInt getFullScreenFlag(void) {
	return fullScreenFlag;
}

sqInt getInterruptCheckCounter(void) {
	return interruptCheckCounter;
}

sqInt getInterruptKeycode(void) {
	return interruptKeycode;
}

sqInt getInterruptPending(void) {
	return interruptPending;
}


/*	Answer the next word read from aFile, byte-swapped according to the swapFlag. */

sqInt getLongFromFileswap(sqImageFile  aFile, sqInt swapFlag) {
    sqInt w;

	w = 0;
	sqImageFileRead(&w, sizeof(w), 1, aFile);
	if (swapFlag) {
		/* begin byteSwapped: */
		
# if (BYTES_PER_WORD == 4)  // swap bytes in an object word
		return ((((((usqInt) w >> 24)) & Byte0Mask) + ((((usqInt) w >> 8)) & Byte1Mask)) + ((((usqInt) w << 8)) & Byte2Mask)) + ((((usqInt) w << 24)) & Byte3Mask);
# else
		return ((((((((((usqInt) w >> 56)) & Byte0Mask) + ((((usqInt) w >> 40)) & Byte1Mask)) + ((((usqInt) w >> 24)) & Byte2Mask)) + ((((usqInt) w >> 8)) & Byte3Mask)) + ((((usqInt) w << 8)) & Byte4Mask)) + ((((usqInt) w << 24)) & Byte5Mask)) + ((((usqInt) w << 40)) & Byte6Mask)) + ((((usqInt) w << 56)) & Byte7Mask);
# endif  // BYTES_PER_WORD == 4
		
		return null;
	} else {
		return w;
	}
	return null;
}

sqInt getNextWakeupTick(void) {
	return nextWakeupTick;
}

sqInt getSavedWindowSize(void) {
	return savedWindowSize;
}


/*	For Newsqueak FFI */

EXPORT(sqInt) getStackPointer(void) {
	return stackPointer;
}


/*	return the global session ID value */

sqInt getThisSessionID(void) {
	return globalSessionID;
}


/*	Attempt to grow the object memory by the given delta 
	amount  */

sqInt growObjectMemory(usqInt delta) {
    usqInt limit;

	if (!(isExcessiveAllocationRequestshift(delta, 0))) {
		statGrowMemory += 1;
		limit = sqGrowMemoryBy(memoryLimit, delta);
		if (!(limit == memoryLimit)) {

			/* remove a tad for safety */

			memoryLimit = (usqInt)limit - 24;
			initializeMemoryFirstFree(freeBlock);
		}
	}
	return null;
}


/*	Implemented in support code for Cog branch in Cross/vm/sqHeapMap.c and
	stubbed out here for use with trunk platform sources */

sqInt heapMapAtWord(sqInt wordPointer) {
	flag("FIXME");
	return 1;
}


/*	a more complex version that tells both the word reversal and the endianness of the machine it came from.  Low half of word is 6502.  Top byte is top byte of #doesNotUnderstand: on this machine. ($d on the Mac or $s on the PC) */

sqInt imageSegmentVersion(void) {
    sqInt wholeWord;


	/* first data word, 'does'  */

	wholeWord = longAt((longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (SelectorDoesNotUnderstand << (SHIFT_FOR_WORD)))) + (BASE_HEADER_SIZE));
	return imageFormatVersionNumber | (wholeWord & 4278190080U);
}


/*	Move objects to consolidate free space into one big chunk. Return the newly created free chunk. */

sqInt incCompBody(void) {
    sqInt bytesFreed;


	/* reserve memory for forwarding table */

	fwdTableInit((BYTES_PER_WORD) * 2);

	/* update pointers to point at new oops */

	bytesFreed = incCompMakeFwd();
	mapPointersInObjectsFromto((sqInt)youngStart, (sqInt)endOfMemory);
	return incCompMove(bytesFreed);
}


/*	Create and initialize forwarding blocks for all non-free objects  
	following compStart. If the supply of forwarding blocks is exhausted,  
	set compEnd to the first chunk above the area to be 
	compacted; otherwise, set it to endOfMemory. Return the number of 
	bytes to be freed. */

sqInt incCompMakeFwd(void) {
    sqInt bytesFreed;
    sqInt fwdBlock;
    sqInt newOop;
    sqInt oop;
    sqInt originalHeader;
    sqInt originalHeaderType;
    sqInt fwdBlock1;
    sqInt header;
    sqInt realHeader;
    sqInt sz;
    sqInt sz1;
    sqInt header1;

	bytesFreed = 0;
	oop = compStart + (headerTypeBytes[(longAt(compStart)) & TypeMask]);
	while ((((usqInt) oop)) < (((usqInt) endOfMemory))) {
		statMkFwdCount += 1;
		if (((longAt(oop)) & TypeMask) == HeaderTypeFree) {
			bytesFreed += (longAt(oop)) & (ALL_BUT_TYPE_MASK);
		} else {

			/* create a forwarding block for oop */

			/* begin fwdBlockGet: */
			fwdTableNext += (BYTES_PER_WORD) * 2;
			if (fwdTableNext <= fwdTableLast) {
				fwdBlock = fwdTableNext;
				goto l1;
			} else {
				fwdBlock = null;
				goto l1;
			}
		l1:	/* end fwdBlockGet: */;
			if (fwdBlock == null) {

				/* stop; we have used all available forwarding blocks */

				compEnd = (usqInt)oop - (headerTypeBytes[(longAt(oop)) & TypeMask]);
				return bytesFreed;
			}
			newOop = oop - bytesFreed;
			/* begin initForwardBlock:mapping:to:withBackPtr: */
			originalHeader = longAt(oop);
			if (DoAssertionChecks) {
				if (fwdBlock == null) {
					error("ran out of forwarding blocks in become");
				}
				if ((originalHeader & (MARK_BIT)) != 0) {
					error("object already has a forwarding table entry");
				}
			}
			originalHeaderType = originalHeader & TypeMask;
			longAtput(fwdBlock, newOop);
			longAtput(fwdBlock + (BYTES_PER_WORD), originalHeader);
			if (0) {
				longAtput(fwdBlock + ((BYTES_PER_WORD) * 2), oop);
			}
			longAtput(oop, (((usqInt) fwdBlock) >> 1) | ((MARK_BIT) | originalHeaderType));
		}
		/* begin objectAfterWhileForwarding: */
		header = longAt(oop);
		if ((header & (MARK_BIT)) == 0) {
			/* begin objectAfter: */
			if (DoAssertionChecks) {
				if ((((usqInt) oop)) >= (((usqInt) endOfMemory))) {
					error("no objects after the end of memory");
				}
			}
			if (((longAt(oop)) & TypeMask) == HeaderTypeFree) {
				sz1 = (longAt(oop)) & (ALL_BUT_TYPE_MASK);
			} else {
				/* begin sizeBitsOf: */
				header1 = longAt(oop);
				if ((header1 & TypeMask) == HeaderTypeSizeAndClass) {
					sz1 = (longAt(oop - ((BYTES_PER_WORD) * 2))) & (LONG_SIZE_MASK);
					goto l3;
				} else {
					sz1 = header1 & (SIZE_MASK);
					goto l3;
				}
			l3:	/* end sizeBitsOf: */;
			}
			oop = (oop + sz1) + (headerTypeBytes[(longAt(oop + sz1)) & TypeMask]);
			goto l2;
		}
		fwdBlock1 = (header & (ALL_BUT_MARK_BIT_AND_TYPE_MASK)) << 1;
		if (DoAssertionChecks) {
			/* begin fwdBlockValidate: */
			if (!(((((usqInt) fwdBlock1)) > (((usqInt) endOfMemory))) && (((((usqInt) fwdBlock1)) <= (((usqInt) fwdTableNext))) && ((fwdBlock1 & 3) == 0)))) {
				error("invalid fwd table entry");
			}
		}
		realHeader = longAt(fwdBlock1 + (BYTES_PER_WORD));
		if ((realHeader & TypeMask) == HeaderTypeSizeAndClass) {
			sz = (longAt(oop - ((BYTES_PER_WORD) * 2))) & (LONG_SIZE_MASK);
		} else {
			sz = realHeader & (SIZE_MASK);
		}
		oop = (oop + sz) + (headerTypeBytes[(longAt(oop + sz)) & TypeMask]);
	l2:	/* end objectAfterWhileForwarding: */;
	}
	compEnd = endOfMemory;
	return bytesFreed;
}


/*	Move all non-free objects between compStart and compEnd to their new  
	locations, restoring their headers in the process. Create a new free  
	block at the end of memory. Return the newly created free chunk.  */
/*	Note: The free block used by the allocator always must be the last free  
	block in memory. It may take several compaction passes to make all  
	free space bubble up to the end of memory. */

sqInt incCompMove(sqInt bytesFreed) {
    sqInt bytesToMove;
    usqInt firstWord;
    sqInt fwdBlock;
    sqInt header;
    usqInt lastWord;
    sqInt newFreeChunk;
    sqInt newOop;
    sqInt next;
    sqInt oop;
    sqInt sz;
    sqInt target;
    usqInt w;
    sqInt header1;
    sqInt fwdBlock1;
    sqInt header2;
    sqInt realHeader;
    sqInt sz1;
    sqInt sz2;
    sqInt header3;

	newOop = null;
	oop = compStart + (headerTypeBytes[(longAt(compStart)) & TypeMask]);
	while ((((usqInt) oop)) < (((usqInt) compEnd))) {
		statCompMoveCount += 1;
		/* begin objectAfterWhileForwarding: */
		header2 = longAt(oop);
		if ((header2 & (MARK_BIT)) == 0) {
			/* begin objectAfter: */
			if (DoAssertionChecks) {
				if ((((usqInt) oop)) >= (((usqInt) endOfMemory))) {
					error("no objects after the end of memory");
				}
			}
			if (((longAt(oop)) & TypeMask) == HeaderTypeFree) {
				sz2 = (longAt(oop)) & (ALL_BUT_TYPE_MASK);
			} else {
				/* begin sizeBitsOf: */
				header3 = longAt(oop);
				if ((header3 & TypeMask) == HeaderTypeSizeAndClass) {
					sz2 = (longAt(oop - ((BYTES_PER_WORD) * 2))) & (LONG_SIZE_MASK);
					goto l3;
				} else {
					sz2 = header3 & (SIZE_MASK);
					goto l3;
				}
			l3:	/* end sizeBitsOf: */;
			}
			next = (oop + sz2) + (headerTypeBytes[(longAt(oop + sz2)) & TypeMask]);
			goto l2;
		}
		fwdBlock1 = (header2 & (ALL_BUT_MARK_BIT_AND_TYPE_MASK)) << 1;
		if (DoAssertionChecks) {
			/* begin fwdBlockValidate: */
			if (!(((((usqInt) fwdBlock1)) > (((usqInt) endOfMemory))) && (((((usqInt) fwdBlock1)) <= (((usqInt) fwdTableNext))) && ((fwdBlock1 & 3) == 0)))) {
				error("invalid fwd table entry");
			}
		}
		realHeader = longAt(fwdBlock1 + (BYTES_PER_WORD));
		if ((realHeader & TypeMask) == HeaderTypeSizeAndClass) {
			sz1 = (longAt(oop - ((BYTES_PER_WORD) * 2))) & (LONG_SIZE_MASK);
		} else {
			sz1 = realHeader & (SIZE_MASK);
		}
		next = (oop + sz1) + (headerTypeBytes[(longAt(oop + sz1)) & TypeMask]);
	l2:	/* end objectAfterWhileForwarding: */;
		if (!(((longAt(oop)) & TypeMask) == HeaderTypeFree)) {

			/* a moving object; unwind its forwarding block */

			fwdBlock = ((longAt(oop)) & (ALL_BUT_MARK_BIT_AND_TYPE_MASK)) << 1;
			if (DoAssertionChecks) {
				/* begin fwdBlockValidate: */
				if (!(((((usqInt) fwdBlock)) > (((usqInt) endOfMemory))) && (((((usqInt) fwdBlock)) <= (((usqInt) fwdTableNext))) && ((fwdBlock & 3) == 0)))) {
					error("invalid fwd table entry");
				}
			}
			newOop = longAt(fwdBlock);
			header = longAt(fwdBlock + (BYTES_PER_WORD));
			longAtput(oop, header);

			/* move the oop (including any extra header words)  */

			bytesToMove = oop - newOop;
			/* begin sizeBitsOf: */
			header1 = longAt(oop);
			if ((header1 & TypeMask) == HeaderTypeSizeAndClass) {
				sz = (longAt(oop - ((BYTES_PER_WORD) * 2))) & (LONG_SIZE_MASK);
				goto l1;
			} else {
				sz = header1 & (SIZE_MASK);
				goto l1;
			}
		l1:	/* end sizeBitsOf: */;
			firstWord = oop - (headerTypeBytes[(longAt(oop)) & TypeMask]);
			lastWord = (oop + sz) - (BASE_HEADER_SIZE);
			target = firstWord - bytesToMove;
			for (w = firstWord; w <= lastWord; w += (BYTES_PER_WORD)) {
				longAtput(target, longAt(w));
				target += BYTES_PER_WORD;
			}
		}
		oop = next;
	}
	if (newOop == null) {

		/* no objects moved */

		oop = compStart + (headerTypeBytes[(longAt(compStart)) & TypeMask]);
		if ((((longAt(oop)) & TypeMask) == HeaderTypeFree) && ((objectAfter(oop)) == (compEnd + (headerTypeBytes[(longAt(compEnd)) & TypeMask])))) {
			newFreeChunk = oop;
		} else {
			newFreeChunk = freeBlock;
		}
	} else {

		/* initialize the newly freed memory chunk */
		/* newOop is the last object moved; free chunk starts 
			right after it */

		newFreeChunk = newOop + (sizeBitsOf(newOop));
		/* begin setSizeOfFree:to: */
		longAtput(newFreeChunk, (bytesFreed & (ALL_BUT_TYPE_MASK)) | HeaderTypeFree);
	}
	if (DoAssertionChecks) {
		if (!((objectAfter(newFreeChunk)) == (compEnd + (headerTypeBytes[(longAt(compEnd)) & TypeMask])))) {
			error("problem creating free chunk after compaction");
		}
	}
	if ((objectAfter(newFreeChunk)) == endOfMemory) {
		initializeMemoryFirstFree(newFreeChunk);
	} else {

		/* newFreeChunk is not at end of memory; re-install freeBlock  */

		initializeMemoryFirstFree(freeBlock);
	}
	return newFreeChunk;
}


/*	Return the equivalent of 
		aClass includesBehavior: aSuperclass.
	Note: written for efficiency and better inlining (only 1 temp) */

sqInt includesBehaviorThatOf(sqInt aClass, sqInt aSuperclass) {
    sqInt theClass;

	if (aSuperclass == nilObj) {
		return 0;
	}
	theClass = aClass;
	while (1) {
		if (theClass == aSuperclass) {
			return 1;
		}
		if (!(theClass != nilObj)) break;
		theClass = longAt((theClass + (BASE_HEADER_SIZE)) + (SuperclassIndex << (SHIFT_FOR_WORD)));
	}
	return 0;
}


/*	Do a mark/sweep garbage collection of just the young object 
	area of object memory (i.e., objects above youngStart), using 
	the root table to identify objects containing pointers to 
	young objects from the old object area. */

sqInt incrementalGC(void) {
    sqInt i;
    sqLong startTime;
    sqInt survivorCount;
    sqInt weDidGrow;
    sqInt growth;
    sqInt i1;
    sqInt oop;
    sqInt valuePointer;

	if (rootTableCount >= RootTableSize) {

		/* root table overflow; cannot do an incremental GC (this should be very rare) */

		statRootTableOverflows += 1;
		return fullGC();
	}
	if (DoAssertionChecks) {
		reverseDisplayFromto(8, 15);
		validateRoots();
		/* begin validate */
	}
	/* begin preGCAction: */
	if (compilerInitialized) {
		compilerPreGC(0);
	} else {
		/* begin storeContextRegisters: */
		longAtput((activeContext + (BASE_HEADER_SIZE)) + (InstructionPointerIndex << (SHIFT_FOR_WORD)), ((((instructionPointer - method) - ((BASE_HEADER_SIZE) - 2)) << 1) | 1));
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer = (((((((usqInt) ((stackPointer - activeContext) - (BASE_HEADER_SIZE))) >> (SHIFT_FOR_WORD)) - TempFrameStart) + 1) << 1) | 1);
		longAtput((activeContext + (BASE_HEADER_SIZE)) + (StackPointerIndex << (SHIFT_FOR_WORD)), valuePointer);
	}
	startTime = ioMicroSecondClock();
	weakRootCount = 0;
	statSweepCount = (statMarkCount = (statMkFwdCount = (statCompMoveCount = 0)));
	markPhase();
	for (i = 1; i <= weakRootCount; i += 1) {
		finalizeReference(weakRoots[i]);
	}
	survivorCount = sweepPhase();
	/* begin incrementalCompaction */
	if (compStart == freeBlock) {
		initializeMemoryFirstFree(freeBlock);
	} else {
		incCompBody();
	}
	statAllocationCount = allocationCount;
	allocationCount = 0;
	statIncrGCs += 1;
	statGCTime = ioMicroSecondClock();
	statIGCDeltaTime = (sqLong)statGCTime - startTime;
	statIncrGCMSecs += statIGCDeltaTime;
	/* begin capturePendingFinalizationSignals */
	/* begin setStatpendingFinalizationSignals: */
	statpendingFinalizationSignals = pendingFinalizationSignals;
	/* begin forceInterruptCheck */
	interruptCheckCounter = -1000;
	nextPollTick = 0;
	statRootTableCount = rootTableCount;
	statSurvivorCount = survivorCount;
	weDidGrow = 0;
	if (((survivorCount > tenuringThreshold) || (rootTableCount >= RootTableRedZone)) || (forceTenureFlag == 1)) {

		/* move up the young space boundary if 
			* there are too many survivors: 
			this limits the number of objects that must be 
			processed on future incremental GC's 
			* we're about to overflow the roots table 
			this limits the number of full GCs that may be caused 
			by root table overflows in the near future */

		forceTenureFlag = 0;
		statTenures += 1;
		/* begin clearRootsTable */
		for (i1 = 1; i1 <= rootTableCount; i1 += 1) {
			oop = rootTable[i1];
			longAtput(oop, (longAt(oop)) & (ALL_BUT_ROOT_BIT));
			rootTable[i1] = 0;
		}
		rootTableCount = 0;
		if ((freeBlock < growHeadroom) && (gcBiasToGrow > 0)) {
			biasToGrow();
			weDidGrow = 1;
		}
		youngStart = freeBlock;
	}
	postGCAction();
	if (DoAssertionChecks) {
		validateRoots();
		/* begin validate */
		reverseDisplayFromto(8, 15);
	}
	if (weDidGrow) {
		/* begin biasToGrowCheckGCLimit */
		growth = (youngStart - memory) - gcBiasToGrowThreshold;
		if (growth < 0) {
			gcBiasToGrowThreshold = (usqInt)youngStart - memory;
		}
		if (growth > gcBiasToGrowGCLimit) {
			fullGC();
			gcBiasToGrowThreshold = (usqInt)youngStart - memory;
		}
	}
	return null;
}


/*	Initialize hooks for the 'null compiler' */

sqInt initCompilerHooks(void) {
	compilerHooks[1]= nullCompilerHook;
	compilerHooks[2]= nullCompilerHook;
	compilerHooks[3]= nullCompilerHook;
	compilerHooks[4]= nullCompilerHook;
	compilerHooks[5]= nullCompilerHook;
	compilerHooks[6]= nullCompilerHook;
	compilerHooks[7]= nullCompilerHook;
	compilerHooks[8]= nullCompilerHook;
	compilerHooks[9]= nullCompilerHook;
	compilerHooks[10]= nullCompilerHook;
	compilerHooks[11]= nullCompilerHook;
	compilerHooks[12]= nullCompilerHook;
	compilerHooks[13]= nullCompilerHook;
	compilerHooks[14]= nullCompilerHook;
	compilerInitialized = 0;
	return null;
}


/*	Set the imageFormatVersionNumber to a default value for this word
	size. Normally this will have been set at image load time, but set it to
	a reasonable default if this has not been done. */

sqInt initializeImageFormatVersionIfNeeded(void) {
	if (imageFormatVersionNumber == 0) {
		if ((BYTES_PER_WORD) == 8) {
			imageFormatVersionNumber = 68000;
		} else {
			imageFormatVersionNumber = 6502;
		}
	}
	return null;
}


/*	Initialize Interpreter state before starting execution of a new image. */

sqInt initializeInterpreter(sqInt bytesToShift) {
    sqInt i;
    sqInt i1;
    sqInt proc;
    sqInt sched;
    sqInt oop;
    sqInt tmp;

	interpreterProxy = sqGetInterpreterProxy();
	dummyReferToProxy();
	initializeObjectMemory(bytesToShift);
	initCompilerHooks();
	activeContext = nilObj;
	theHomeContext = nilObj;
	method = nilObj;
	receiver = nilObj;
	messageSelector = nilObj;
	newMethod = nilObj;
	methodClass = nilObj;
	lkupClass = nilObj;
	receiverClass = nilObj;
	newNativeMethod = nilObj;
	/* begin flushMethodCache */
	for (i = 1; i <= MethodCacheSize; i += 1) {
		methodCache[i] = 0;
	}
	/* begin flushAtCache */
	for (i1 = 1; i1 <= AtCacheTotalSize; i1 += 1) {
		atCache[i1] = 0;
	}
	/* begin loadInitialContext */
	/* begin fetchPointer:ofObject: */
	oop = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (SchedulerAssociation << (SHIFT_FOR_WORD)));
	sched = longAt((oop + (BASE_HEADER_SIZE)) + (ValueIndex << (SHIFT_FOR_WORD)));
	proc = longAt((sched + (BASE_HEADER_SIZE)) + (ActiveProcessIndex << (SHIFT_FOR_WORD)));
	activeContext = (usqInt)longAt((proc + (BASE_HEADER_SIZE)) + (SuspendedContextIndex << (SHIFT_FOR_WORD)));
	if ((((usqInt) activeContext)) < (((usqInt) youngStart))) {
		beRootIfOld((sqInt)activeContext);
	}
	/* begin fetchContextRegisters: */
	tmp = longAt((activeContext + (BASE_HEADER_SIZE)) + (MethodIndex << (SHIFT_FOR_WORD)));
	if ((tmp & 1)) {
		tmp = longAt((activeContext + (BASE_HEADER_SIZE)) + (HomeIndex << (SHIFT_FOR_WORD)));
		if ((((usqInt) tmp)) < (((usqInt) youngStart))) {
			beRootIfOld(tmp);
		}
	} else {
		tmp = activeContext;
	}
	theHomeContext = tmp;
	receiver = longAt((tmp + (BASE_HEADER_SIZE)) + (ReceiverIndex << (SHIFT_FOR_WORD)));
	method = (usqInt)longAt((tmp + (BASE_HEADER_SIZE)) + (MethodIndex << (SHIFT_FOR_WORD)));
	tmp = ((longAt((activeContext + (BASE_HEADER_SIZE)) + (InstructionPointerIndex << (SHIFT_FOR_WORD)))) >> 1);
	instructionPointer = (usqInt)((method + tmp) + (BASE_HEADER_SIZE)) - 2;
	tmp = ((longAt((activeContext + (BASE_HEADER_SIZE)) + (StackPointerIndex << (SHIFT_FOR_WORD)))) >> 1);
	stackPointer = (usqInt)(activeContext + (BASE_HEADER_SIZE)) + (((TempFrameStart + tmp) - 1) * (BYTES_PER_WORD));
	reclaimableContextCount = 0;
	/* begin initialCleanup */
	if (((longAt(activeContext)) & (ROOT_BIT)) == 0) {
		goto l1;
	}
	longAtput(activeContext, (longAt(activeContext)) & (ALL_BUT_ROOT_BIT));
	flushExternalPrimitives();
l1:	/* end initialCleanup */;
	interruptCheckCounter = 0;
	interruptCheckCounterFeedBackReset = 1000;
	interruptChecksEveryNms = 1;
	nextPollTick = 0;
	nextWakeupTick = 0;
	lastTick = 0;

	/* cmd-. as used for Mac but no other OS */

	interruptKeycode = 2094;
	interruptPending = 0;
	semaphoresUseBufferA = 1;
	semaphoresToSignalCountA = 0;
	semaphoresToSignalCountB = 0;
	deferDisplayUpdates = 0;
	pendingFinalizationSignals = 0;
	globalSessionID = 0;
	while (globalSessionID == 0) {
		globalSessionID = time(NULL) + ioMSecs();
	}
	jmpDepth = 0;
	jmpMax = MaxJumpBuf;
	return null;
}


/*	Initialize endOfMemory to the top of oop storage space, reserving some space for forwarding blocks, and create the freeBlock from which space is allocated. Also create a fake free chunk at endOfMemory to act as a sentinal for memory scans.  */
/*	Note: The amount of space reserved for forwarding blocks should be chosen to ensure that incremental compactions can usually be done in a single pass. However, there should be enough forwarding blocks so a full compaction can be done in a reasonable number of passes, say ten. (A full compaction requires N object-moving passes, where N = number of non-garbage objects / number of forwarding blocks). 
	di 11/18/2000 Re totalObjectCount: Provide a margin of one byte per object to be used for forwarding pointers at GC time. Since fwd blocks are 8 bytes, this means an absolute worst case of 8 passes to compact memory. In most cases it will be adequate to do compaction in a single pass.  */

sqInt initializeMemoryFirstFree(usqInt firstFree) {
    usqInt fwdBlockBytes;


	/* reserve space for forwarding blocks */

	fwdBlockBytes = totalObjectCount & (((WORD_MASK) - (BYTES_PER_WORD)) + 1);
	if (!((((usqInt) (memoryLimit - fwdBlockBytes))) >= (((usqInt) (firstFree + (BASE_HEADER_SIZE)))))) {

		/* reserve enough space for a minimal free block of BaseHeaderSize bytes */

		fwdBlockBytes = memoryLimit - (firstFree + (BASE_HEADER_SIZE));
	}
	endOfMemory = (usqInt)memoryLimit - fwdBlockBytes;
	freeBlock = firstFree;
	/* begin setSizeOfFree:to: */
	longAtput(freeBlock, ((endOfMemory - firstFree) & (ALL_BUT_TYPE_MASK)) | HeaderTypeFree);
	/* begin setSizeOfFree:to: */
	longAtput(endOfMemory, ((BASE_HEADER_SIZE) & (ALL_BUT_TYPE_MASK)) | HeaderTypeFree);
	if (DoAssertionChecks) {
		if (!((freeBlock < endOfMemory) && (endOfMemory < memoryLimit))) {
			error("error in free space computation");
		}
		if (!((endOfMemory + (headerTypeBytes[(longAt(endOfMemory)) & TypeMask])) == endOfMemory)) {
			error("header format must have changed");
		}
		if (!((objectAfter((sqInt)freeBlock)) == endOfMemory)) {
			error("free block not properly initialized");
		}
	}
	return null;
}


/*	Initialize object memory variables at startup time. Assume endOfMemory is initially set (by the image-reading code) to the end of the last object in the image. Initialization redefines endOfMemory to be the end of the object allocation area based on the total available memory, but reserving some space for forwarding blocks. */
/*	Assume: image reader initializes the following variables:
		memory
		endOfMemory
		memoryLimit
		specialObjectsOop
		lastHash
	 */
/*	di 11/18/2000 fix slow full GC */
/*	set the start of the young object space */

sqInt initializeObjectMemory(sqInt bytesToShift) {

	/* image may be at a different address; adjust oops for new location */

	youngStart = endOfMemory;
	totalObjectCount = adjustAllOopsBy(bytesToShift);
	initializeMemoryFirstFree(endOfMemory);

	/* heavily used special objects */

	specialObjectsOop += bytesToShift;
	nilObj = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (NilObject << (SHIFT_FOR_WORD)));
	falseObj = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (FalseObject << (SHIFT_FOR_WORD)));
	trueObj = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (TrueObject << (SHIFT_FOR_WORD)));
	rootTableCount = 0;
	freeContexts = NilContext;
	freeLargeContexts = NilContext;
	allocationCount = 0;
	lowSpaceThreshold = 0;
	signalLowSpace = 0;
	compStart = 0;
	compEnd = 0;
	fwdTableNext = 0;
	fwdTableLast = 0;
	remapBufferCount = 0;

	/* do incremental GC after this many allocations */

	allocationsBetweenGCs = 4000;

	/* tenure all suriving objects if count is over this threshold */

	tenuringThreshold = 2000;

	/* four megabyte of headroom when growing */

	growHeadroom = (4 * 1024) * 1024;

	/* eight megabyte of free space before shrinking */
	/* garbage collection statistics */

	shrinkThreshold = (8 * 1024) * 1024;
	statFullGCs = 0;
	statFullGCMSecs = 0;
	statIncrGCs = 0;
	statIncrGCMSecs = 0;
	statTenures = 0;
	statRootTableOverflows = 0;
	statGrowMemory = 0;
	statShrinkMemory = 0;
	forceTenureFlag = 0;
	gcBiasToGrow = 0;
	gcBiasToGrowGCLimit = 0;
	extraRootCount = 0;
	return null;
}


/*	Install the oop of this object in the given cache (at or atPut), along with
	its size, format and fixedSize */

sqInt installinAtCacheatstring(sqInt rcvr, sqInt *cache, sqInt atIx, sqInt stringy) {
    sqInt fixedFields;
    sqInt fmt;
    sqInt hdr;
    sqInt totalLength;
    sqInt class;
    sqInt classFormat;
    sqInt sz;
    sqInt ccIndex;
    sqInt oop1;

	hdr = longAt(rcvr);
	fmt = (((usqInt) hdr) >> 8) & 15;
	if ((fmt == 3) && ((((((usqInt) hdr) >> 12) & 31) == 13) || ((((((usqInt) hdr) >> 12) & 31) == 14) || (((((usqInt) hdr) >> 12) & 31) == 4)))) {

		/* Contexts must not be put in the atCache, since their size is not constant */

		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		return null;
	}
	/* begin lengthOf:baseHeader:format: */
	if ((hdr & TypeMask) == HeaderTypeSizeAndClass) {
		sz = (longAt(rcvr - ((BYTES_PER_WORD) * 2))) & (LONG_SIZE_MASK);
	} else {
		sz = hdr & (SIZE_MASK);
	}
	sz -= hdr & (SIZE_4_BIT);
	if (fmt <= 4) {
		totalLength = ((usqInt) (sz - (BASE_HEADER_SIZE))) >> (SHIFT_FOR_WORD);
		goto l2;
	}
	if (fmt < 8) {
		totalLength = ((usqInt) (sz - (BASE_HEADER_SIZE))) >> 2;
		goto l2;
	} else {
		totalLength = (sz - (BASE_HEADER_SIZE)) - (fmt & 3);
		goto l2;
	}
l2:	/* end lengthOf:baseHeader:format: */;
	/* begin fixedFieldsOf:format:length: */
	if ((fmt > 4) || (fmt == 2)) {
		fixedFields = 0;
		goto l1;
	}
	if (fmt < 2) {
		fixedFields = totalLength;
		goto l1;
	}
	/* begin fetchClassOf: */
	if ((rcvr & 1)) {
		class = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassInteger << (SHIFT_FOR_WORD)));
		goto l3;
	}
	ccIndex = (((usqInt) (longAt(rcvr))) >> 12) & 31;
	if (ccIndex == 0) {
		class = (longAt(rcvr - (BASE_HEADER_SIZE))) & (ALL_BUT_TYPE_MASK);
		goto l3;
	} else {
		/* begin fetchPointer:ofObject: */
		oop1 = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (CompactClasses << (SHIFT_FOR_WORD)));
		class = longAt((oop1 + (BASE_HEADER_SIZE)) + ((ccIndex - 1) << (SHIFT_FOR_WORD)));
		goto l3;
	}
l3:	/* end fetchClassOf: */;
	classFormat = (longAt((class + (BASE_HEADER_SIZE)) + (InstanceSpecificationIndex << (SHIFT_FOR_WORD)))) - 1;
	fixedFields = (((((usqInt) classFormat) >> 11) & 192) + ((((usqInt) classFormat) >> 2) & 63)) - 1;
l1:	/* end fixedFieldsOf:format:length: */;
	cache[atIx + AtCacheOop] = rcvr;
	if (stringy) {
		cache[atIx + AtCacheFmt] = (fmt + 16);
	} else {
		cache[atIx + AtCacheFmt] = fmt;
	}
	cache[atIx + AtCacheFixedFields] = fixedFields;
	cache[atIx + AtCacheSize] = (totalLength - fixedFields);
	return null;
}


/*	Answer the number of slots in a class.  For example the instanceSizeOf: 
	 ClassPoint is 2, for the x & y slots. The instance size of non-pointer classes is 0. */

sqInt instanceSizeOf(sqInt classObj) {
    sqInt byteSize;
    sqInt classHdr;
    sqInt sizeHiBits;

	assert(addressCouldBeObj(classObj));

	/* Low 2 bits are 0 */
	/* Compute the size of instances of the class (used for fixed field classes only) */

	classHdr = (longAt((classObj + (BASE_HEADER_SIZE)) + (InstanceSpecificationIndex << (SHIFT_FOR_WORD)))) - 1;
	sizeHiBits = (((usqInt) classHdr) >> 9) & 768;

	/* size in bytes -- low 2 bits are 0 */

	byteSize = (classHdr & (SIZE_MASK)) + sizeHiBits;
	return (byteSize - (BASE_HEADER_SIZE)) / (BYTES_PER_WORD);
}


/*	NOTE: This method supports the backward-compatible split instSize field of the 
	class format word. The sizeHiBits will go away and other shifts change by 2 
	when the split fields get merged in an (incompatible) image change. */

sqInt instantiateClassindexableSize(sqInt classPointer, sqInt size) {
    sqInt binc;
    sqInt bm1;
    sqInt byteSize;
    sqInt cClass;
    sqInt classFormat;
    sqInt fillWord;
    sqInt format;
    sqInt hash;
    sqInt hdrSize;
    sqInt header1;
    sqInt header2;
    sqInt header3;
    sqInt newObj;
    sqInt sizeHiBits;
    usqInt end;
    usqInt i;
    sqInt newObj1;
    sqInt remappedClassOop;
    sqInt oop;
    sqInt enoughSpace;
    sqInt newChunk;
    sqInt newFreeSize;
    usqInt minFree;
    sqInt currentProc;
    sqInt lastSavedProcess;
    sqInt sched;
    sqInt oop1;

	if (DoAssertionChecks) {
		if (size < 0) {
			error("cannot have a negative indexable field count");
		}
	}
	/* begin newObjectHash */
	lastHash = (13849 + (27181 * lastHash)) & 65535;
	hash = lastHash;

	/* Low 2 bits are 0 */

	classFormat = (longAt((classPointer + (BASE_HEADER_SIZE)) + (InstanceSpecificationIndex << (SHIFT_FOR_WORD)))) - 1;
	header1 = (classFormat & 130816) | ((hash << HashBitsOffset) & HashBits);
	header2 = classPointer;
	header3 = 0;
	sizeHiBits = ((usqInt) (classFormat & 393216)) >> 9;

	/* compact class field from format word */

	cClass = header1 & CompactClassMask;

	/* size in bytes -- low 2 bits are 0 */
	/* Note this byteSize comes from the format word of the class which is pre-shifted
		to 4 bytes per field.  Need another shift for 8 bytes per word... */

	byteSize = (classFormat & ((SIZE_MASK) + (SIZE_4_BIT))) + sizeHiBits;
	byteSize = byteSize << ((SHIFT_FOR_WORD) - 2);
	format = (((usqInt) classFormat) >> 8) & 15;
	flag("sizeLowBits");
	if (format < 8) {
		if (format == 6) {

			/* long32 bitmaps */

			bm1 = (BYTES_PER_WORD) - 1;

			/* round up */

			byteSize = ((byteSize + (size * 4)) + bm1) & (LONG_SIZE_MASK);

			/* odd bytes */
			/* extra low bit (4) for 64-bit VM goes in 4-bit (betw hdr bits and sizeBits) */

			binc = bm1 - (((size * 4) + bm1) & bm1);
			header1 = header1 | (binc & 4);
		} else {

			/* Arrays and 64-bit bitmaps */

			byteSize += size * (BYTES_PER_WORD);
		}
	} else {

		/* Strings and Methods */

		bm1 = (BYTES_PER_WORD) - 1;

		/* round up */

		byteSize = ((byteSize + size) + bm1) & (LONG_SIZE_MASK);

		/* odd bytes */
		/* low bits of byte size go in format field */

		binc = bm1 - ((size + bm1) & bm1);

		/* extra low bit (4) for 64-bit VM goes in 4-bit (betw hdr bits and sizeBits) */

		header1 = header1 | ((binc & 3) << 8);
		header1 = header1 | (binc & 4);
	}
	if (byteSize > 255) {

		/* requires size header word */

		header3 = byteSize;
		header1 = header1;
	} else {
		header1 = header1 | byteSize;
	}
	if (header3 > 0) {

		/* requires full header */

		hdrSize = 3;
	} else {
		if (cClass == 0) {
			hdrSize = 2;
		} else {
			hdrSize = 1;
		}
	}
	if (format <= 4) {

		/* if pointers, fill with nil oop */

		fillWord = nilObj;
	} else {
		fillWord = 0;
	}
	/* begin allocate:headerSize:h1:h2:h3:doFill:with: */
	if (hdrSize > 1) {
		/* begin pushRemappableOop: */
		remapBuffer[(remapBufferCount += 1)] = header2;
	}
	/* begin allocateChunk: */
	if (allocationCount >= allocationsBetweenGCs) {
		incrementalGC();
	}
	/* begin sufficientSpaceToAllocate: */
	minFree = (lowSpaceThreshold + (byteSize + ((hdrSize - 1) * (BYTES_PER_WORD)))) + (BASE_HEADER_SIZE);
	if (oopisGreaterThanOrEqualTo((longAt(freeBlock)) & (ALL_BUT_TYPE_MASK), minFree)) {
		enoughSpace = 1;
		goto l1;
	} else {
		enoughSpace = sufficientSpaceAfterGC(minFree);
		goto l1;
	}
l1:	/* end sufficientSpaceToAllocate: */;
	if (!(enoughSpace)) {
		signalLowSpace = 1;
		lowSpaceThreshold = 0;
		/* begin saveProcessSignalingLowSpace */
		lastSavedProcess = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ProcessSignalingLowSpace << (SHIFT_FOR_WORD)));
		if (lastSavedProcess == nilObj) {
			/* begin fetchPointer:ofObject: */
			oop1 = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (SchedulerAssociation << (SHIFT_FOR_WORD)));
			sched = longAt((oop1 + (BASE_HEADER_SIZE)) + (ValueIndex << (SHIFT_FOR_WORD)));
			currentProc = longAt((sched + (BASE_HEADER_SIZE)) + (ActiveProcessIndex << (SHIFT_FOR_WORD)));
			/* begin storePointer:ofObject:withValue: */
			if ((((usqInt) specialObjectsOop)) < (((usqInt) youngStart))) {
				possibleRootStoreIntovalue(specialObjectsOop, currentProc);
			}
			longAtput((specialObjectsOop + (BASE_HEADER_SIZE)) + (ProcessSignalingLowSpace << (SHIFT_FOR_WORD)), currentProc);
		}
		/* begin forceInterruptCheck */
		interruptCheckCounter = -1000;
		nextPollTick = 0;
	}
	if (oopisLessThan((longAt(freeBlock)) & (ALL_BUT_TYPE_MASK), (byteSize + ((hdrSize - 1) * (BYTES_PER_WORD))) + (BASE_HEADER_SIZE))) {
		error("out of memory");
	}
	newFreeSize = ((longAt(freeBlock)) & (ALL_BUT_TYPE_MASK)) - (byteSize + ((hdrSize - 1) * (BYTES_PER_WORD)));
	newChunk = freeBlock;
	freeBlock += byteSize + ((hdrSize - 1) * (BYTES_PER_WORD));
	/* begin setSizeOfFree:to: */
	longAtput(freeBlock, (newFreeSize & (ALL_BUT_TYPE_MASK)) | HeaderTypeFree);
	allocationCount += 1;
	newObj1 = newChunk;
	if (hdrSize > 1) {
		/* begin popRemappableOop */
		oop = remapBuffer[remapBufferCount];
		remapBufferCount -= 1;
		remappedClassOop = oop;
	}
	if (hdrSize == 3) {
		longAtput(newObj1, header3 | HeaderTypeSizeAndClass);
		longAtput(newObj1 + (BYTES_PER_WORD), remappedClassOop | HeaderTypeSizeAndClass);
		longAtput(newObj1 + ((BYTES_PER_WORD) * 2), header1 | HeaderTypeSizeAndClass);
		newObj1 += (BYTES_PER_WORD) * 2;
	}
	if (hdrSize == 2) {
		longAtput(newObj1, remappedClassOop | HeaderTypeClass);
		longAtput(newObj1 + (BYTES_PER_WORD), header1 | HeaderTypeClass);
		newObj1 += BYTES_PER_WORD;
	}
	if (hdrSize == 1) {
		longAtput(newObj1, header1 | HeaderTypeShort);
	}
	if (1) {
		end = newObj1 + byteSize;
		i = newObj1 + (BYTES_PER_WORD);
		while (i < end) {
			longAtput(i, fillWord);
			i += BYTES_PER_WORD;
		}
	}
	if (DoAssertionChecks) {
		okayOop(newObj1);
		oopHasOkayClass(newObj1);
		if (!((objectAfter(newObj1)) == freeBlock)) {
			error("allocate bug: did not set header of new oop correctly");
		}
		if (!((objectAfter((sqInt)freeBlock)) == endOfMemory)) {
			error("allocate bug: did not set header of freeBlock correctly");
		}
	}
	newObj = newObj1;
	return newObj;
}


/*	This version of instantiateClass assumes that the total object 
	size is under 256 bytes, the limit for objects with only one or 
	two header words. Note that the size is specified in bytes 
	and should include four bytes for the base header word. */

sqInt instantiateContextsizeInBytes(sqInt classPointer, sqInt sizeInBytes) {
    sqInt hash;
    sqInt hdrSize;
    sqInt header1;
    sqInt header2;
    sqInt extendedSize;
    usqInt end;
    usqInt i;
    sqInt newObj;
    sqInt remappedClassOop;
    sqInt oop;
    sqInt enoughSpace;
    sqInt newChunk;
    sqInt newFreeSize;
    usqInt minFree;
    sqInt currentProc;
    sqInt lastSavedProcess;
    sqInt sched;
    sqInt oop1;

	/* begin newObjectHash */
	lastHash = (13849 + (27181 * lastHash)) & 65535;
	hash = lastHash;
	header1 = ((hash << HashBitsOffset) & HashBits) | ((longAt((classPointer + (BASE_HEADER_SIZE)) + (InstanceSpecificationIndex << (SHIFT_FOR_WORD)))) - 1);
	header2 = classPointer;
	if ((header1 & CompactClassMask) > 0) {

		/* are contexts compact? */

		hdrSize = 1;
	} else {
		hdrSize = 2;
	}
	if (sizeInBytes <= (SIZE_MASK)) {

		/* OR size into header1.  Must not do this if size > SizeMask */

		header1 += sizeInBytes - (header1 & (SIZE_MASK));
	} else {

		/* Zero the size field of header1 if large */

		hdrSize = 3;
		header1 -= header1 & (SIZE_MASK);
	}
	flag("Dan");
	/* begin allocate:headerSize:h1:h2:h3:doFill:with: */
	extendedSize = LARGE_CONTEXT_SIZE;
	if (hdrSize > 1) {
		/* begin pushRemappableOop: */
		remapBuffer[(remapBufferCount += 1)] = header2;
	}
	/* begin allocateChunk: */
	if (allocationCount >= allocationsBetweenGCs) {
		incrementalGC();
	}
	/* begin sufficientSpaceToAllocate: */
	minFree = (lowSpaceThreshold + (sizeInBytes + ((hdrSize - 1) * (BYTES_PER_WORD)))) + (BASE_HEADER_SIZE);
	if (oopisGreaterThanOrEqualTo((longAt(freeBlock)) & (ALL_BUT_TYPE_MASK), minFree)) {
		enoughSpace = 1;
		goto l1;
	} else {
		enoughSpace = sufficientSpaceAfterGC(minFree);
		goto l1;
	}
l1:	/* end sufficientSpaceToAllocate: */;
	if (!(enoughSpace)) {
		signalLowSpace = 1;
		lowSpaceThreshold = 0;
		/* begin saveProcessSignalingLowSpace */
		lastSavedProcess = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ProcessSignalingLowSpace << (SHIFT_FOR_WORD)));
		if (lastSavedProcess == nilObj) {
			/* begin fetchPointer:ofObject: */
			oop1 = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (SchedulerAssociation << (SHIFT_FOR_WORD)));
			sched = longAt((oop1 + (BASE_HEADER_SIZE)) + (ValueIndex << (SHIFT_FOR_WORD)));
			currentProc = longAt((sched + (BASE_HEADER_SIZE)) + (ActiveProcessIndex << (SHIFT_FOR_WORD)));
			/* begin storePointer:ofObject:withValue: */
			if ((((usqInt) specialObjectsOop)) < (((usqInt) youngStart))) {
				possibleRootStoreIntovalue(specialObjectsOop, currentProc);
			}
			longAtput((specialObjectsOop + (BASE_HEADER_SIZE)) + (ProcessSignalingLowSpace << (SHIFT_FOR_WORD)), currentProc);
		}
		/* begin forceInterruptCheck */
		interruptCheckCounter = -1000;
		nextPollTick = 0;
	}
	if (oopisLessThan((longAt(freeBlock)) & (ALL_BUT_TYPE_MASK), (sizeInBytes + ((hdrSize - 1) * (BYTES_PER_WORD))) + (BASE_HEADER_SIZE))) {
		error("out of memory");
	}
	newFreeSize = ((longAt(freeBlock)) & (ALL_BUT_TYPE_MASK)) - (sizeInBytes + ((hdrSize - 1) * (BYTES_PER_WORD)));
	newChunk = freeBlock;
	freeBlock += sizeInBytes + ((hdrSize - 1) * (BYTES_PER_WORD));
	/* begin setSizeOfFree:to: */
	longAtput(freeBlock, (newFreeSize & (ALL_BUT_TYPE_MASK)) | HeaderTypeFree);
	allocationCount += 1;
	newObj = newChunk;
	if (hdrSize > 1) {
		/* begin popRemappableOop */
		oop = remapBuffer[remapBufferCount];
		remapBufferCount -= 1;
		remappedClassOop = oop;
	}
	if (hdrSize == 3) {
		longAtput(newObj, extendedSize | HeaderTypeSizeAndClass);
		longAtput(newObj + (BYTES_PER_WORD), remappedClassOop | HeaderTypeSizeAndClass);
		longAtput(newObj + ((BYTES_PER_WORD) * 2), header1 | HeaderTypeSizeAndClass);
		newObj += (BYTES_PER_WORD) * 2;
	}
	if (hdrSize == 2) {
		longAtput(newObj, remappedClassOop | HeaderTypeClass);
		longAtput(newObj + (BYTES_PER_WORD), header1 | HeaderTypeClass);
		newObj += BYTES_PER_WORD;
	}
	if (hdrSize == 1) {
		longAtput(newObj, header1 | HeaderTypeShort);
	}
	if (0) {
		end = newObj + sizeInBytes;
		i = newObj + (BYTES_PER_WORD);
		while (i < end) {
			longAtput(i, 0);
			i += BYTES_PER_WORD;
		}
	}
	if (DoAssertionChecks) {
		okayOop(newObj);
		oopHasOkayClass(newObj);
		if (!((objectAfter(newObj)) == freeBlock)) {
			error("allocate bug: did not set header of new oop correctly");
		}
		if (!((objectAfter((sqInt)freeBlock)) == endOfMemory)) {
			error("allocate bug: did not set header of freeBlock correctly");
		}
	}
	return newObj;
}


/*	This version of instantiateClass assumes that the total object 
	size is under 256 bytes, the limit for objects with only one or 
	two header words. Note that the size is specified in bytes 
	and should include 4 or 8 bytes for the base header word. 
	NOTE this code will only work for sizes that are an integral number of words
		(like not a 32-bit LargeInteger in a 64-bit system). 
	May cause a GC.
	Note that the created small object IS NOT FILLED and must be completed before returning it to Squeak. Since this call is used in routines that do jsut that we are safe. Break this rule and die. */

sqInt instantiateSmallClasssizeInBytes(sqInt classPointer, sqInt sizeInBytes) {
    sqInt hash;
    sqInt hdrSize;
    sqInt header1;
    sqInt header2;
    usqInt end;
    usqInt i;
    sqInt newObj;
    sqInt remappedClassOop;
    sqInt oop;
    sqInt enoughSpace;
    sqInt newChunk;
    sqInt newFreeSize;
    usqInt minFree;
    sqInt currentProc;
    sqInt lastSavedProcess;
    sqInt sched;
    sqInt oop1;

	if (!((sizeInBytes & ((BYTES_PER_WORD) - 1)) == 0)) {
		error("size must be integral number of words");
	}
	/* begin newObjectHash */
	lastHash = (13849 + (27181 * lastHash)) & 65535;
	hash = lastHash;
	header1 = ((hash << HashBitsOffset) & HashBits) | ((longAt((classPointer + (BASE_HEADER_SIZE)) + (InstanceSpecificationIndex << (SHIFT_FOR_WORD)))) - 1);
	header2 = classPointer;
	if ((header1 & CompactClassMask) > 0) {

		/* is this a compact class */

		hdrSize = 1;
	} else {
		hdrSize = 2;
	}
	header1 += sizeInBytes - (header1 & ((SIZE_MASK) + (SIZE_4_BIT)));
	/* begin allocate:headerSize:h1:h2:h3:doFill:with: */
	if (hdrSize > 1) {
		/* begin pushRemappableOop: */
		remapBuffer[(remapBufferCount += 1)] = header2;
	}
	/* begin allocateChunk: */
	if (allocationCount >= allocationsBetweenGCs) {
		incrementalGC();
	}
	/* begin sufficientSpaceToAllocate: */
	minFree = (lowSpaceThreshold + (sizeInBytes + ((hdrSize - 1) * (BYTES_PER_WORD)))) + (BASE_HEADER_SIZE);
	if (oopisGreaterThanOrEqualTo((longAt(freeBlock)) & (ALL_BUT_TYPE_MASK), minFree)) {
		enoughSpace = 1;
		goto l1;
	} else {
		enoughSpace = sufficientSpaceAfterGC(minFree);
		goto l1;
	}
l1:	/* end sufficientSpaceToAllocate: */;
	if (!(enoughSpace)) {
		signalLowSpace = 1;
		lowSpaceThreshold = 0;
		/* begin saveProcessSignalingLowSpace */
		lastSavedProcess = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ProcessSignalingLowSpace << (SHIFT_FOR_WORD)));
		if (lastSavedProcess == nilObj) {
			/* begin fetchPointer:ofObject: */
			oop1 = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (SchedulerAssociation << (SHIFT_FOR_WORD)));
			sched = longAt((oop1 + (BASE_HEADER_SIZE)) + (ValueIndex << (SHIFT_FOR_WORD)));
			currentProc = longAt((sched + (BASE_HEADER_SIZE)) + (ActiveProcessIndex << (SHIFT_FOR_WORD)));
			/* begin storePointer:ofObject:withValue: */
			if ((((usqInt) specialObjectsOop)) < (((usqInt) youngStart))) {
				possibleRootStoreIntovalue(specialObjectsOop, currentProc);
			}
			longAtput((specialObjectsOop + (BASE_HEADER_SIZE)) + (ProcessSignalingLowSpace << (SHIFT_FOR_WORD)), currentProc);
		}
		/* begin forceInterruptCheck */
		interruptCheckCounter = -1000;
		nextPollTick = 0;
	}
	if (oopisLessThan((longAt(freeBlock)) & (ALL_BUT_TYPE_MASK), (sizeInBytes + ((hdrSize - 1) * (BYTES_PER_WORD))) + (BASE_HEADER_SIZE))) {
		error("out of memory");
	}
	newFreeSize = ((longAt(freeBlock)) & (ALL_BUT_TYPE_MASK)) - (sizeInBytes + ((hdrSize - 1) * (BYTES_PER_WORD)));
	newChunk = freeBlock;
	freeBlock += sizeInBytes + ((hdrSize - 1) * (BYTES_PER_WORD));
	/* begin setSizeOfFree:to: */
	longAtput(freeBlock, (newFreeSize & (ALL_BUT_TYPE_MASK)) | HeaderTypeFree);
	allocationCount += 1;
	newObj = newChunk;
	if (hdrSize > 1) {
		/* begin popRemappableOop */
		oop = remapBuffer[remapBufferCount];
		remapBufferCount -= 1;
		remappedClassOop = oop;
	}
	if (hdrSize == 3) {
		longAtput(newObj, 0 | HeaderTypeSizeAndClass);
		longAtput(newObj + (BYTES_PER_WORD), remappedClassOop | HeaderTypeSizeAndClass);
		longAtput(newObj + ((BYTES_PER_WORD) * 2), header1 | HeaderTypeSizeAndClass);
		newObj += (BYTES_PER_WORD) * 2;
	}
	if (hdrSize == 2) {
		longAtput(newObj, remappedClassOop | HeaderTypeClass);
		longAtput(newObj + (BYTES_PER_WORD), header1 | HeaderTypeClass);
		newObj += BYTES_PER_WORD;
	}
	if (hdrSize == 1) {
		longAtput(newObj, header1 | HeaderTypeShort);
	}
	if (0) {
		end = newObj + sizeInBytes;
		i = newObj + (BYTES_PER_WORD);
		while (i < end) {
			longAtput(i, 0);
			i += BYTES_PER_WORD;
		}
	}
	if (DoAssertionChecks) {
		okayOop(newObj);
		oopHasOkayClass(newObj);
		if (!((objectAfter(newObj)) == freeBlock)) {
			error("allocate bug: did not set header of new oop correctly");
		}
		if (!((objectAfter((sqInt)freeBlock)) == endOfMemory)) {
			error("allocate bug: did not set header of freeBlock correctly");
		}
	}
	return newObj;
}


/*	Like #stackIntegerValue: but access method arguments left-to-right */

sqInt integerArg(sqInt index) {
    sqInt oop;

	oop = methodArg(index);
	if (oop == 0) {
		return 0.0;
	}
	/* begin checkedIntegerValueOf: */
	if ((oop & 1)) {
		return (oop >> 1);
	} else {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		return 0;
	}
	return null;
}

sqInt integerObjectOf(sqInt value) {
	return (value << 1) + 1;
}


/*	Translator produces 'objectPointer >> 1' */

sqInt integerValueOf(sqInt objectPointer) {
	if ((objectPointer & 2147483648U) != 0) {

		/* negative */

		return ((((usqInt) (objectPointer & 2147483647U)) >> 1) - 1073741823) - 1;
	} else {

		/* positive */

		return ((usqInt) objectPointer) >> 1;
	}
	return null;
}

EXPORT(sqInt) internalIsImmutable(sqInt oop) {
	return 0;
}

EXPORT(sqInt) internalIsMutable(sqInt oop) {
	return 1;
}


/*	This is the main interpreter loop. It normally loops forever, fetching and executing bytecodes. When running in the context of a browser plugin VM, however, it must return control to the browser periodically. This should done only when the state of the currently running Squeak thread is safely stored in the object heap. Since this is the case at the moment that a check for interrupts is performed, that is when we return to the browser if it is time to do so. Interrupt checks happen quite frequently. */
/*	should not be inlined into any senders */
/*	record entry time when running as a browser plug-in */

sqInt interpret(void) {
    sqInt localReturnValue;
    sqInt localReturnContext;
    sqInt localHomeContext;
    char* localSP;
    char* localIP;
    sqInt currentBytecode;

	browserPluginInitialiseIfNeeded();
	initializeImageFormatVersionIfNeeded();
	/* begin internalizeIPandSP */
	localIP = pointerForOop(instructionPointer);
	localSP = pointerForOop(stackPointer);
	localHomeContext = theHomeContext;
	/* begin fetchNextBytecode */
	currentBytecode = byteAtPointer(++localIP);
	while (1) {
		switch (currentBytecode) {
		case 0:
			/* pushReceiverVariableBytecode */
			{
				sqInt object;
				flag("requires currentBytecode to be expanded to a constant");
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushReceiverVariable: */
				/* begin internalPush: */
				object = longAt((receiver + (BASE_HEADER_SIZE)) + ((0 & 15) << (SHIFT_FOR_WORD)));
				longAtPointerput((localSP += BYTES_PER_WORD), object);
			}
;
			break;
		case 1:
			/* pushReceiverVariableBytecode */
			{
				sqInt object;
				flag("requires currentBytecode to be expanded to a constant");
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushReceiverVariable: */
				/* begin internalPush: */
				object = longAt((receiver + (BASE_HEADER_SIZE)) + ((1 & 15) << (SHIFT_FOR_WORD)));
				longAtPointerput((localSP += BYTES_PER_WORD), object);
			}
;
			break;
		case 2:
			/* pushReceiverVariableBytecode */
			{
				sqInt object;
				flag("requires currentBytecode to be expanded to a constant");
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushReceiverVariable: */
				/* begin internalPush: */
				object = longAt((receiver + (BASE_HEADER_SIZE)) + ((2 & 15) << (SHIFT_FOR_WORD)));
				longAtPointerput((localSP += BYTES_PER_WORD), object);
			}
;
			break;
		case 3:
			/* pushReceiverVariableBytecode */
			{
				sqInt object;
				flag("requires currentBytecode to be expanded to a constant");
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushReceiverVariable: */
				/* begin internalPush: */
				object = longAt((receiver + (BASE_HEADER_SIZE)) + ((3 & 15) << (SHIFT_FOR_WORD)));
				longAtPointerput((localSP += BYTES_PER_WORD), object);
			}
;
			break;
		case 4:
			/* pushReceiverVariableBytecode */
			{
				sqInt object;
				flag("requires currentBytecode to be expanded to a constant");
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushReceiverVariable: */
				/* begin internalPush: */
				object = longAt((receiver + (BASE_HEADER_SIZE)) + ((4 & 15) << (SHIFT_FOR_WORD)));
				longAtPointerput((localSP += BYTES_PER_WORD), object);
			}
;
			break;
		case 5:
			/* pushReceiverVariableBytecode */
			{
				sqInt object;
				flag("requires currentBytecode to be expanded to a constant");
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushReceiverVariable: */
				/* begin internalPush: */
				object = longAt((receiver + (BASE_HEADER_SIZE)) + ((5 & 15) << (SHIFT_FOR_WORD)));
				longAtPointerput((localSP += BYTES_PER_WORD), object);
			}
;
			break;
		case 6:
			/* pushReceiverVariableBytecode */
			{
				sqInt object;
				flag("requires currentBytecode to be expanded to a constant");
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushReceiverVariable: */
				/* begin internalPush: */
				object = longAt((receiver + (BASE_HEADER_SIZE)) + ((6 & 15) << (SHIFT_FOR_WORD)));
				longAtPointerput((localSP += BYTES_PER_WORD), object);
			}
;
			break;
		case 7:
			/* pushReceiverVariableBytecode */
			{
				sqInt object;
				flag("requires currentBytecode to be expanded to a constant");
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushReceiverVariable: */
				/* begin internalPush: */
				object = longAt((receiver + (BASE_HEADER_SIZE)) + ((7 & 15) << (SHIFT_FOR_WORD)));
				longAtPointerput((localSP += BYTES_PER_WORD), object);
			}
;
			break;
		case 8:
			/* pushReceiverVariableBytecode */
			{
				sqInt object;
				flag("requires currentBytecode to be expanded to a constant");
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushReceiverVariable: */
				/* begin internalPush: */
				object = longAt((receiver + (BASE_HEADER_SIZE)) + ((8 & 15) << (SHIFT_FOR_WORD)));
				longAtPointerput((localSP += BYTES_PER_WORD), object);
			}
;
			break;
		case 9:
			/* pushReceiverVariableBytecode */
			{
				sqInt object;
				flag("requires currentBytecode to be expanded to a constant");
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushReceiverVariable: */
				/* begin internalPush: */
				object = longAt((receiver + (BASE_HEADER_SIZE)) + ((9 & 15) << (SHIFT_FOR_WORD)));
				longAtPointerput((localSP += BYTES_PER_WORD), object);
			}
;
			break;
		case 10:
			/* pushReceiverVariableBytecode */
			{
				sqInt object;
				flag("requires currentBytecode to be expanded to a constant");
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushReceiverVariable: */
				/* begin internalPush: */
				object = longAt((receiver + (BASE_HEADER_SIZE)) + ((10 & 15) << (SHIFT_FOR_WORD)));
				longAtPointerput((localSP += BYTES_PER_WORD), object);
			}
;
			break;
		case 11:
			/* pushReceiverVariableBytecode */
			{
				sqInt object;
				flag("requires currentBytecode to be expanded to a constant");
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushReceiverVariable: */
				/* begin internalPush: */
				object = longAt((receiver + (BASE_HEADER_SIZE)) + ((11 & 15) << (SHIFT_FOR_WORD)));
				longAtPointerput((localSP += BYTES_PER_WORD), object);
			}
;
			break;
		case 12:
			/* pushReceiverVariableBytecode */
			{
				sqInt object;
				flag("requires currentBytecode to be expanded to a constant");
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushReceiverVariable: */
				/* begin internalPush: */
				object = longAt((receiver + (BASE_HEADER_SIZE)) + ((12 & 15) << (SHIFT_FOR_WORD)));
				longAtPointerput((localSP += BYTES_PER_WORD), object);
			}
;
			break;
		case 13:
			/* pushReceiverVariableBytecode */
			{
				sqInt object;
				flag("requires currentBytecode to be expanded to a constant");
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushReceiverVariable: */
				/* begin internalPush: */
				object = longAt((receiver + (BASE_HEADER_SIZE)) + ((13 & 15) << (SHIFT_FOR_WORD)));
				longAtPointerput((localSP += BYTES_PER_WORD), object);
			}
;
			break;
		case 14:
			/* pushReceiverVariableBytecode */
			{
				sqInt object;
				flag("requires currentBytecode to be expanded to a constant");
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushReceiverVariable: */
				/* begin internalPush: */
				object = longAt((receiver + (BASE_HEADER_SIZE)) + ((14 & 15) << (SHIFT_FOR_WORD)));
				longAtPointerput((localSP += BYTES_PER_WORD), object);
			}
;
			break;
		case 15:
			/* pushReceiverVariableBytecode */
			{
				sqInt object;
				flag("requires currentBytecode to be expanded to a constant");
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushReceiverVariable: */
				/* begin internalPush: */
				object = longAt((receiver + (BASE_HEADER_SIZE)) + ((15 & 15) << (SHIFT_FOR_WORD)));
				longAtPointerput((localSP += BYTES_PER_WORD), object);
			}
;
			break;
		case 16:
			/* pushTemporaryVariableBytecode */
			{
				sqInt object;
				flag("requires currentBytecode to be expanded to a constant");
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushTemporaryVariable: */
				/* begin internalPush: */
				object = longAt((localHomeContext + (BASE_HEADER_SIZE)) + (((16 & 15) + TempFrameStart) << (SHIFT_FOR_WORD)));
				longAtPointerput((localSP += BYTES_PER_WORD), object);
			}
;
			break;
		case 17:
			/* pushTemporaryVariableBytecode */
			{
				sqInt object;
				flag("requires currentBytecode to be expanded to a constant");
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushTemporaryVariable: */
				/* begin internalPush: */
				object = longAt((localHomeContext + (BASE_HEADER_SIZE)) + (((17 & 15) + TempFrameStart) << (SHIFT_FOR_WORD)));
				longAtPointerput((localSP += BYTES_PER_WORD), object);
			}
;
			break;
		case 18:
			/* pushTemporaryVariableBytecode */
			{
				sqInt object;
				flag("requires currentBytecode to be expanded to a constant");
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushTemporaryVariable: */
				/* begin internalPush: */
				object = longAt((localHomeContext + (BASE_HEADER_SIZE)) + (((18 & 15) + TempFrameStart) << (SHIFT_FOR_WORD)));
				longAtPointerput((localSP += BYTES_PER_WORD), object);
			}
;
			break;
		case 19:
			/* pushTemporaryVariableBytecode */
			{
				sqInt object;
				flag("requires currentBytecode to be expanded to a constant");
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushTemporaryVariable: */
				/* begin internalPush: */
				object = longAt((localHomeContext + (BASE_HEADER_SIZE)) + (((19 & 15) + TempFrameStart) << (SHIFT_FOR_WORD)));
				longAtPointerput((localSP += BYTES_PER_WORD), object);
			}
;
			break;
		case 20:
			/* pushTemporaryVariableBytecode */
			{
				sqInt object;
				flag("requires currentBytecode to be expanded to a constant");
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushTemporaryVariable: */
				/* begin internalPush: */
				object = longAt((localHomeContext + (BASE_HEADER_SIZE)) + (((20 & 15) + TempFrameStart) << (SHIFT_FOR_WORD)));
				longAtPointerput((localSP += BYTES_PER_WORD), object);
			}
;
			break;
		case 21:
			/* pushTemporaryVariableBytecode */
			{
				sqInt object;
				flag("requires currentBytecode to be expanded to a constant");
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushTemporaryVariable: */
				/* begin internalPush: */
				object = longAt((localHomeContext + (BASE_HEADER_SIZE)) + (((21 & 15) + TempFrameStart) << (SHIFT_FOR_WORD)));
				longAtPointerput((localSP += BYTES_PER_WORD), object);
			}
;
			break;
		case 22:
			/* pushTemporaryVariableBytecode */
			{
				sqInt object;
				flag("requires currentBytecode to be expanded to a constant");
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushTemporaryVariable: */
				/* begin internalPush: */
				object = longAt((localHomeContext + (BASE_HEADER_SIZE)) + (((22 & 15) + TempFrameStart) << (SHIFT_FOR_WORD)));
				longAtPointerput((localSP += BYTES_PER_WORD), object);
			}
;
			break;
		case 23:
			/* pushTemporaryVariableBytecode */
			{
				sqInt object;
				flag("requires currentBytecode to be expanded to a constant");
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushTemporaryVariable: */
				/* begin internalPush: */
				object = longAt((localHomeContext + (BASE_HEADER_SIZE)) + (((23 & 15) + TempFrameStart) << (SHIFT_FOR_WORD)));
				longAtPointerput((localSP += BYTES_PER_WORD), object);
			}
;
			break;
		case 24:
			/* pushTemporaryVariableBytecode */
			{
				sqInt object;
				flag("requires currentBytecode to be expanded to a constant");
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushTemporaryVariable: */
				/* begin internalPush: */
				object = longAt((localHomeContext + (BASE_HEADER_SIZE)) + (((24 & 15) + TempFrameStart) << (SHIFT_FOR_WORD)));
				longAtPointerput((localSP += BYTES_PER_WORD), object);
			}
;
			break;
		case 25:
			/* pushTemporaryVariableBytecode */
			{
				sqInt object;
				flag("requires currentBytecode to be expanded to a constant");
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushTemporaryVariable: */
				/* begin internalPush: */
				object = longAt((localHomeContext + (BASE_HEADER_SIZE)) + (((25 & 15) + TempFrameStart) << (SHIFT_FOR_WORD)));
				longAtPointerput((localSP += BYTES_PER_WORD), object);
			}
;
			break;
		case 26:
			/* pushTemporaryVariableBytecode */
			{
				sqInt object;
				flag("requires currentBytecode to be expanded to a constant");
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushTemporaryVariable: */
				/* begin internalPush: */
				object = longAt((localHomeContext + (BASE_HEADER_SIZE)) + (((26 & 15) + TempFrameStart) << (SHIFT_FOR_WORD)));
				longAtPointerput((localSP += BYTES_PER_WORD), object);
			}
;
			break;
		case 27:
			/* pushTemporaryVariableBytecode */
			{
				sqInt object;
				flag("requires currentBytecode to be expanded to a constant");
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushTemporaryVariable: */
				/* begin internalPush: */
				object = longAt((localHomeContext + (BASE_HEADER_SIZE)) + (((27 & 15) + TempFrameStart) << (SHIFT_FOR_WORD)));
				longAtPointerput((localSP += BYTES_PER_WORD), object);
			}
;
			break;
		case 28:
			/* pushTemporaryVariableBytecode */
			{
				sqInt object;
				flag("requires currentBytecode to be expanded to a constant");
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushTemporaryVariable: */
				/* begin internalPush: */
				object = longAt((localHomeContext + (BASE_HEADER_SIZE)) + (((28 & 15) + TempFrameStart) << (SHIFT_FOR_WORD)));
				longAtPointerput((localSP += BYTES_PER_WORD), object);
			}
;
			break;
		case 29:
			/* pushTemporaryVariableBytecode */
			{
				sqInt object;
				flag("requires currentBytecode to be expanded to a constant");
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushTemporaryVariable: */
				/* begin internalPush: */
				object = longAt((localHomeContext + (BASE_HEADER_SIZE)) + (((29 & 15) + TempFrameStart) << (SHIFT_FOR_WORD)));
				longAtPointerput((localSP += BYTES_PER_WORD), object);
			}
;
			break;
		case 30:
			/* pushTemporaryVariableBytecode */
			{
				sqInt object;
				flag("requires currentBytecode to be expanded to a constant");
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushTemporaryVariable: */
				/* begin internalPush: */
				object = longAt((localHomeContext + (BASE_HEADER_SIZE)) + (((30 & 15) + TempFrameStart) << (SHIFT_FOR_WORD)));
				longAtPointerput((localSP += BYTES_PER_WORD), object);
			}
;
			break;
		case 31:
			/* pushTemporaryVariableBytecode */
			{
				sqInt object;
				flag("requires currentBytecode to be expanded to a constant");
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushTemporaryVariable: */
				/* begin internalPush: */
				object = longAt((localHomeContext + (BASE_HEADER_SIZE)) + (((31 & 15) + TempFrameStart) << (SHIFT_FOR_WORD)));
				longAtPointerput((localSP += BYTES_PER_WORD), object);
			}
;
			break;
		case 32:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;
				flag("requires currentBytecode to be expanded to a constant");
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				object = longAt((method + (BASE_HEADER_SIZE)) + (((32 & 31) + LiteralStart) << (SHIFT_FOR_WORD)));
				longAtPointerput((localSP += BYTES_PER_WORD), object);
			}
;
			break;
		case 33:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;
				flag("requires currentBytecode to be expanded to a constant");
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				object = longAt((method + (BASE_HEADER_SIZE)) + (((33 & 31) + LiteralStart) << (SHIFT_FOR_WORD)));
				longAtPointerput((localSP += BYTES_PER_WORD), object);
			}
;
			break;
		case 34:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;
				flag("requires currentBytecode to be expanded to a constant");
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				object = longAt((method + (BASE_HEADER_SIZE)) + (((34 & 31) + LiteralStart) << (SHIFT_FOR_WORD)));
				longAtPointerput((localSP += BYTES_PER_WORD), object);
			}
;
			break;
		case 35:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;
				flag("requires currentBytecode to be expanded to a constant");
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				object = longAt((method + (BASE_HEADER_SIZE)) + (((35 & 31) + LiteralStart) << (SHIFT_FOR_WORD)));
				longAtPointerput((localSP += BYTES_PER_WORD), object);
			}
;
			break;
		case 36:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;
				flag("requires currentBytecode to be expanded to a constant");
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				object = longAt((method + (BASE_HEADER_SIZE)) + (((36 & 31) + LiteralStart) << (SHIFT_FOR_WORD)));
				longAtPointerput((localSP += BYTES_PER_WORD), object);
			}
;
			break;
		case 37:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;
				flag("requires currentBytecode to be expanded to a constant");
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				object = longAt((method + (BASE_HEADER_SIZE)) + (((37 & 31) + LiteralStart) << (SHIFT_FOR_WORD)));
				longAtPointerput((localSP += BYTES_PER_WORD), object);
			}
;
			break;
		case 38:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;
				flag("requires currentBytecode to be expanded to a constant");
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				object = longAt((method + (BASE_HEADER_SIZE)) + (((38 & 31) + LiteralStart) << (SHIFT_FOR_WORD)));
				longAtPointerput((localSP += BYTES_PER_WORD), object);
			}
;
			break;
		case 39:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;
				flag("requires currentBytecode to be expanded to a constant");
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				object = longAt((method + (BASE_HEADER_SIZE)) + (((39 & 31) + LiteralStart) << (SHIFT_FOR_WORD)));
				longAtPointerput((localSP += BYTES_PER_WORD), object);
			}
;
			break;
		case 40:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;
				flag("requires currentBytecode to be expanded to a constant");
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				object = longAt((method + (BASE_HEADER_SIZE)) + (((40 & 31) + LiteralStart) << (SHIFT_FOR_WORD)));
				longAtPointerput((localSP += BYTES_PER_WORD), object);
			}
;
			break;
		case 41:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;
				flag("requires currentBytecode to be expanded to a constant");
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				object = longAt((method + (BASE_HEADER_SIZE)) + (((41 & 31) + LiteralStart) << (SHIFT_FOR_WORD)));
				longAtPointerput((localSP += BYTES_PER_WORD), object);
			}
;
			break;
		case 42:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;
				flag("requires currentBytecode to be expanded to a constant");
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				object = longAt((method + (BASE_HEADER_SIZE)) + (((42 & 31) + LiteralStart) << (SHIFT_FOR_WORD)));
				longAtPointerput((localSP += BYTES_PER_WORD), object);
			}
;
			break;
		case 43:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;
				flag("requires currentBytecode to be expanded to a constant");
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				object = longAt((method + (BASE_HEADER_SIZE)) + (((43 & 31) + LiteralStart) << (SHIFT_FOR_WORD)));
				longAtPointerput((localSP += BYTES_PER_WORD), object);
			}
;
			break;
		case 44:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;
				flag("requires currentBytecode to be expanded to a constant");
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				object = longAt((method + (BASE_HEADER_SIZE)) + (((44 & 31) + LiteralStart) << (SHIFT_FOR_WORD)));
				longAtPointerput((localSP += BYTES_PER_WORD), object);
			}
;
			break;
		case 45:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;
				flag("requires currentBytecode to be expanded to a constant");
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				object = longAt((method + (BASE_HEADER_SIZE)) + (((45 & 31) + LiteralStart) << (SHIFT_FOR_WORD)));
				longAtPointerput((localSP += BYTES_PER_WORD), object);
			}
;
			break;
		case 46:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;
				flag("requires currentBytecode to be expanded to a constant");
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				object = longAt((method + (BASE_HEADER_SIZE)) + (((46 & 31) + LiteralStart) << (SHIFT_FOR_WORD)));
				longAtPointerput((localSP += BYTES_PER_WORD), object);
			}
;
			break;
		case 47:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;
				flag("requires currentBytecode to be expanded to a constant");
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				object = longAt((method + (BASE_HEADER_SIZE)) + (((47 & 31) + LiteralStart) << (SHIFT_FOR_WORD)));
				longAtPointerput((localSP += BYTES_PER_WORD), object);
			}
;
			break;
		case 48:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;
				flag("requires currentBytecode to be expanded to a constant");
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				object = longAt((method + (BASE_HEADER_SIZE)) + (((48 & 31) + LiteralStart) << (SHIFT_FOR_WORD)));
				longAtPointerput((localSP += BYTES_PER_WORD), object);
			}
;
			break;
		case 49:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;
				flag("requires currentBytecode to be expanded to a constant");
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				object = longAt((method + (BASE_HEADER_SIZE)) + (((49 & 31) + LiteralStart) << (SHIFT_FOR_WORD)));
				longAtPointerput((localSP += BYTES_PER_WORD), object);
			}
;
			break;
		case 50:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;
				flag("requires currentBytecode to be expanded to a constant");
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				object = longAt((method + (BASE_HEADER_SIZE)) + (((50 & 31) + LiteralStart) << (SHIFT_FOR_WORD)));
				longAtPointerput((localSP += BYTES_PER_WORD), object);
			}
;
			break;
		case 51:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;
				flag("requires currentBytecode to be expanded to a constant");
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				object = longAt((method + (BASE_HEADER_SIZE)) + (((51 & 31) + LiteralStart) << (SHIFT_FOR_WORD)));
				longAtPointerput((localSP += BYTES_PER_WORD), object);
			}
;
			break;
		case 52:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;
				flag("requires currentBytecode to be expanded to a constant");
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				object = longAt((method + (BASE_HEADER_SIZE)) + (((52 & 31) + LiteralStart) << (SHIFT_FOR_WORD)));
				longAtPointerput((localSP += BYTES_PER_WORD), object);
			}
;
			break;
		case 53:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;
				flag("requires currentBytecode to be expanded to a constant");
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				object = longAt((method + (BASE_HEADER_SIZE)) + (((53 & 31) + LiteralStart) << (SHIFT_FOR_WORD)));
				longAtPointerput((localSP += BYTES_PER_WORD), object);
			}
;
			break;
		case 54:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;
				flag("requires currentBytecode to be expanded to a constant");
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				object = longAt((method + (BASE_HEADER_SIZE)) + (((54 & 31) + LiteralStart) << (SHIFT_FOR_WORD)));
				longAtPointerput((localSP += BYTES_PER_WORD), object);
			}
;
			break;
		case 55:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;
				flag("requires currentBytecode to be expanded to a constant");
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				object = longAt((method + (BASE_HEADER_SIZE)) + (((55 & 31) + LiteralStart) << (SHIFT_FOR_WORD)));
				longAtPointerput((localSP += BYTES_PER_WORD), object);
			}
;
			break;
		case 56:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;
				flag("requires currentBytecode to be expanded to a constant");
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				object = longAt((method + (BASE_HEADER_SIZE)) + (((56 & 31) + LiteralStart) << (SHIFT_FOR_WORD)));
				longAtPointerput((localSP += BYTES_PER_WORD), object);
			}
;
			break;
		case 57:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;
				flag("requires currentBytecode to be expanded to a constant");
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				object = longAt((method + (BASE_HEADER_SIZE)) + (((57 & 31) + LiteralStart) << (SHIFT_FOR_WORD)));
				longAtPointerput((localSP += BYTES_PER_WORD), object);
			}
;
			break;
		case 58:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;
				flag("requires currentBytecode to be expanded to a constant");
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				object = longAt((method + (BASE_HEADER_SIZE)) + (((58 & 31) + LiteralStart) << (SHIFT_FOR_WORD)));
				longAtPointerput((localSP += BYTES_PER_WORD), object);
			}
;
			break;
		case 59:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;
				flag("requires currentBytecode to be expanded to a constant");
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				object = longAt((method + (BASE_HEADER_SIZE)) + (((59 & 31) + LiteralStart) << (SHIFT_FOR_WORD)));
				longAtPointerput((localSP += BYTES_PER_WORD), object);
			}
;
			break;
		case 60:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;
				flag("requires currentBytecode to be expanded to a constant");
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				object = longAt((method + (BASE_HEADER_SIZE)) + (((60 & 31) + LiteralStart) << (SHIFT_FOR_WORD)));
				longAtPointerput((localSP += BYTES_PER_WORD), object);
			}
;
			break;
		case 61:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;
				flag("requires currentBytecode to be expanded to a constant");
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				object = longAt((method + (BASE_HEADER_SIZE)) + (((61 & 31) + LiteralStart) << (SHIFT_FOR_WORD)));
				longAtPointerput((localSP += BYTES_PER_WORD), object);
			}
;
			break;
		case 62:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;
				flag("requires currentBytecode to be expanded to a constant");
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				object = longAt((method + (BASE_HEADER_SIZE)) + (((62 & 31) + LiteralStart) << (SHIFT_FOR_WORD)));
				longAtPointerput((localSP += BYTES_PER_WORD), object);
			}
;
			break;
		case 63:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;
				flag("requires currentBytecode to be expanded to a constant");
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				object = longAt((method + (BASE_HEADER_SIZE)) + (((63 & 31) + LiteralStart) << (SHIFT_FOR_WORD)));
				longAtPointerput((localSP += BYTES_PER_WORD), object);
			}
;
			break;
		case 64:
			/* pushLiteralVariableBytecode */
			{
				sqInt object;
				sqInt oop;
				flag("requires currentBytecode to be expanded to a constant");
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralVariable: */
				/* begin internalPush: */
				/* begin fetchPointer:ofObject: */
				oop = longAt((method + (BASE_HEADER_SIZE)) + (((64 & 31) + LiteralStart) << (SHIFT_FOR_WORD)));
				object = longAt((oop + (BASE_HEADER_SIZE)) + (ValueIndex << (SHIFT_FOR_WORD)));
				longAtPointerput((localSP += BYTES_PER_WORD), object);
			}
;
			break;
		case 65:
			/* pushLiteralVariableBytecode */
			{
				sqInt object;
				sqInt oop;
				flag("requires currentBytecode to be expanded to a constant");
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralVariable: */
				/* begin internalPush: */
				/* begin fetchPointer:ofObject: */
				oop = longAt((method + (BASE_HEADER_SIZE)) + (((65 & 31) + LiteralStart) << (SHIFT_FOR_WORD)));
				object = longAt((oop + (BASE_HEADER_SIZE)) + (ValueIndex << (SHIFT_FOR_WORD)));
				longAtPointerput((localSP += BYTES_PER_WORD), object);
			}
;
			break;
		case 66:
			/* pushLiteralVariableBytecode */
			{
				sqInt object;
				sqInt oop;
				flag("requires currentBytecode to be expanded to a constant");
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralVariable: */
				/* begin internalPush: */
				/* begin fetchPointer:ofObject: */
				oop = longAt((method + (BASE_HEADER_SIZE)) + (((66 & 31) + LiteralStart) << (SHIFT_FOR_WORD)));
				object = longAt((oop + (BASE_HEADER_SIZE)) + (ValueIndex << (SHIFT_FOR_WORD)));
				longAtPointerput((localSP += BYTES_PER_WORD), object);
			}
;
			break;
		case 67:
			/* pushLiteralVariableBytecode */
			{
				sqInt object;
				sqInt oop;
				flag("requires currentBytecode to be expanded to a constant");
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralVariable: */
				/* begin internalPush: */
				/* begin fetchPointer:ofObject: */
				oop = longAt((method + (BASE_HEADER_SIZE)) + (((67 & 31) + LiteralStart) << (SHIFT_FOR_WORD)));
				object = longAt((oop + (BASE_HEADER_SIZE)) + (ValueIndex << (SHIFT_FOR_WORD)));
				longAtPointerput((localSP += BYTES_PER_WORD), object);
			}
;
			break;
		case 68:
			/* pushLiteralVariableBytecode */
			{
				sqInt object;
				sqInt oop;
				flag("requires currentBytecode to be expanded to a constant");
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralVariable: */
				/* begin internalPush: */
				/* begin fetchPointer:ofObject: */
				oop = longAt((method + (BASE_HEADER_SIZE)) + (((68 & 31) + LiteralStart) << (SHIFT_FOR_WORD)));
				object = longAt((oop + (BASE_HEADER_SIZE)) + (ValueIndex << (SHIFT_FOR_WORD)));
				longAtPointerput((localSP += BYTES_PER_WORD), object);
			}
;
			break;
		case 69:
			/* pushLiteralVariableBytecode */
			{
				sqInt object;
				sqInt oop;
				flag("requires currentBytecode to be expanded to a constant");
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralVariable: */
				/* begin internalPush: */
				/* begin fetchPointer:ofObject: */
				oop = longAt((method + (BASE_HEADER_SIZE)) + (((69 & 31) + LiteralStart) << (SHIFT_FOR_WORD)));
				object = longAt((oop + (BASE_HEADER_SIZE)) + (ValueIndex << (SHIFT_FOR_WORD)));
				longAtPointerput((localSP += BYTES_PER_WORD), object);
			}
;
			break;
		case 70:
			/* pushLiteralVariableBytecode */
			{
				sqInt object;
				sqInt oop;
				flag("requires currentBytecode to be expanded to a constant");
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralVariable: */
				/* begin internalPush: */
				/* begin fetchPointer:ofObject: */
				oop = longAt((method + (BASE_HEADER_SIZE)) + (((70 & 31) + LiteralStart) << (SHIFT_FOR_WORD)));
				object = longAt((oop + (BASE_HEADER_SIZE)) + (ValueIndex << (SHIFT_FOR_WORD)));
				longAtPointerput((localSP += BYTES_PER_WORD), object);
			}
;
			break;
		case 71:
			/* pushLiteralVariableBytecode */
			{
				sqInt object;
				sqInt oop;
				flag("requires currentBytecode to be expanded to a constant");
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralVariable: */
				/* begin internalPush: */
				/* begin fetchPointer:ofObject: */
				oop = longAt((method + (BASE_HEADER_SIZE)) + (((71 & 31) + LiteralStart) << (SHIFT_FOR_WORD)));
				object = longAt((oop + (BASE_HEADER_SIZE)) + (ValueIndex << (SHIFT_FOR_WORD)));
				longAtPointerput((localSP += BYTES_PER_WORD), object);
			}
;
			break;
		case 72:
			/* pushLiteralVariableBytecode */
			{
				sqInt object;
				sqInt oop;
				flag("requires currentBytecode to be expanded to a constant");
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralVariable: */
				/* begin internalPush: */
				/* begin fetchPointer:ofObject: */
				oop = longAt((method + (BASE_HEADER_SIZE)) + (((72 & 31) + LiteralStart) << (SHIFT_FOR_WORD)));
				object = longAt((oop + (BASE_HEADER_SIZE)) + (ValueIndex << (SHIFT_FOR_WORD)));
				longAtPointerput((localSP += BYTES_PER_WORD), object);
			}
;
			break;
		case 73:
			/* pushLiteralVariableBytecode */
			{
				sqInt object;
				sqInt oop;
				flag("requires currentBytecode to be expanded to a constant");
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralVariable: */
				/* begin internalPush: */
				/* begin fetchPointer:ofObject: */
				oop = longAt((method + (BASE_HEADER_SIZE)) + (((73 & 31) + LiteralStart) << (SHIFT_FOR_WORD)));
				object = longAt((oop + (BASE_HEADER_SIZE)) + (ValueIndex << (SHIFT_FOR_WORD)));
				longAtPointerput((localSP += BYTES_PER_WORD), object);
			}
;
			break;
		case 74:
			/* pushLiteralVariableBytecode */
			{
				sqInt object;
				sqInt oop;
				flag("requires currentBytecode to be expanded to a constant");
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralVariable: */
				/* begin internalPush: */
				/* begin fetchPointer:ofObject: */
				oop = longAt((method + (BASE_HEADER_SIZE)) + (((74 & 31) + LiteralStart) << (SHIFT_FOR_WORD)));
				object = longAt((oop + (BASE_HEADER_SIZE)) + (ValueIndex << (SHIFT_FOR_WORD)));
				longAtPointerput((localSP += BYTES_PER_WORD), object);
			}
;
			break;
		case 75:
			/* pushLiteralVariableBytecode */
			{
				sqInt object;
				sqInt oop;
				flag("requires currentBytecode to be expanded to a constant");
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralVariable: */
				/* begin internalPush: */
				/* begin fetchPointer:ofObject: */
				oop = longAt((method + (BASE_HEADER_SIZE)) + (((75 & 31) + LiteralStart) << (SHIFT_FOR_WORD)));
				object = longAt((oop + (BASE_HEADER_SIZE)) + (ValueIndex << (SHIFT_FOR_WORD)));
				longAtPointerput((localSP += BYTES_PER_WORD), object);
			}
;
			break;
		case 76:
			/* pushLiteralVariableBytecode */
			{
				sqInt object;
				sqInt oop;
				flag("requires currentBytecode to be expanded to a constant");
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralVariable: */
				/* begin internalPush: */
				/* begin fetchPointer:ofObject: */
				oop = longAt((method + (BASE_HEADER_SIZE)) + (((76 & 31) + LiteralStart) << (SHIFT_FOR_WORD)));
				object = longAt((oop + (BASE_HEADER_SIZE)) + (ValueIndex << (SHIFT_FOR_WORD)));
				longAtPointerput((localSP += BYTES_PER_WORD), object);
			}
;
			break;
		case 77:
			/* pushLiteralVariableBytecode */
			{
				sqInt object;
				sqInt oop;
				flag("requires currentBytecode to be expanded to a constant");
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralVariable: */
				/* begin internalPush: */
				/* begin fetchPointer:ofObject: */
				oop = longAt((method + (BASE_HEADER_SIZE)) + (((77 & 31) + LiteralStart) << (SHIFT_FOR_WORD)));
				object = longAt((oop + (BASE_HEADER_SIZE)) + (ValueIndex << (SHIFT_FOR_WORD)));
				longAtPointerput((localSP += BYTES_PER_WORD), object);
			}
;
			break;
		case 78:
			/* pushLiteralVariableBytecode */
			{
				sqInt object;
				sqInt oop;
				flag("requires currentBytecode to be expanded to a constant");
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralVariable: */
				/* begin internalPush: */
				/* begin fetchPointer:ofObject: */
				oop = longAt((method + (BASE_HEADER_SIZE)) + (((78 & 31) + LiteralStart) << (SHIFT_FOR_WORD)));
				object = longAt((oop + (BASE_HEADER_SIZE)) + (ValueIndex << (SHIFT_FOR_WORD)));
				longAtPointerput((localSP += BYTES_PER_WORD), object);
			}
;
			break;
		case 79:
			/* pushLiteralVariableBytecode */
			{
				sqInt object;
				sqInt oop;
				flag("requires currentBytecode to be expanded to a constant");
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralVariable: */
				/* begin internalPush: */
				/* begin fetchPointer:ofObject: */
				oop = longAt((method + (BASE_HEADER_SIZE)) + (((79 & 31) + LiteralStart) << (SHIFT_FOR_WORD)));
				object = longAt((oop + (BASE_HEADER_SIZE)) + (ValueIndex << (SHIFT_FOR_WORD)));
				longAtPointerput((localSP += BYTES_PER_WORD), object);
			}
;
			break;
		case 80:
			/* pushLiteralVariableBytecode */
			{
				sqInt object;
				sqInt oop;
				flag("requires currentBytecode to be expanded to a constant");
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralVariable: */
				/* begin internalPush: */
				/* begin fetchPointer:ofObject: */
				oop = longAt((method + (BASE_HEADER_SIZE)) + (((80 & 31) + LiteralStart) << (SHIFT_FOR_WORD)));
				object = longAt((oop + (BASE_HEADER_SIZE)) + (ValueIndex << (SHIFT_FOR_WORD)));
				longAtPointerput((localSP += BYTES_PER_WORD), object);
			}
;
			break;
		case 81:
			/* pushLiteralVariableBytecode */
			{
				sqInt object;
				sqInt oop;
				flag("requires currentBytecode to be expanded to a constant");
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralVariable: */
				/* begin internalPush: */
				/* begin fetchPointer:ofObject: */
				oop = longAt((method + (BASE_HEADER_SIZE)) + (((81 & 31) + LiteralStart) << (SHIFT_FOR_WORD)));
				object = longAt((oop + (BASE_HEADER_SIZE)) + (ValueIndex << (SHIFT_FOR_WORD)));
				longAtPointerput((localSP += BYTES_PER_WORD), object);
			}
;
			break;
		case 82:
			/* pushLiteralVariableBytecode */
			{
				sqInt object;
				sqInt oop;
				flag("requires currentBytecode to be expanded to a constant");
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralVariable: */
				/* begin internalPush: */
				/* begin fetchPointer:ofObject: */
				oop = longAt((method + (BASE_HEADER_SIZE)) + (((82 & 31) + LiteralStart) << (SHIFT_FOR_WORD)));
				object = longAt((oop + (BASE_HEADER_SIZE)) + (ValueIndex << (SHIFT_FOR_WORD)));
				longAtPointerput((localSP += BYTES_PER_WORD), object);
			}
;
			break;
		case 83:
			/* pushLiteralVariableBytecode */
			{
				sqInt object;
				sqInt oop;
				flag("requires currentBytecode to be expanded to a constant");
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralVariable: */
				/* begin internalPush: */
				/* begin fetchPointer:ofObject: */
				oop = longAt((method + (BASE_HEADER_SIZE)) + (((83 & 31) + LiteralStart) << (SHIFT_FOR_WORD)));
				object = longAt((oop + (BASE_HEADER_SIZE)) + (ValueIndex << (SHIFT_FOR_WORD)));
				longAtPointerput((localSP += BYTES_PER_WORD), object);
			}
;
			break;
		case 84:
			/* pushLiteralVariableBytecode */
			{
				sqInt object;
				sqInt oop;
				flag("requires currentBytecode to be expanded to a constant");
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralVariable: */
				/* begin internalPush: */
				/* begin fetchPointer:ofObject: */
				oop = longAt((method + (BASE_HEADER_SIZE)) + (((84 & 31) + LiteralStart) << (SHIFT_FOR_WORD)));
				object = longAt((oop + (BASE_HEADER_SIZE)) + (ValueIndex << (SHIFT_FOR_WORD)));
				longAtPointerput((localSP += BYTES_PER_WORD), object);
			}
;
			break;
		case 85:
			/* pushLiteralVariableBytecode */
			{
				sqInt object;
				sqInt oop;
				flag("requires currentBytecode to be expanded to a constant");
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralVariable: */
				/* begin internalPush: */
				/* begin fetchPointer:ofObject: */
				oop = longAt((method + (BASE_HEADER_SIZE)) + (((85 & 31) + LiteralStart) << (SHIFT_FOR_WORD)));
				object = longAt((oop + (BASE_HEADER_SIZE)) + (ValueIndex << (SHIFT_FOR_WORD)));
				longAtPointerput((localSP += BYTES_PER_WORD), object);
			}
;
			break;
		case 86:
			/* pushLiteralVariableBytecode */
			{
				sqInt object;
				sqInt oop;
				flag("requires currentBytecode to be expanded to a constant");
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralVariable: */
				/* begin internalPush: */
				/* begin fetchPointer:ofObject: */
				oop = longAt((method + (BASE_HEADER_SIZE)) + (((86 & 31) + LiteralStart) << (SHIFT_FOR_WORD)));
				object = longAt((oop + (BASE_HEADER_SIZE)) + (ValueIndex << (SHIFT_FOR_WORD)));
				longAtPointerput((localSP += BYTES_PER_WORD), object);
			}
;
			break;
		case 87:
			/* pushLiteralVariableBytecode */
			{
				sqInt object;
				sqInt oop;
				flag("requires currentBytecode to be expanded to a constant");
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralVariable: */
				/* begin internalPush: */
				/* begin fetchPointer:ofObject: */
				oop = longAt((method + (BASE_HEADER_SIZE)) + (((87 & 31) + LiteralStart) << (SHIFT_FOR_WORD)));
				object = longAt((oop + (BASE_HEADER_SIZE)) + (ValueIndex << (SHIFT_FOR_WORD)));
				longAtPointerput((localSP += BYTES_PER_WORD), object);
			}
;
			break;
		case 88:
			/* pushLiteralVariableBytecode */
			{
				sqInt object;
				sqInt oop;
				flag("requires currentBytecode to be expanded to a constant");
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralVariable: */
				/* begin internalPush: */
				/* begin fetchPointer:ofObject: */
				oop = longAt((method + (BASE_HEADER_SIZE)) + (((88 & 31) + LiteralStart) << (SHIFT_FOR_WORD)));
				object = longAt((oop + (BASE_HEADER_SIZE)) + (ValueIndex << (SHIFT_FOR_WORD)));
				longAtPointerput((localSP += BYTES_PER_WORD), object);
			}
;
			break;
		case 89:
			/* pushLiteralVariableBytecode */
			{
				sqInt object;
				sqInt oop;
				flag("requires currentBytecode to be expanded to a constant");
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralVariable: */
				/* begin internalPush: */
				/* begin fetchPointer:ofObject: */
				oop = longAt((method + (BASE_HEADER_SIZE)) + (((89 & 31) + LiteralStart) << (SHIFT_FOR_WORD)));
				object = longAt((oop + (BASE_HEADER_SIZE)) + (ValueIndex << (SHIFT_FOR_WORD)));
				longAtPointerput((localSP += BYTES_PER_WORD), object);
			}
;
			break;
		case 90:
			/* pushLiteralVariableBytecode */
			{
				sqInt object;
				sqInt oop;
				flag("requires currentBytecode to be expanded to a constant");
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralVariable: */
				/* begin internalPush: */
				/* begin fetchPointer:ofObject: */
				oop = longAt((method + (BASE_HEADER_SIZE)) + (((90 & 31) + LiteralStart) << (SHIFT_FOR_WORD)));
				object = longAt((oop + (BASE_HEADER_SIZE)) + (ValueIndex << (SHIFT_FOR_WORD)));
				longAtPointerput((localSP += BYTES_PER_WORD), object);
			}
;
			break;
		case 91:
			/* pushLiteralVariableBytecode */
			{
				sqInt object;
				sqInt oop;
				flag("requires currentBytecode to be expanded to a constant");
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralVariable: */
				/* begin internalPush: */
				/* begin fetchPointer:ofObject: */
				oop = longAt((method + (BASE_HEADER_SIZE)) + (((91 & 31) + LiteralStart) << (SHIFT_FOR_WORD)));
				object = longAt((oop + (BASE_HEADER_SIZE)) + (ValueIndex << (SHIFT_FOR_WORD)));
				longAtPointerput((localSP += BYTES_PER_WORD), object);
			}
;
			break;
		case 92:
			/* pushLiteralVariableBytecode */
			{
				sqInt object;
				sqInt oop;
				flag("requires currentBytecode to be expanded to a constant");
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralVariable: */
				/* begin internalPush: */
				/* begin fetchPointer:ofObject: */
				oop = longAt((method + (BASE_HEADER_SIZE)) + (((92 & 31) + LiteralStart) << (SHIFT_FOR_WORD)));
				object = longAt((oop + (BASE_HEADER_SIZE)) + (ValueIndex << (SHIFT_FOR_WORD)));
				longAtPointerput((localSP += BYTES_PER_WORD), object);
			}
;
			break;
		case 93:
			/* pushLiteralVariableBytecode */
			{
				sqInt object;
				sqInt oop;
				flag("requires currentBytecode to be expanded to a constant");
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralVariable: */
				/* begin internalPush: */
				/* begin fetchPointer:ofObject: */
				oop = longAt((method + (BASE_HEADER_SIZE)) + (((93 & 31) + LiteralStart) << (SHIFT_FOR_WORD)));
				object = longAt((oop + (BASE_HEADER_SIZE)) + (ValueIndex << (SHIFT_FOR_WORD)));
				longAtPointerput((localSP += BYTES_PER_WORD), object);
			}
;
			break;
		case 94:
			/* pushLiteralVariableBytecode */
			{
				sqInt object;
				sqInt oop;
				flag("requires currentBytecode to be expanded to a constant");
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralVariable: */
				/* begin internalPush: */
				/* begin fetchPointer:ofObject: */
				oop = longAt((method + (BASE_HEADER_SIZE)) + (((94 & 31) + LiteralStart) << (SHIFT_FOR_WORD)));
				object = longAt((oop + (BASE_HEADER_SIZE)) + (ValueIndex << (SHIFT_FOR_WORD)));
				longAtPointerput((localSP += BYTES_PER_WORD), object);
			}
;
			break;
		case 95:
			/* pushLiteralVariableBytecode */
			{
				sqInt object;
				sqInt oop;
				flag("requires currentBytecode to be expanded to a constant");
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralVariable: */
				/* begin internalPush: */
				/* begin fetchPointer:ofObject: */
				oop = longAt((method + (BASE_HEADER_SIZE)) + (((95 & 31) + LiteralStart) << (SHIFT_FOR_WORD)));
				object = longAt((oop + (BASE_HEADER_SIZE)) + (ValueIndex << (SHIFT_FOR_WORD)));
				longAtPointerput((localSP += BYTES_PER_WORD), object);
			}
;
			break;
		case 96:
			/* storeAndPopReceiverVariableBytecode */
			{
				sqInt rcvr;
				sqInt top;
				flag("requires currentBytecode to be expanded to a constant");
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				rcvr = receiver;
				top = longAtPointer(localSP);
				if ((((usqInt) rcvr)) < (((usqInt) youngStart))) {
					possibleRootStoreIntovalue(rcvr, top);
				}
				longAtput((rcvr + (BASE_HEADER_SIZE)) + ((96 & 7) << (SHIFT_FOR_WORD)), top);
				/* begin internalPop: */
				localSP -= 1 * (BYTES_PER_WORD);
			}
;
			break;
		case 97:
			/* storeAndPopReceiverVariableBytecode */
			{
				sqInt rcvr;
				sqInt top;
				flag("requires currentBytecode to be expanded to a constant");
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				rcvr = receiver;
				top = longAtPointer(localSP);
				if ((((usqInt) rcvr)) < (((usqInt) youngStart))) {
					possibleRootStoreIntovalue(rcvr, top);
				}
				longAtput((rcvr + (BASE_HEADER_SIZE)) + ((97 & 7) << (SHIFT_FOR_WORD)), top);
				/* begin internalPop: */
				localSP -= 1 * (BYTES_PER_WORD);
			}
;
			break;
		case 98:
			/* storeAndPopReceiverVariableBytecode */
			{
				sqInt rcvr;
				sqInt top;
				flag("requires currentBytecode to be expanded to a constant");
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				rcvr = receiver;
				top = longAtPointer(localSP);
				if ((((usqInt) rcvr)) < (((usqInt) youngStart))) {
					possibleRootStoreIntovalue(rcvr, top);
				}
				longAtput((rcvr + (BASE_HEADER_SIZE)) + ((98 & 7) << (SHIFT_FOR_WORD)), top);
				/* begin internalPop: */
				localSP -= 1 * (BYTES_PER_WORD);
			}
;
			break;
		case 99:
			/* storeAndPopReceiverVariableBytecode */
			{
				sqInt rcvr;
				sqInt top;
				flag("requires currentBytecode to be expanded to a constant");
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				rcvr = receiver;
				top = longAtPointer(localSP);
				if ((((usqInt) rcvr)) < (((usqInt) youngStart))) {
					possibleRootStoreIntovalue(rcvr, top);
				}
				longAtput((rcvr + (BASE_HEADER_SIZE)) + ((99 & 7) << (SHIFT_FOR_WORD)), top);
				/* begin internalPop: */
				localSP -= 1 * (BYTES_PER_WORD);
			}
;
			break;
		case 100:
			/* storeAndPopReceiverVariableBytecode */
			{
				sqInt rcvr;
				sqInt top;
				flag("requires currentBytecode to be expanded to a constant");
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				rcvr = receiver;
				top = longAtPointer(localSP);
				if ((((usqInt) rcvr)) < (((usqInt) youngStart))) {
					possibleRootStoreIntovalue(rcvr, top);
				}
				longAtput((rcvr + (BASE_HEADER_SIZE)) + ((100 & 7) << (SHIFT_FOR_WORD)), top);
				/* begin internalPop: */
				localSP -= 1 * (BYTES_PER_WORD);
			}
;
			break;
		case 101:
			/* storeAndPopReceiverVariableBytecode */
			{
				sqInt rcvr;
				sqInt top;
				flag("requires currentBytecode to be expanded to a constant");
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				rcvr = receiver;
				top = longAtPointer(localSP);
				if ((((usqInt) rcvr)) < (((usqInt) youngStart))) {
					possibleRootStoreIntovalue(rcvr, top);
				}
				longAtput((rcvr + (BASE_HEADER_SIZE)) + ((101 & 7) << (SHIFT_FOR_WORD)), top);
				/* begin internalPop: */
				localSP -= 1 * (BYTES_PER_WORD);
			}
;
			break;
		case 102:
			/* storeAndPopReceiverVariableBytecode */
			{
				sqInt rcvr;
				sqInt top;
				flag("requires currentBytecode to be expanded to a constant");
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				rcvr = receiver;
				top = longAtPointer(localSP);
				if ((((usqInt) rcvr)) < (((usqInt) youngStart))) {
					possibleRootStoreIntovalue(rcvr, top);
				}
				longAtput((rcvr + (BASE_HEADER_SIZE)) + ((102 & 7) << (SHIFT_FOR_WORD)), top);
				/* begin internalPop: */
				localSP -= 1 * (BYTES_PER_WORD);
			}
;
			break;
		case 103:
			/* storeAndPopReceiverVariableBytecode */
			{
				sqInt rcvr;
				sqInt top;
				flag("requires currentBytecode to be expanded to a constant");
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				rcvr = receiver;
				top = longAtPointer(localSP);
				if ((((usqInt) rcvr)) < (((usqInt) youngStart))) {
					possibleRootStoreIntovalue(rcvr, top);
				}
				longAtput((rcvr + (BASE_HEADER_SIZE)) + ((103 & 7) << (SHIFT_FOR_WORD)), top);
				/* begin internalPop: */
				localSP -= 1 * (BYTES_PER_WORD);
			}
;
			break;
		case 104:
			/* storeAndPopTemporaryVariableBytecode */
			{
				flag("requires currentBytecode to be expanded to a constant");
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				longAtput((localHomeContext + (BASE_HEADER_SIZE)) + (((104 & 7) + TempFrameStart) << (SHIFT_FOR_WORD)), longAtPointer(localSP));
				/* begin internalPop: */
				localSP -= 1 * (BYTES_PER_WORD);
			}
;
			break;
		case 105:
			/* storeAndPopTemporaryVariableBytecode */
			{
				flag("requires currentBytecode to be expanded to a constant");
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				longAtput((localHomeContext + (BASE_HEADER_SIZE)) + (((105 & 7) + TempFrameStart) << (SHIFT_FOR_WORD)), longAtPointer(localSP));
				/* begin internalPop: */
				localSP -= 1 * (BYTES_PER_WORD);
			}
;
			break;
		case 106:
			/* storeAndPopTemporaryVariableBytecode */
			{
				flag("requires currentBytecode to be expanded to a constant");
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				longAtput((localHomeContext + (BASE_HEADER_SIZE)) + (((106 & 7) + TempFrameStart) << (SHIFT_FOR_WORD)), longAtPointer(localSP));
				/* begin internalPop: */
				localSP -= 1 * (BYTES_PER_WORD);
			}
;
			break;
		case 107:
			/* storeAndPopTemporaryVariableBytecode */
			{
				flag("requires currentBytecode to be expanded to a constant");
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				longAtput((localHomeContext + (BASE_HEADER_SIZE)) + (((107 & 7) + TempFrameStart) << (SHIFT_FOR_WORD)), longAtPointer(localSP));
				/* begin internalPop: */
				localSP -= 1 * (BYTES_PER_WORD);
			}
;
			break;
		case 108:
			/* storeAndPopTemporaryVariableBytecode */
			{
				flag("requires currentBytecode to be expanded to a constant");
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				longAtput((localHomeContext + (BASE_HEADER_SIZE)) + (((108 & 7) + TempFrameStart) << (SHIFT_FOR_WORD)), longAtPointer(localSP));
				/* begin internalPop: */
				localSP -= 1 * (BYTES_PER_WORD);
			}
;
			break;
		case 109:
			/* storeAndPopTemporaryVariableBytecode */
			{
				flag("requires currentBytecode to be expanded to a constant");
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				longAtput((localHomeContext + (BASE_HEADER_SIZE)) + (((109 & 7) + TempFrameStart) << (SHIFT_FOR_WORD)), longAtPointer(localSP));
				/* begin internalPop: */
				localSP -= 1 * (BYTES_PER_WORD);
			}
;
			break;
		case 110:
			/* storeAndPopTemporaryVariableBytecode */
			{
				flag("requires currentBytecode to be expanded to a constant");
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				longAtput((localHomeContext + (BASE_HEADER_SIZE)) + (((110 & 7) + TempFrameStart) << (SHIFT_FOR_WORD)), longAtPointer(localSP));
				/* begin internalPop: */
				localSP -= 1 * (BYTES_PER_WORD);
			}
;
			break;
		case 111:
			/* storeAndPopTemporaryVariableBytecode */
			{
				flag("requires currentBytecode to be expanded to a constant");
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				longAtput((localHomeContext + (BASE_HEADER_SIZE)) + (((111 & 7) + TempFrameStart) << (SHIFT_FOR_WORD)), longAtPointer(localSP));
				/* begin internalPop: */
				localSP -= 1 * (BYTES_PER_WORD);
			}
;
			break;
		case 112:
			/* pushReceiverBytecode */
			{
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin internalPush: */
				longAtPointerput((localSP += BYTES_PER_WORD), receiver);
			}
;
			break;
		case 113:
			/* pushConstantTrueBytecode */
			{
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin internalPush: */
				longAtPointerput((localSP += BYTES_PER_WORD), trueObj);
			}
;
			break;
		case 114:
			/* pushConstantFalseBytecode */
			{
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin internalPush: */
				longAtPointerput((localSP += BYTES_PER_WORD), falseObj);
			}
;
			break;
		case 115:
			/* pushConstantNilBytecode */
			{
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin internalPush: */
				longAtPointerput((localSP += BYTES_PER_WORD), nilObj);
			}
;
			break;
		case 116:
			/* pushConstantMinusOneBytecode */
			{
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin internalPush: */
				longAtPointerput((localSP += BYTES_PER_WORD), ConstMinusOne);
			}
;
			break;
		case 117:
			/* pushConstantZeroBytecode */
			{
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin internalPush: */
				longAtPointerput((localSP += BYTES_PER_WORD), ConstZero);
			}
;
			break;
		case 118:
			/* pushConstantOneBytecode */
			{
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin internalPush: */
				longAtPointerput((localSP += BYTES_PER_WORD), ConstOne);
			}
;
			break;
		case 119:
			/* pushConstantTwoBytecode */
			{
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin internalPush: */
				longAtPointerput((localSP += BYTES_PER_WORD), ConstTwo);
			}
;
			break;
		case 120:
			/* returnReceiver */
			{
				sqInt closureOrNil;
				sqInt context;
				/* begin sender */
				context = localHomeContext;
				while (((closureOrNil = longAt((context + (BASE_HEADER_SIZE)) + (ClosureIndex << (SHIFT_FOR_WORD))))) != nilObj) {
					context = longAt((closureOrNil + (BASE_HEADER_SIZE)) + (ClosureOuterContextIndex << (SHIFT_FOR_WORD)));
				}
				localReturnContext = longAt((context + (BASE_HEADER_SIZE)) + (SenderIndex << (SHIFT_FOR_WORD)));
				localReturnValue = receiver;
				/* goto commonReturn */
			}
;
			
		commonReturn:
			/* commonReturn */
			{
				sqInt contextOfCaller;
				sqInt localCntx;
				sqInt localVal;
				sqInt nilOop;
				sqInt thisCntx;
				sqInt unwindMarked;
				sqInt header;
				sqInt meth;
				sqInt pIndex;
				sqInt primBits;
				sqInt header1;
				sqInt tmp;
				nilOop = nilObj;
				thisCntx = activeContext;
				localCntx = localReturnContext;
				localVal = localReturnValue;
				if ((localCntx == nilOop) || ((longAt((localCntx + (BASE_HEADER_SIZE)) + (InstructionPointerIndex << (SHIFT_FOR_WORD)))) == nilOop)) {
					/* begin internalCannotReturn: */
					/* begin internalPush: */
					longAtPointerput((localSP += BYTES_PER_WORD), activeContext);
					/* begin internalPush: */
					longAtPointerput((localSP += BYTES_PER_WORD), localVal);
					messageSelector = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (SelectorCannotReturn << (SHIFT_FOR_WORD)));
					argumentCount = 1;
					goto normalSend;
					goto l41;
				}
				thisCntx = longAt((activeContext + (BASE_HEADER_SIZE)) + (SenderIndex << (SHIFT_FOR_WORD)));
				while (!(thisCntx == localCntx)) {
					if (thisCntx == nilOop) {
						/* begin internalCannotReturn: */
						/* begin internalPush: */
						longAtPointerput((localSP += BYTES_PER_WORD), activeContext);
						/* begin internalPush: */
						longAtPointerput((localSP += BYTES_PER_WORD), localVal);
						messageSelector = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (SelectorCannotReturn << (SHIFT_FOR_WORD)));
						argumentCount = 1;
						goto normalSend;
						goto l41;
					}
					/* begin isUnwindMarked: */
					header = longAt(thisCntx);
					if (!(((((usqInt) header) >> 12) & 31) == 14)) {
						unwindMarked = 0;
						goto l42;
					}
					meth = longAt((thisCntx + (BASE_HEADER_SIZE)) + (MethodIndex << (SHIFT_FOR_WORD)));
					/* begin primitiveIndexOf: */
					primBits = (((usqInt) (longAt((meth + (BASE_HEADER_SIZE)) + (HeaderIndex << (SHIFT_FOR_WORD))))) >> 1) & 268435967;
					pIndex = (primBits & 511) + (((usqInt) primBits) >> 19);
					unwindMarked = pIndex == 198;
				l42:	/* end isUnwindMarked: */;
					if (unwindMarked) {
						/* begin internalAboutToReturn:through: */
						/* begin internalPush: */
						longAtPointerput((localSP += BYTES_PER_WORD), activeContext);
						/* begin internalPush: */
						longAtPointerput((localSP += BYTES_PER_WORD), localVal);
						/* begin internalPush: */
						longAtPointerput((localSP += BYTES_PER_WORD), thisCntx);
						messageSelector = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (SelectorAboutToReturn << (SHIFT_FOR_WORD)));
						argumentCount = 2;
						goto normalSend;
						goto l41;
					}
					thisCntx = longAt((thisCntx + (BASE_HEADER_SIZE)) + (SenderIndex << (SHIFT_FOR_WORD)));
				}
				thisCntx = activeContext;
				while (!(thisCntx == localCntx)) {
					contextOfCaller = longAt((thisCntx + (BASE_HEADER_SIZE)) + (SenderIndex << (SHIFT_FOR_WORD)));
					longAtput((thisCntx + (BASE_HEADER_SIZE)) + (SenderIndex << (SHIFT_FOR_WORD)), nilOop);
					longAtput((thisCntx + (BASE_HEADER_SIZE)) + (InstructionPointerIndex << (SHIFT_FOR_WORD)), nilOop);
					if (reclaimableContextCount > 0) {
						reclaimableContextCount -= 1;
						/* begin recycleContextIfPossible: */
						if ((((usqInt) thisCntx)) >= (((usqInt) youngStart))) {
							header1 = longAt(thisCntx);
							if (((((usqInt) header1) >> 12) & 31) == 14) {
								if ((header1 & (SIZE_MASK)) == (SMALL_CONTEXT_SIZE)) {
									longAtput((thisCntx + (BASE_HEADER_SIZE)) + (0 << (SHIFT_FOR_WORD)), freeContexts);
									freeContexts = thisCntx;
								}
								if ((header1 & (SIZE_MASK)) == (LARGE_CONTEXT_SIZE)) {
									longAtput((thisCntx + (BASE_HEADER_SIZE)) + (0 << (SHIFT_FOR_WORD)), freeLargeContexts);
									freeLargeContexts = thisCntx;
								}
							}
						}
					}
					thisCntx = contextOfCaller;
				}
				activeContext = thisCntx;
				if ((((usqInt) thisCntx)) < (((usqInt) youngStart))) {
					beRootIfOld(thisCntx);
				}
				/* begin internalFetchContextRegisters: */
				tmp = longAt((thisCntx + (BASE_HEADER_SIZE)) + (MethodIndex << (SHIFT_FOR_WORD)));
				if ((tmp & 1)) {
					tmp = longAt((thisCntx + (BASE_HEADER_SIZE)) + (HomeIndex << (SHIFT_FOR_WORD)));
					if ((((usqInt) tmp)) < (((usqInt) youngStart))) {
						beRootIfOld(tmp);
					}
				} else {
					tmp = thisCntx;
				}
				localHomeContext = tmp;
				receiver = longAt((tmp + (BASE_HEADER_SIZE)) + (ReceiverIndex << (SHIFT_FOR_WORD)));
				method = (usqInt)longAt((tmp + (BASE_HEADER_SIZE)) + (MethodIndex << (SHIFT_FOR_WORD)));
				tmp = ((longAt((thisCntx + (BASE_HEADER_SIZE)) + (InstructionPointerIndex << (SHIFT_FOR_WORD)))) >> 1);
				localIP = pointerForOop(((method + tmp) + (BASE_HEADER_SIZE)) - 2);
				tmp = ((longAt((thisCntx + (BASE_HEADER_SIZE)) + (StackPointerIndex << (SHIFT_FOR_WORD)))) >> 1);
				localSP = pointerForOop((thisCntx + (BASE_HEADER_SIZE)) + (((TempFrameStart + tmp) - 1) * (BYTES_PER_WORD)));
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin internalPush: */
				longAtPointerput((localSP += BYTES_PER_WORD), localVal);
			}
;
		l41:	/* end case */;
			break;
		case 121:
			/* returnTrue */
			{
				sqInt closureOrNil;
				sqInt context;
				/* begin sender */
				context = localHomeContext;
				while (((closureOrNil = longAt((context + (BASE_HEADER_SIZE)) + (ClosureIndex << (SHIFT_FOR_WORD))))) != nilObj) {
					context = longAt((closureOrNil + (BASE_HEADER_SIZE)) + (ClosureOuterContextIndex << (SHIFT_FOR_WORD)));
				}
				localReturnContext = longAt((context + (BASE_HEADER_SIZE)) + (SenderIndex << (SHIFT_FOR_WORD)));
				localReturnValue = trueObj;
				goto commonReturn;
			}
;
			break;
		case 122:
			/* returnFalse */
			{
				sqInt closureOrNil;
				sqInt context;
				/* begin sender */
				context = localHomeContext;
				while (((closureOrNil = longAt((context + (BASE_HEADER_SIZE)) + (ClosureIndex << (SHIFT_FOR_WORD))))) != nilObj) {
					context = longAt((closureOrNil + (BASE_HEADER_SIZE)) + (ClosureOuterContextIndex << (SHIFT_FOR_WORD)));
				}
				localReturnContext = longAt((context + (BASE_HEADER_SIZE)) + (SenderIndex << (SHIFT_FOR_WORD)));
				localReturnValue = falseObj;
				goto commonReturn;
			}
;
			break;
		case 123:
			/* returnNil */
			{
				sqInt closureOrNil;
				sqInt context;
				/* begin sender */
				context = localHomeContext;
				while (((closureOrNil = longAt((context + (BASE_HEADER_SIZE)) + (ClosureIndex << (SHIFT_FOR_WORD))))) != nilObj) {
					context = longAt((closureOrNil + (BASE_HEADER_SIZE)) + (ClosureOuterContextIndex << (SHIFT_FOR_WORD)));
				}
				localReturnContext = longAt((context + (BASE_HEADER_SIZE)) + (SenderIndex << (SHIFT_FOR_WORD)));
				localReturnValue = nilObj;
				goto commonReturn;
			}
;
			break;
		case 124:
			/* returnTopFromMethod */
			{
				sqInt closureOrNil;
				sqInt context;
				/* begin sender */
				context = localHomeContext;
				while (((closureOrNil = longAt((context + (BASE_HEADER_SIZE)) + (ClosureIndex << (SHIFT_FOR_WORD))))) != nilObj) {
					context = longAt((closureOrNil + (BASE_HEADER_SIZE)) + (ClosureOuterContextIndex << (SHIFT_FOR_WORD)));
				}
				localReturnContext = longAt((context + (BASE_HEADER_SIZE)) + (SenderIndex << (SHIFT_FOR_WORD)));
				localReturnValue = longAtPointer(localSP);
				goto commonReturn;
			}
;
			break;
		case 125:
			/* returnTopFromBlock */
			{
				localReturnContext = longAt((activeContext + (BASE_HEADER_SIZE)) + (CallerIndex << (SHIFT_FOR_WORD)));
				localReturnValue = longAtPointer(localSP);
				goto commonReturn;
			}
;
			break;
		case 126:
		case 127:
			/* unknownBytecode */
			{
				error("Unknown bytecode");
			}
;
			break;
		case 128:
			/* extendedPushBytecode */
			{
				sqInt descriptor;
				sqInt variableIndex;
				sqInt variableType;
				sqInt object;
				sqInt object1;
				sqInt object2;
				sqInt object3;
				sqInt oop;
				descriptor = byteAtPointer(++localIP);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				variableType = (((usqInt) descriptor) >> 6) & 3;
				variableIndex = descriptor & 63;
				if (variableType == 0) {
					/* begin pushReceiverVariable: */
					/* begin internalPush: */
					object = longAt((receiver + (BASE_HEADER_SIZE)) + (variableIndex << (SHIFT_FOR_WORD)));
					longAtPointerput((localSP += BYTES_PER_WORD), object);
					goto l1;
				}
				if (variableType == 1) {
					/* begin pushTemporaryVariable: */
					/* begin internalPush: */
					object1 = longAt((localHomeContext + (BASE_HEADER_SIZE)) + ((variableIndex + TempFrameStart) << (SHIFT_FOR_WORD)));
					longAtPointerput((localSP += BYTES_PER_WORD), object1);
					goto l1;
				}
				if (variableType == 2) {
					/* begin pushLiteralConstant: */
					/* begin internalPush: */
					object2 = longAt((method + (BASE_HEADER_SIZE)) + ((variableIndex + LiteralStart) << (SHIFT_FOR_WORD)));
					longAtPointerput((localSP += BYTES_PER_WORD), object2);
					goto l1;
				}
				if (variableType == 3) {
					/* begin pushLiteralVariable: */
					/* begin internalPush: */
					/* begin fetchPointer:ofObject: */
					oop = longAt((method + (BASE_HEADER_SIZE)) + ((variableIndex + LiteralStart) << (SHIFT_FOR_WORD)));
					object3 = longAt((oop + (BASE_HEADER_SIZE)) + (ValueIndex << (SHIFT_FOR_WORD)));
					longAtPointerput((localSP += BYTES_PER_WORD), object3);
					goto l1;
				}
			}
;
		l1:	/* end case */;
			break;
		case 129:
			/* extendedStoreBytecode */
			{
				sqInt association;
				sqInt descriptor;
				sqInt variableIndex;
				sqInt variableType;
				descriptor = byteAtPointer(++localIP);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				variableType = (((usqInt) descriptor) >> 6) & 3;
				variableIndex = descriptor & 63;
				if (variableType == 0) {
					/* begin storePointer:ofObject:withValue: */
					if ((((usqInt) receiver)) < (((usqInt) youngStart))) {
						possibleRootStoreIntovalue(receiver, longAtPointer(localSP));
					}
					longAtput((receiver + (BASE_HEADER_SIZE)) + (variableIndex << (SHIFT_FOR_WORD)), longAtPointer(localSP));
					goto l2;
				}
				if (variableType == 1) {
					longAtput((localHomeContext + (BASE_HEADER_SIZE)) + ((variableIndex + TempFrameStart) << (SHIFT_FOR_WORD)), longAtPointer(localSP));
					goto l2;
				}
				if (variableType == 2) {
					error("illegal store");
				}
				if (variableType == 3) {
					association = longAt((method + (BASE_HEADER_SIZE)) + ((variableIndex + LiteralStart) << (SHIFT_FOR_WORD)));
					/* begin storePointer:ofObject:withValue: */
					if ((((usqInt) association)) < (((usqInt) youngStart))) {
						possibleRootStoreIntovalue(association, longAtPointer(localSP));
					}
					longAtput((association + (BASE_HEADER_SIZE)) + (ValueIndex << (SHIFT_FOR_WORD)), longAtPointer(localSP));
					goto l2;
				}
			}
;
		l2:	/* end case */;
			break;
		case 130:
			/* extendedStoreAndPopBytecode */
			{
				sqInt association;
				sqInt descriptor;
				sqInt variableIndex;
				sqInt variableType;
				/* begin extendedStoreBytecode */
				descriptor = byteAtPointer(++localIP);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				variableType = (((usqInt) descriptor) >> 6) & 3;
				variableIndex = descriptor & 63;
				if (variableType == 0) {
					/* begin storePointer:ofObject:withValue: */
					if ((((usqInt) receiver)) < (((usqInt) youngStart))) {
						possibleRootStoreIntovalue(receiver, longAtPointer(localSP));
					}
					longAtput((receiver + (BASE_HEADER_SIZE)) + (variableIndex << (SHIFT_FOR_WORD)), longAtPointer(localSP));
					goto l3;
				}
				if (variableType == 1) {
					longAtput((localHomeContext + (BASE_HEADER_SIZE)) + ((variableIndex + TempFrameStart) << (SHIFT_FOR_WORD)), longAtPointer(localSP));
					goto l3;
				}
				if (variableType == 2) {
					error("illegal store");
				}
				if (variableType == 3) {
					association = longAt((method + (BASE_HEADER_SIZE)) + ((variableIndex + LiteralStart) << (SHIFT_FOR_WORD)));
					/* begin storePointer:ofObject:withValue: */
					if ((((usqInt) association)) < (((usqInt) youngStart))) {
						possibleRootStoreIntovalue(association, longAtPointer(localSP));
					}
					longAtput((association + (BASE_HEADER_SIZE)) + (ValueIndex << (SHIFT_FOR_WORD)), longAtPointer(localSP));
					goto l3;
				}
			l3:	/* end extendedStoreBytecode */;
				/* begin internalPop: */
				localSP -= 1 * (BYTES_PER_WORD);
			}
;
			break;
		case 131:
			/* singleExtendedSendBytecode */
			{
				sqInt descriptor;
				descriptor = byteAtPointer(++localIP);
				messageSelector = longAt((method + (BASE_HEADER_SIZE)) + (((descriptor & 31) + LiteralStart) << (SHIFT_FOR_WORD)));
				argumentCount = ((usqInt) descriptor) >> 5;
				/* goto normalSend */
			}
;
			
		normalSend:
			/* normalSend */
			{
				sqInt rcvr;
				sqInt ccIndex;
				sqInt oop1;
				rcvr = longAtPointer(localSP - (argumentCount * (BYTES_PER_WORD)));
				/* begin fetchClassOf: */
				if ((rcvr & 1)) {
					lkupClass = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassInteger << (SHIFT_FOR_WORD)));
					goto l43;
				}
				ccIndex = (((usqInt) (longAt(rcvr))) >> 12) & 31;
				if (ccIndex == 0) {
					lkupClass = (longAt(rcvr - (BASE_HEADER_SIZE))) & (ALL_BUT_TYPE_MASK);
					goto l43;
				} else {
					/* begin fetchPointer:ofObject: */
					oop1 = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (CompactClasses << (SHIFT_FOR_WORD)));
					lkupClass = longAt((oop1 + (BASE_HEADER_SIZE)) + ((ccIndex - 1) << (SHIFT_FOR_WORD)));
					goto l43;
				}
			l43:	/* end fetchClassOf: */;
				receiverClass = lkupClass;
				/* goto commonSend */
			}
;
			
		commonSend:
			/* commonSend */
			{
				sqInt ok;
				sqInt hash;
				sqInt probe;
				sqInt delta;
				sqInt localPrimIndex;
				sqInt nArgs;
				sqInt oop;
				sqInt argCount2;
				sqInt i;
				sqInt methodHeader;
				sqInt needsLarge;
				sqInt newContext;
				sqInt tempCount;
				sqInt where;
				sqInt tmp;
				sqInt valuePointer;
				/* begin internalFindNewMethod */
				/* begin lookupInMethodCacheSel:class: */
				hash = messageSelector ^ lkupClass;
				probe = hash & MethodCacheMask;
				if (((methodCache[probe + MethodCacheSelector]) == messageSelector) && ((methodCache[probe + MethodCacheClass]) == lkupClass)) {
					newMethod = (usqInt)methodCache[probe + MethodCacheMethod];
					primitiveIndex = methodCache[probe + MethodCachePrim];
					newNativeMethod = methodCache[probe + MethodCacheNative];
					primitiveFunctionPointer = ((void (*)(void)) (methodCache[probe + MethodCachePrimFunction]));
					ok = 1;
					goto l44;
				}
				probe = (((usqInt) hash) >> 1) & MethodCacheMask;
				if (((methodCache[probe + MethodCacheSelector]) == messageSelector) && ((methodCache[probe + MethodCacheClass]) == lkupClass)) {
					newMethod = (usqInt)methodCache[probe + MethodCacheMethod];
					primitiveIndex = methodCache[probe + MethodCachePrim];
					newNativeMethod = methodCache[probe + MethodCacheNative];
					primitiveFunctionPointer = ((void (*)(void)) (methodCache[probe + MethodCachePrimFunction]));
					ok = 1;
					goto l44;
				}
				probe = (((usqInt) hash) >> 2) & MethodCacheMask;
				if (((methodCache[probe + MethodCacheSelector]) == messageSelector) && ((methodCache[probe + MethodCacheClass]) == lkupClass)) {
					newMethod = (usqInt)methodCache[probe + MethodCacheMethod];
					primitiveIndex = methodCache[probe + MethodCachePrim];
					newNativeMethod = methodCache[probe + MethodCacheNative];
					primitiveFunctionPointer = ((void (*)(void)) (methodCache[probe + MethodCachePrimFunction]));
					ok = 1;
					goto l44;
				}
				ok = 0;
			l44:	/* end lookupInMethodCacheSel:class: */;
				if (!(ok)) {
					/* begin externalizeIPandSP */
					instructionPointer = (usqInt)oopForPointer(localIP);
					stackPointer = (usqInt)oopForPointer(localSP);
					theHomeContext = localHomeContext;
					lookupMethodInClass(lkupClass);
					/* begin internalizeIPandSP */
					localIP = pointerForOop(instructionPointer);
					localSP = pointerForOop(stackPointer);
					localHomeContext = theHomeContext;
					addNewMethodToCache();
				}
				/* begin internalExecuteNewMethod */
				localPrimIndex = primitiveIndex;
				if (localPrimIndex > 0) {
					if ((localPrimIndex > 255) && (localPrimIndex < 520)) {
						if (localPrimIndex >= 264) {
							/* begin internalPop:thenPush: */
							oop = longAt(((longAtPointer(localSP)) + (BASE_HEADER_SIZE)) + ((localPrimIndex - 264) << (SHIFT_FOR_WORD)));
							longAtPointerput((localSP -= (1 - 1) * (BYTES_PER_WORD)), oop);
							goto l45;
						} else {
							if (localPrimIndex == 256) {
								goto l45;
							}
							if (localPrimIndex == 257) {
								/* begin internalPop:thenPush: */
								longAtPointerput((localSP -= (1 - 1) * (BYTES_PER_WORD)), trueObj);
								goto l45;
							}
							if (localPrimIndex == 258) {
								/* begin internalPop:thenPush: */
								longAtPointerput((localSP -= (1 - 1) * (BYTES_PER_WORD)), falseObj);
								goto l45;
							}
							if (localPrimIndex == 259) {
								/* begin internalPop:thenPush: */
								longAtPointerput((localSP -= (1 - 1) * (BYTES_PER_WORD)), nilObj);
								goto l45;
							}
							/* begin internalPop:thenPush: */
							longAtPointerput((localSP -= (1 - 1) * (BYTES_PER_WORD)), (((localPrimIndex - 261) << 1) | 1));
							goto l45;
						}
					} else {
						/* begin externalizeIPandSP */
						instructionPointer = (usqInt)oopForPointer(localIP);
						stackPointer = (usqInt)oopForPointer(localSP);
						theHomeContext = localHomeContext;
						if (DoBalanceChecks) {
							nArgs = argumentCount;
							delta = stackPointer - activeContext;
						}
						/* begin initPrimCall */
						primFailCode = 0;
						dispatchFunctionPointer(primitiveFunctionPointer);
						if (DoBalanceChecks) {
							if (!(balancedStackafterPrimitivewithArgs(delta, localPrimIndex, nArgs))) {
								printUnbalancedStack(localPrimIndex);
							}
						}
						/* begin internalizeIPandSP */
						localIP = pointerForOop(instructionPointer);
						localSP = pointerForOop(stackPointer);
						localHomeContext = theHomeContext;
						if (!primFailCode) {
							browserPluginReturnIfNeeded();
							goto l45;
						}
					}
				}
				/* begin internalActivateNewMethod */
				methodHeader = longAt((newMethod + (BASE_HEADER_SIZE)) + (HeaderIndex << (SHIFT_FOR_WORD)));
				needsLarge = methodHeader & LargeContextBit;
				if ((needsLarge == 0) && (freeContexts != NilContext)) {
					newContext = freeContexts;
					/* begin setFreeContextsAfter: */
					freeContexts = longAt((newContext + (BASE_HEADER_SIZE)) + (0 << (SHIFT_FOR_WORD)));
				} else {
					/* begin externalizeIPandSP */
					instructionPointer = (usqInt)oopForPointer(localIP);
					stackPointer = (usqInt)oopForPointer(localSP);
					theHomeContext = localHomeContext;
					newContext = allocateOrRecycleContext(needsLarge);
					/* begin internalizeIPandSP */
					localIP = pointerForOop(instructionPointer);
					localSP = pointerForOop(stackPointer);
					localHomeContext = theHomeContext;
				}
				tempCount = (((usqInt) methodHeader) >> 19) & 63;
				where = newContext + (BASE_HEADER_SIZE);
				longAtput(where + (SenderIndex << (SHIFT_FOR_WORD)), activeContext);
				longAtput(where + (InstructionPointerIndex << (SHIFT_FOR_WORD)), (((((LiteralStart + ((((usqInt) methodHeader) >> 10) & 255)) * (BYTES_PER_WORD)) + 1) << 1) | 1));
				longAtput(where + (StackPointerIndex << (SHIFT_FOR_WORD)), ((tempCount << 1) | 1));
				longAtput(where + (MethodIndex << (SHIFT_FOR_WORD)), newMethod);
				longAtput(where + (ClosureIndex << (SHIFT_FOR_WORD)), nilObj);
				argCount2 = argumentCount;
				for (i = 0; i <= argCount2; i += 1) {
					longAtput(where + ((ReceiverIndex + i) << (SHIFT_FOR_WORD)), longAtPointer(localSP - ((argCount2 - i) * (BYTES_PER_WORD))));
				}
				methodHeader = nilObj;
				for (i = ((argCount2 + 1) + ReceiverIndex); i <= (tempCount + ReceiverIndex); i += 1) {
					longAtput(where + (i << (SHIFT_FOR_WORD)), methodHeader);
				}
				/* begin internalPop: */
				localSP -= (argCount2 + 1) * (BYTES_PER_WORD);
				reclaimableContextCount += 1;
				/* begin internalNewActiveContext: */
				/* begin internalStoreContextRegisters: */
				longAtput((activeContext + (BASE_HEADER_SIZE)) + (InstructionPointerIndex << (SHIFT_FOR_WORD)), (((((oopForPointer(localIP)) + 2) - (method + (BASE_HEADER_SIZE))) << 1) | 1));
				/* begin storePointerUnchecked:ofObject:withValue: */
				valuePointer = (((((((usqInt) ((oopForPointer(localSP)) - (activeContext + (BASE_HEADER_SIZE)))) >> (SHIFT_FOR_WORD)) - TempFrameStart) + 1) << 1) | 1);
				longAtput((activeContext + (BASE_HEADER_SIZE)) + (StackPointerIndex << (SHIFT_FOR_WORD)), valuePointer);
				if ((((usqInt) newContext)) < (((usqInt) youngStart))) {
					beRootIfOld(newContext);
				}
				activeContext = newContext;
				/* begin internalFetchContextRegisters: */
				tmp = longAt((newContext + (BASE_HEADER_SIZE)) + (MethodIndex << (SHIFT_FOR_WORD)));
				if ((tmp & 1)) {
					tmp = longAt((newContext + (BASE_HEADER_SIZE)) + (HomeIndex << (SHIFT_FOR_WORD)));
					if ((((usqInt) tmp)) < (((usqInt) youngStart))) {
						beRootIfOld(tmp);
					}
				} else {
					tmp = newContext;
				}
				localHomeContext = tmp;
				receiver = longAt((tmp + (BASE_HEADER_SIZE)) + (ReceiverIndex << (SHIFT_FOR_WORD)));
				method = (usqInt)longAt((tmp + (BASE_HEADER_SIZE)) + (MethodIndex << (SHIFT_FOR_WORD)));
				tmp = ((longAt((newContext + (BASE_HEADER_SIZE)) + (InstructionPointerIndex << (SHIFT_FOR_WORD)))) >> 1);
				localIP = pointerForOop(((method + tmp) + (BASE_HEADER_SIZE)) - 2);
				tmp = ((longAt((newContext + (BASE_HEADER_SIZE)) + (StackPointerIndex << (SHIFT_FOR_WORD)))) >> 1);
				localSP = pointerForOop((newContext + (BASE_HEADER_SIZE)) + (((TempFrameStart + tmp) - 1) * (BYTES_PER_WORD)));
				/* begin internalQuickCheckForInterrupts */
				if (((interruptCheckCounter -= 1)) <= 0) {
					/* begin externalizeIPandSP */
					instructionPointer = (usqInt)oopForPointer(localIP);
					stackPointer = (usqInt)oopForPointer(localSP);
					theHomeContext = localHomeContext;
					checkForInterrupts();
					browserPluginReturnIfNeeded();
					/* begin internalizeIPandSP */
					localIP = pointerForOop(instructionPointer);
					localSP = pointerForOop(stackPointer);
					localHomeContext = theHomeContext;
				}
			l45:	/* end internalExecuteNewMethod */;
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
			}
;
			break;
		case 132:
			/* doubleExtendedDoAnythingBytecode */
			{
				sqInt byte2;
				sqInt byte3;
				sqInt opType;
				sqInt top;
				sqInt oop;
				sqInt object;
				sqInt object1;
				sqInt object2;
				sqInt oop1;
				byte2 = byteAtPointer(++localIP);
				byte3 = byteAtPointer(++localIP);
				opType = ((usqInt) byte2) >> 5;
				if (opType == 0) {
					messageSelector = longAt((method + (BASE_HEADER_SIZE)) + ((byte3 + LiteralStart) << (SHIFT_FOR_WORD)));
					argumentCount = byte2 & 31;
					goto normalSend;
					goto l4;
				}
				if (opType == 1) {
					messageSelector = longAt((method + (BASE_HEADER_SIZE)) + ((byte3 + LiteralStart) << (SHIFT_FOR_WORD)));
					argumentCount = byte2 & 31;
					goto commonSupersend;
					goto l4;
				}
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				if (opType == 2) {
					/* begin pushReceiverVariable: */
					/* begin internalPush: */
					object = longAt((receiver + (BASE_HEADER_SIZE)) + (byte3 << (SHIFT_FOR_WORD)));
					longAtPointerput((localSP += BYTES_PER_WORD), object);
					goto l4;
				}
				if (opType == 3) {
					/* begin pushLiteralConstant: */
					/* begin internalPush: */
					object1 = longAt((method + (BASE_HEADER_SIZE)) + ((byte3 + LiteralStart) << (SHIFT_FOR_WORD)));
					longAtPointerput((localSP += BYTES_PER_WORD), object1);
					goto l4;
				}
				if (opType == 4) {
					/* begin pushLiteralVariable: */
					/* begin internalPush: */
					/* begin fetchPointer:ofObject: */
					oop1 = longAt((method + (BASE_HEADER_SIZE)) + ((byte3 + LiteralStart) << (SHIFT_FOR_WORD)));
					object2 = longAt((oop1 + (BASE_HEADER_SIZE)) + (ValueIndex << (SHIFT_FOR_WORD)));
					longAtPointerput((localSP += BYTES_PER_WORD), object2);
					goto l4;
				}
				if (opType == 5) {
					top = longAtPointer(localSP);
					/* begin storePointer:ofObject:withValue: */
					if ((((usqInt) receiver)) < (((usqInt) youngStart))) {
						possibleRootStoreIntovalue(receiver, top);
					}
					longAtput((receiver + (BASE_HEADER_SIZE)) + (byte3 << (SHIFT_FOR_WORD)), top);
					goto l4;
				}
				if (opType == 6) {
					top = longAtPointer(localSP);
					/* begin internalPop: */
					localSP -= 1 * (BYTES_PER_WORD);
					/* begin storePointer:ofObject:withValue: */
					if ((((usqInt) receiver)) < (((usqInt) youngStart))) {
						possibleRootStoreIntovalue(receiver, top);
					}
					longAtput((receiver + (BASE_HEADER_SIZE)) + (byte3 << (SHIFT_FOR_WORD)), top);
					goto l4;
				}
				if (opType == 7) {
					top = longAtPointer(localSP);
					/* begin storePointer:ofObject:withValue: */
					oop = longAt((method + (BASE_HEADER_SIZE)) + ((byte3 + LiteralStart) << (SHIFT_FOR_WORD)));
					if ((((usqInt) oop)) < (((usqInt) youngStart))) {
						possibleRootStoreIntovalue(oop, top);
					}
					longAtput((oop + (BASE_HEADER_SIZE)) + (ValueIndex << (SHIFT_FOR_WORD)), top);
					goto l4;
				}
			}
;
		l4:	/* end case */;
			break;
		case 133:
			/* singleExtendedSuperBytecode */
			{
				sqInt descriptor;
				descriptor = byteAtPointer(++localIP);
				messageSelector = longAt((method + (BASE_HEADER_SIZE)) + (((descriptor & 31) + LiteralStart) << (SHIFT_FOR_WORD)));
				argumentCount = ((usqInt) descriptor) >> 5;
				/* goto commonSupersend */
			}
;
			
		commonSupersend:
			/* superclassSend */
			{
				sqInt rcvr;
				sqInt classPointer;
				sqInt oop;
				sqInt offset;
				sqInt ccIndex;
				sqInt oop1;
				/* begin superclassOf: */
				/* begin fetchPointer:ofObject: */
				/* begin literal:ofMethod: */
				offset = (literalCountOfHeader(longAt((method + (BASE_HEADER_SIZE)) + (HeaderIndex << (SHIFT_FOR_WORD))))) - 1;
				oop = longAt((method + (BASE_HEADER_SIZE)) + ((offset + LiteralStart) << (SHIFT_FOR_WORD)));
				classPointer = longAt((oop + (BASE_HEADER_SIZE)) + (ValueIndex << (SHIFT_FOR_WORD)));
				lkupClass = longAt((classPointer + (BASE_HEADER_SIZE)) + (SuperclassIndex << (SHIFT_FOR_WORD)));
				rcvr = longAtPointer(localSP - (argumentCount * (BYTES_PER_WORD)));
				/* begin fetchClassOf: */
				if ((rcvr & 1)) {
					receiverClass = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassInteger << (SHIFT_FOR_WORD)));
					goto l46;
				}
				ccIndex = (((usqInt) (longAt(rcvr))) >> 12) & 31;
				if (ccIndex == 0) {
					receiverClass = (longAt(rcvr - (BASE_HEADER_SIZE))) & (ALL_BUT_TYPE_MASK);
					goto l46;
				} else {
					/* begin fetchPointer:ofObject: */
					oop1 = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (CompactClasses << (SHIFT_FOR_WORD)));
					receiverClass = longAt((oop1 + (BASE_HEADER_SIZE)) + ((ccIndex - 1) << (SHIFT_FOR_WORD)));
					goto l46;
				}
			l46:	/* end fetchClassOf: */;
				goto commonSend;
			}
;
			break;
		case 134:
			/* secondExtendedSendBytecode */
			{
				sqInt descriptor;
				descriptor = byteAtPointer(++localIP);
				messageSelector = longAt((method + (BASE_HEADER_SIZE)) + (((descriptor & 63) + LiteralStart) << (SHIFT_FOR_WORD)));
				argumentCount = ((usqInt) descriptor) >> 6;
				goto normalSend;
			}
;
			break;
		case 135:
			/* popStackBytecode */
			{
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin internalPop: */
				localSP -= 1 * (BYTES_PER_WORD);
			}
;
			break;
		case 136:
			/* duplicateTopBytecode */
			{
				sqInt object;
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin internalPush: */
				object = longAtPointer(localSP);
				longAtPointerput((localSP += BYTES_PER_WORD), object);
			}
;
			break;
		case 137:
			/* pushActiveContextBytecode */
			{
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				reclaimableContextCount = 0;
				/* begin internalPush: */
				longAtPointerput((localSP += BYTES_PER_WORD), activeContext);
			}
;
			break;
		case 138:
			/* pushNewArrayBytecode */
			{
				sqInt array;
				sqInt i;
				sqInt popValues;
				sqInt size;
				size = byteAtPointer(++localIP);
				popValues = size > 127;
				size = size & 127;
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin externalizeIPandSP */
				instructionPointer = (usqInt)oopForPointer(localIP);
				stackPointer = (usqInt)oopForPointer(localSP);
				theHomeContext = localHomeContext;
				array = instantiateClassindexableSize(longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassArray << (SHIFT_FOR_WORD))), size);
				/* begin internalizeIPandSP */
				localIP = pointerForOop(instructionPointer);
				localSP = pointerForOop(stackPointer);
				localHomeContext = theHomeContext;
				if (popValues) {
					for (i = 0; i <= (size - 1); i += 1) {
						longAtput((array + (BASE_HEADER_SIZE)) + (i << (SHIFT_FOR_WORD)), longAtPointer(localSP - (((size - i) - 1) * (BYTES_PER_WORD))));
					}
					/* begin internalPop: */
					localSP -= size * (BYTES_PER_WORD);
				}
				/* begin internalPush: */
				longAtPointerput((localSP += BYTES_PER_WORD), array);
			}
;
			break;
		case 139:
			/* unknownBytecode */
			{
				error("Unknown bytecode");
			}
;
			break;
		case 140:
			/* pushRemoteTempLongBytecode */
			{
				sqInt remoteTempIndex;
				sqInt tempVectorIndex;
				sqInt tempVector;
				sqInt object;
				remoteTempIndex = byteAtPointer(++localIP);
				tempVectorIndex = byteAtPointer(++localIP);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushRemoteTemp:inVectorAt: */
				tempVector = longAt((localHomeContext + (BASE_HEADER_SIZE)) + ((tempVectorIndex + TempFrameStart) << (SHIFT_FOR_WORD)));
				/* begin internalPush: */
				object = longAt((tempVector + (BASE_HEADER_SIZE)) + (remoteTempIndex << (SHIFT_FOR_WORD)));
				longAtPointerput((localSP += BYTES_PER_WORD), object);
			}
;
			break;
		case 141:
			/* storeRemoteTempLongBytecode */
			{
				sqInt remoteTempIndex;
				sqInt tempVectorIndex;
				sqInt tempVector;
				remoteTempIndex = byteAtPointer(++localIP);
				tempVectorIndex = byteAtPointer(++localIP);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin storeRemoteTemp:inVectorAt: */
				tempVector = longAt((localHomeContext + (BASE_HEADER_SIZE)) + ((tempVectorIndex + TempFrameStart) << (SHIFT_FOR_WORD)));
				/* begin storePointer:ofObject:withValue: */
				if ((((usqInt) tempVector)) < (((usqInt) youngStart))) {
					possibleRootStoreIntovalue(tempVector, longAtPointer(localSP));
				}
				longAtput((tempVector + (BASE_HEADER_SIZE)) + (remoteTempIndex << (SHIFT_FOR_WORD)), longAtPointer(localSP));
			}
;
			break;
		case 142:
			/* storeAndPopRemoteTempLongBytecode */
			{
				sqInt remoteTempIndex;
				sqInt tempVectorIndex;
				sqInt tempVector;
				/* begin storeRemoteTempLongBytecode */
				remoteTempIndex = byteAtPointer(++localIP);
				tempVectorIndex = byteAtPointer(++localIP);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin storeRemoteTemp:inVectorAt: */
				tempVector = longAt((localHomeContext + (BASE_HEADER_SIZE)) + ((tempVectorIndex + TempFrameStart) << (SHIFT_FOR_WORD)));
				/* begin storePointer:ofObject:withValue: */
				if ((((usqInt) tempVector)) < (((usqInt) youngStart))) {
					possibleRootStoreIntovalue(tempVector, longAtPointer(localSP));
				}
				longAtput((tempVector + (BASE_HEADER_SIZE)) + (remoteTempIndex << (SHIFT_FOR_WORD)), longAtPointer(localSP));
				/* begin internalPop: */
				localSP -= 1 * (BYTES_PER_WORD);
			}
;
			break;
		case 143:
			/* pushClosureCopyCopiedValuesBytecode */
			{
				sqInt blockSize;
				sqInt i;
				sqInt newClosure;
				sqInt numArgs;
				sqInt numArgsNumCopied;
				sqInt numCopied;
				sqInt initialIP;
				sqInt newClosure1;
				if ((BYTES_PER_WORD) == 4) {
					imageFormatVersionNumber = 6504;
				} else {
					imageFormatVersionNumber = 68002;
				}
				numArgsNumCopied = byteAtPointer(++localIP);
				numArgs = numArgsNumCopied & 15;
				numCopied = ((usqInt) numArgsNumCopied >> 4);
				blockSize = (byteAtPointer(++localIP)) << 8;
				blockSize += byteAtPointer(++localIP);
				/* begin externalizeIPandSP */
				instructionPointer = (usqInt)oopForPointer(localIP);
				stackPointer = (usqInt)oopForPointer(localSP);
				theHomeContext = localHomeContext;
				/* begin closureNumArgs:instructionPointer:numCopiedValues: */
				initialIP = ((oopForPointer(localIP)) + 2) - (method + (BASE_HEADER_SIZE));
				newClosure1 = instantiateSmallClasssizeInBytes(longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassBlockClosure << (SHIFT_FOR_WORD))), ((BYTES_PER_WORD) * (ClosureFirstCopiedValueIndex + numCopied)) + (BASE_HEADER_SIZE));
				longAtput((newClosure1 + (BASE_HEADER_SIZE)) + (ClosureStartPCIndex << (SHIFT_FOR_WORD)), ((initialIP << 1) | 1));
				longAtput((newClosure1 + (BASE_HEADER_SIZE)) + (ClosureNumArgsIndex << (SHIFT_FOR_WORD)), ((numArgs << 1) | 1));
				newClosure = newClosure1;
				/* begin internalizeIPandSP */
				localIP = pointerForOop(instructionPointer);
				localSP = pointerForOop(stackPointer);
				localHomeContext = theHomeContext;
				longAtput((newClosure + (BASE_HEADER_SIZE)) + (ClosureOuterContextIndex << (SHIFT_FOR_WORD)), activeContext);
				reclaimableContextCount = 0;
				if (numCopied > 0) {
					for (i = 0; i <= (numCopied - 1); i += 1) {
						longAtput((newClosure + (BASE_HEADER_SIZE)) + ((i + ClosureFirstCopiedValueIndex) << (SHIFT_FOR_WORD)), longAtPointer(localSP - (((numCopied - i) - 1) * (BYTES_PER_WORD))));
					}
					/* begin internalPop: */
					localSP -= numCopied * (BYTES_PER_WORD);
				}
				localIP += blockSize;
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin internalPush: */
				longAtPointerput((localSP += BYTES_PER_WORD), newClosure);
			}
;
			break;
		case 144:
			/* shortUnconditionalJump */
			{
				sqInt offset;
				/* begin jump: */
				offset = (144 & 7) + 1;
				localIP = (localIP + offset) + 1;
				currentBytecode = byteAtPointer(localIP);
			}
;
			break;
		case 145:
			/* shortUnconditionalJump */
			{
				sqInt offset;
				/* begin jump: */
				offset = (145 & 7) + 1;
				localIP = (localIP + offset) + 1;
				currentBytecode = byteAtPointer(localIP);
			}
;
			break;
		case 146:
			/* shortUnconditionalJump */
			{
				sqInt offset;
				/* begin jump: */
				offset = (146 & 7) + 1;
				localIP = (localIP + offset) + 1;
				currentBytecode = byteAtPointer(localIP);
			}
;
			break;
		case 147:
			/* shortUnconditionalJump */
			{
				sqInt offset;
				/* begin jump: */
				offset = (147 & 7) + 1;
				localIP = (localIP + offset) + 1;
				currentBytecode = byteAtPointer(localIP);
			}
;
			break;
		case 148:
			/* shortUnconditionalJump */
			{
				sqInt offset;
				/* begin jump: */
				offset = (148 & 7) + 1;
				localIP = (localIP + offset) + 1;
				currentBytecode = byteAtPointer(localIP);
			}
;
			break;
		case 149:
			/* shortUnconditionalJump */
			{
				sqInt offset;
				/* begin jump: */
				offset = (149 & 7) + 1;
				localIP = (localIP + offset) + 1;
				currentBytecode = byteAtPointer(localIP);
			}
;
			break;
		case 150:
			/* shortUnconditionalJump */
			{
				sqInt offset;
				/* begin jump: */
				offset = (150 & 7) + 1;
				localIP = (localIP + offset) + 1;
				currentBytecode = byteAtPointer(localIP);
			}
;
			break;
		case 151:
			/* shortUnconditionalJump */
			{
				sqInt offset;
				/* begin jump: */
				offset = (151 & 7) + 1;
				localIP = (localIP + offset) + 1;
				currentBytecode = byteAtPointer(localIP);
			}
;
			break;
		case 152:
		case 153:
		case 154:
		case 155:
		case 156:
		case 157:
		case 158:
		case 159:
			/* shortConditionalJump */
			{
				sqInt offset;
				sqInt boolean;
				/* begin jumplfFalseBy: */
				offset = (currentBytecode & 7) + 1;
				boolean = longAtPointer(localSP);
				if (boolean == falseObj) {
					/* begin jump: */
					localIP = (localIP + offset) + 1;
					currentBytecode = byteAtPointer(localIP);
				} else {
					if (!(boolean == trueObj)) {
						messageSelector = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (SelectorMustBeBoolean << (SHIFT_FOR_WORD)));
						argumentCount = 0;
						goto normalSend;
						goto l5;
					}
					/* begin fetchNextBytecode */
					currentBytecode = byteAtPointer(++localIP);
				}
				/* begin internalPop: */
				localSP -= 1 * (BYTES_PER_WORD);
			l5:	/* end jumplfFalseBy: */;
			}
;
			break;
		case 160:
		case 161:
		case 162:
		case 163:
		case 164:
		case 165:
		case 166:
		case 167:
			/* longUnconditionalJump */
			{
				sqInt offset;
				offset = (((currentBytecode & 7) - 4) * 256) + (byteAtPointer(++localIP));
				localIP += offset;
				if (offset < 0) {
					/* begin internalQuickCheckForInterrupts */
					if (((interruptCheckCounter -= 1)) <= 0) {
						/* begin externalizeIPandSP */
						instructionPointer = (usqInt)oopForPointer(localIP);
						stackPointer = (usqInt)oopForPointer(localSP);
						theHomeContext = localHomeContext;
						checkForInterrupts();
						browserPluginReturnIfNeeded();
						/* begin internalizeIPandSP */
						localIP = pointerForOop(instructionPointer);
						localSP = pointerForOop(stackPointer);
						localHomeContext = theHomeContext;
					}
				}
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
			}
;
			break;
		case 168:
		case 169:
		case 170:
		case 171:
			/* longJumpIfTrue */
			{
				sqInt offset;
				sqInt boolean;
				/* begin jumplfTrueBy: */
				offset = ((currentBytecode & 3) * 256) + (byteAtPointer(++localIP));
				boolean = longAtPointer(localSP);
				if (boolean == trueObj) {
					/* begin jump: */
					localIP = (localIP + offset) + 1;
					currentBytecode = byteAtPointer(localIP);
				} else {
					if (!(boolean == falseObj)) {
						messageSelector = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (SelectorMustBeBoolean << (SHIFT_FOR_WORD)));
						argumentCount = 0;
						goto normalSend;
						goto l6;
					}
					/* begin fetchNextBytecode */
					currentBytecode = byteAtPointer(++localIP);
				}
				/* begin internalPop: */
				localSP -= 1 * (BYTES_PER_WORD);
			l6:	/* end jumplfTrueBy: */;
			}
;
			break;
		case 172:
		case 173:
		case 174:
		case 175:
			/* longJumpIfFalse */
			{
				sqInt offset;
				sqInt boolean;
				/* begin jumplfFalseBy: */
				offset = ((currentBytecode & 3) * 256) + (byteAtPointer(++localIP));
				boolean = longAtPointer(localSP);
				if (boolean == falseObj) {
					/* begin jump: */
					localIP = (localIP + offset) + 1;
					currentBytecode = byteAtPointer(localIP);
				} else {
					if (!(boolean == trueObj)) {
						messageSelector = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (SelectorMustBeBoolean << (SHIFT_FOR_WORD)));
						argumentCount = 0;
						goto normalSend;
						goto l7;
					}
					/* begin fetchNextBytecode */
					currentBytecode = byteAtPointer(++localIP);
				}
				/* begin internalPop: */
				localSP -= 1 * (BYTES_PER_WORD);
			l7:	/* end jumplfFalseBy: */;
			}
;
			break;
		case 176:
			/* bytecodePrimAdd */
			{
				sqInt arg;
				sqInt rcvr;
				sqInt result;
				sqInt oop;
				rcvr = longAtPointer(localSP - (1 * (BYTES_PER_WORD)));
				arg = longAtPointer(localSP - (0 * (BYTES_PER_WORD)));
				if (((rcvr & arg) & 1) != 0) {
					result = ((rcvr >> 1)) + ((arg >> 1));
					if (
# ifdef SQ_HOST32  // cast to int for 64 bit image on 32 bit host
						(((((int) result)) ^ ((((int) result)) << 1)) >= 0)
# else
						((result >= -1073741824) && (result <= 1073741823))
# endif  // SQ_HOST32
					) {
						/* begin internalPop:thenPush: */
						longAtPointerput((localSP -= (2 - 1) * (BYTES_PER_WORD)), ((result << 1) | 1));
						/* begin fetchNextBytecode */
						currentBytecode = byteAtPointer(++localIP);
						goto l8;
					}
				} else {
					/* begin initPrimCall */
					primFailCode = 0;
					/* begin externalizeIPandSP */
					instructionPointer = (usqInt)oopForPointer(localIP);
					stackPointer = (usqInt)oopForPointer(localSP);
					theHomeContext = localHomeContext;
					primitiveFloatAddtoArg(rcvr, arg);
					/* begin internalizeIPandSP */
					localIP = pointerForOop(instructionPointer);
					localSP = pointerForOop(stackPointer);
					localHomeContext = theHomeContext;
					if (!primFailCode) {
						/* begin fetchNextBytecode */
						currentBytecode = byteAtPointer(++localIP);
						goto l8;
					}
				}
				/* begin fetchPointer:ofObject: */
				oop = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (SpecialSelectors << (SHIFT_FOR_WORD)));
				messageSelector = longAt((oop + (BASE_HEADER_SIZE)) + ((0 * 2) << (SHIFT_FOR_WORD)));
				argumentCount = 1;
				goto normalSend;
			}
;
		l8:	/* end case */;
			break;
		case 177:
			/* bytecodePrimSubtract */
			{
				sqInt arg;
				sqInt rcvr;
				sqInt result;
				sqInt oop;
				rcvr = longAtPointer(localSP - (1 * (BYTES_PER_WORD)));
				arg = longAtPointer(localSP - (0 * (BYTES_PER_WORD)));
				if (((rcvr & arg) & 1) != 0) {
					result = ((rcvr >> 1)) - ((arg >> 1));
					if (
# ifdef SQ_HOST32  // cast to int for 64 bit image on 32 bit host
						(((((int) result)) ^ ((((int) result)) << 1)) >= 0)
# else
						((result >= -1073741824) && (result <= 1073741823))
# endif  // SQ_HOST32
					) {
						/* begin internalPop:thenPush: */
						longAtPointerput((localSP -= (2 - 1) * (BYTES_PER_WORD)), ((result << 1) | 1));
						/* begin fetchNextBytecode */
						currentBytecode = byteAtPointer(++localIP);
						goto l9;
					}
				} else {
					/* begin initPrimCall */
					primFailCode = 0;
					/* begin externalizeIPandSP */
					instructionPointer = (usqInt)oopForPointer(localIP);
					stackPointer = (usqInt)oopForPointer(localSP);
					theHomeContext = localHomeContext;
					primitiveFloatSubtractfromArg(rcvr, arg);
					/* begin internalizeIPandSP */
					localIP = pointerForOop(instructionPointer);
					localSP = pointerForOop(stackPointer);
					localHomeContext = theHomeContext;
					if (!primFailCode) {
						/* begin fetchNextBytecode */
						currentBytecode = byteAtPointer(++localIP);
						goto l9;
					}
				}
				/* begin fetchPointer:ofObject: */
				oop = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (SpecialSelectors << (SHIFT_FOR_WORD)));
				messageSelector = longAt((oop + (BASE_HEADER_SIZE)) + ((1 * 2) << (SHIFT_FOR_WORD)));
				argumentCount = 1;
				goto normalSend;
			}
;
		l9:	/* end case */;
			break;
		case 178:
			/* bytecodePrimLessThan */
			{
				sqInt aBool;
				sqInt arg;
				sqInt rcvr;
				sqInt oop;
				sqInt bytecode;
				sqInt offset;
				sqInt bytecode1;
				sqInt offset1;
				rcvr = longAtPointer(localSP - (1 * (BYTES_PER_WORD)));
				arg = longAtPointer(localSP - (0 * (BYTES_PER_WORD)));
				if (((rcvr & arg) & 1) != 0) {
					;
					/* begin booleanCheat: */
					bytecode = byteAtPointer(++localIP);
					/* begin internalPop: */
					localSP -= 2 * (BYTES_PER_WORD);
					if ((bytecode < 160) && (bytecode > 151)) {
						if (rcvr < arg) {
							/* begin fetchNextBytecode */
							currentBytecode = byteAtPointer(++localIP);
							goto l10;
						} else {
							/* begin jump: */
							localIP = (localIP + (bytecode - 151)) + 1;
							currentBytecode = byteAtPointer(localIP);
							goto l10;
						}
					}
					if (bytecode == 172) {
						offset = byteAtPointer(++localIP);
						if (rcvr < arg) {
							/* begin fetchNextBytecode */
							currentBytecode = byteAtPointer(++localIP);
							goto l10;
						} else {
							/* begin jump: */
							localIP = (localIP + offset) + 1;
							currentBytecode = byteAtPointer(localIP);
							goto l10;
						}
					}
					localIP -= 1;
					/* begin fetchNextBytecode */
					currentBytecode = byteAtPointer(++localIP);
					if (rcvr < arg) {
						/* begin internalPush: */
						longAtPointerput((localSP += BYTES_PER_WORD), trueObj);
					} else {
						/* begin internalPush: */
						longAtPointerput((localSP += BYTES_PER_WORD), falseObj);
					}
					goto l10;
				}
				/* begin initPrimCall */
				primFailCode = 0;
				aBool = primitiveFloatLessthanArg(rcvr, arg);
				if (!primFailCode) {
					/* begin booleanCheat: */
					bytecode1 = byteAtPointer(++localIP);
					/* begin internalPop: */
					localSP -= 2 * (BYTES_PER_WORD);
					if ((bytecode1 < 160) && (bytecode1 > 151)) {
						if (aBool) {
							/* begin fetchNextBytecode */
							currentBytecode = byteAtPointer(++localIP);
							goto l10;
						} else {
							/* begin jump: */
							localIP = (localIP + (bytecode1 - 151)) + 1;
							currentBytecode = byteAtPointer(localIP);
							goto l10;
						}
					}
					if (bytecode1 == 172) {
						offset1 = byteAtPointer(++localIP);
						if (aBool) {
							/* begin fetchNextBytecode */
							currentBytecode = byteAtPointer(++localIP);
							goto l10;
						} else {
							/* begin jump: */
							localIP = (localIP + offset1) + 1;
							currentBytecode = byteAtPointer(localIP);
							goto l10;
						}
					}
					localIP -= 1;
					/* begin fetchNextBytecode */
					currentBytecode = byteAtPointer(++localIP);
					if (aBool) {
						/* begin internalPush: */
						longAtPointerput((localSP += BYTES_PER_WORD), trueObj);
					} else {
						/* begin internalPush: */
						longAtPointerput((localSP += BYTES_PER_WORD), falseObj);
					}
					goto l10;
				}
				/* begin fetchPointer:ofObject: */
				oop = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (SpecialSelectors << (SHIFT_FOR_WORD)));
				messageSelector = longAt((oop + (BASE_HEADER_SIZE)) + ((2 * 2) << (SHIFT_FOR_WORD)));
				argumentCount = 1;
				goto normalSend;
			}
;
		l10:	/* end case */;
			break;
		case 179:
			/* bytecodePrimGreaterThan */
			{
				sqInt aBool;
				sqInt arg;
				sqInt rcvr;
				sqInt oop;
				sqInt bytecode;
				sqInt offset;
				sqInt bytecode1;
				sqInt offset1;
				rcvr = longAtPointer(localSP - (1 * (BYTES_PER_WORD)));
				arg = longAtPointer(localSP - (0 * (BYTES_PER_WORD)));
				if (((rcvr & arg) & 1) != 0) {
					;
					/* begin booleanCheat: */
					bytecode = byteAtPointer(++localIP);
					/* begin internalPop: */
					localSP -= 2 * (BYTES_PER_WORD);
					if ((bytecode < 160) && (bytecode > 151)) {
						if (rcvr > arg) {
							/* begin fetchNextBytecode */
							currentBytecode = byteAtPointer(++localIP);
							goto l11;
						} else {
							/* begin jump: */
							localIP = (localIP + (bytecode - 151)) + 1;
							currentBytecode = byteAtPointer(localIP);
							goto l11;
						}
					}
					if (bytecode == 172) {
						offset = byteAtPointer(++localIP);
						if (rcvr > arg) {
							/* begin fetchNextBytecode */
							currentBytecode = byteAtPointer(++localIP);
							goto l11;
						} else {
							/* begin jump: */
							localIP = (localIP + offset) + 1;
							currentBytecode = byteAtPointer(localIP);
							goto l11;
						}
					}
					localIP -= 1;
					/* begin fetchNextBytecode */
					currentBytecode = byteAtPointer(++localIP);
					if (rcvr > arg) {
						/* begin internalPush: */
						longAtPointerput((localSP += BYTES_PER_WORD), trueObj);
					} else {
						/* begin internalPush: */
						longAtPointerput((localSP += BYTES_PER_WORD), falseObj);
					}
					goto l11;
				}
				/* begin initPrimCall */
				primFailCode = 0;
				aBool = primitiveFloatGreaterthanArg(rcvr, arg);
				if (!primFailCode) {
					/* begin booleanCheat: */
					bytecode1 = byteAtPointer(++localIP);
					/* begin internalPop: */
					localSP -= 2 * (BYTES_PER_WORD);
					if ((bytecode1 < 160) && (bytecode1 > 151)) {
						if (aBool) {
							/* begin fetchNextBytecode */
							currentBytecode = byteAtPointer(++localIP);
							goto l11;
						} else {
							/* begin jump: */
							localIP = (localIP + (bytecode1 - 151)) + 1;
							currentBytecode = byteAtPointer(localIP);
							goto l11;
						}
					}
					if (bytecode1 == 172) {
						offset1 = byteAtPointer(++localIP);
						if (aBool) {
							/* begin fetchNextBytecode */
							currentBytecode = byteAtPointer(++localIP);
							goto l11;
						} else {
							/* begin jump: */
							localIP = (localIP + offset1) + 1;
							currentBytecode = byteAtPointer(localIP);
							goto l11;
						}
					}
					localIP -= 1;
					/* begin fetchNextBytecode */
					currentBytecode = byteAtPointer(++localIP);
					if (aBool) {
						/* begin internalPush: */
						longAtPointerput((localSP += BYTES_PER_WORD), trueObj);
					} else {
						/* begin internalPush: */
						longAtPointerput((localSP += BYTES_PER_WORD), falseObj);
					}
					goto l11;
				}
				/* begin fetchPointer:ofObject: */
				oop = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (SpecialSelectors << (SHIFT_FOR_WORD)));
				messageSelector = longAt((oop + (BASE_HEADER_SIZE)) + ((3 * 2) << (SHIFT_FOR_WORD)));
				argumentCount = 1;
				goto normalSend;
			}
;
		l11:	/* end case */;
			break;
		case 180:
			/* bytecodePrimLessOrEqual */
			{
				sqInt aBool;
				sqInt arg;
				sqInt rcvr;
				sqInt oop;
				sqInt bytecode;
				sqInt offset;
				sqInt bytecode1;
				sqInt offset1;
				rcvr = longAtPointer(localSP - (1 * (BYTES_PER_WORD)));
				arg = longAtPointer(localSP - (0 * (BYTES_PER_WORD)));
				if (((rcvr & arg) & 1) != 0) {
					;
					/* begin booleanCheat: */
					bytecode = byteAtPointer(++localIP);
					/* begin internalPop: */
					localSP -= 2 * (BYTES_PER_WORD);
					if ((bytecode < 160) && (bytecode > 151)) {
						if (rcvr <= arg) {
							/* begin fetchNextBytecode */
							currentBytecode = byteAtPointer(++localIP);
							goto l12;
						} else {
							/* begin jump: */
							localIP = (localIP + (bytecode - 151)) + 1;
							currentBytecode = byteAtPointer(localIP);
							goto l12;
						}
					}
					if (bytecode == 172) {
						offset = byteAtPointer(++localIP);
						if (rcvr <= arg) {
							/* begin fetchNextBytecode */
							currentBytecode = byteAtPointer(++localIP);
							goto l12;
						} else {
							/* begin jump: */
							localIP = (localIP + offset) + 1;
							currentBytecode = byteAtPointer(localIP);
							goto l12;
						}
					}
					localIP -= 1;
					/* begin fetchNextBytecode */
					currentBytecode = byteAtPointer(++localIP);
					if (rcvr <= arg) {
						/* begin internalPush: */
						longAtPointerput((localSP += BYTES_PER_WORD), trueObj);
					} else {
						/* begin internalPush: */
						longAtPointerput((localSP += BYTES_PER_WORD), falseObj);
					}
					goto l12;
				}
				/* begin initPrimCall */
				primFailCode = 0;
				aBool = primitiveFloatLessOrEqualtoArg(rcvr, arg);
				if (!primFailCode) {
					/* begin booleanCheat: */
					bytecode1 = byteAtPointer(++localIP);
					/* begin internalPop: */
					localSP -= 2 * (BYTES_PER_WORD);
					if ((bytecode1 < 160) && (bytecode1 > 151)) {
						if (aBool) {
							/* begin fetchNextBytecode */
							currentBytecode = byteAtPointer(++localIP);
							goto l12;
						} else {
							/* begin jump: */
							localIP = (localIP + (bytecode1 - 151)) + 1;
							currentBytecode = byteAtPointer(localIP);
							goto l12;
						}
					}
					if (bytecode1 == 172) {
						offset1 = byteAtPointer(++localIP);
						if (aBool) {
							/* begin fetchNextBytecode */
							currentBytecode = byteAtPointer(++localIP);
							goto l12;
						} else {
							/* begin jump: */
							localIP = (localIP + offset1) + 1;
							currentBytecode = byteAtPointer(localIP);
							goto l12;
						}
					}
					localIP -= 1;
					/* begin fetchNextBytecode */
					currentBytecode = byteAtPointer(++localIP);
					if (aBool) {
						/* begin internalPush: */
						longAtPointerput((localSP += BYTES_PER_WORD), trueObj);
					} else {
						/* begin internalPush: */
						longAtPointerput((localSP += BYTES_PER_WORD), falseObj);
					}
					goto l12;
				}
				/* begin fetchPointer:ofObject: */
				oop = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (SpecialSelectors << (SHIFT_FOR_WORD)));
				messageSelector = longAt((oop + (BASE_HEADER_SIZE)) + ((4 * 2) << (SHIFT_FOR_WORD)));
				argumentCount = 1;
				goto normalSend;
			}
;
		l12:	/* end case */;
			break;
		case 181:
			/* bytecodePrimGreaterOrEqual */
			{
				sqInt aBool;
				sqInt arg;
				sqInt rcvr;
				sqInt oop;
				sqInt bytecode;
				sqInt offset;
				sqInt bytecode1;
				sqInt offset1;
				rcvr = longAtPointer(localSP - (1 * (BYTES_PER_WORD)));
				arg = longAtPointer(localSP - (0 * (BYTES_PER_WORD)));
				if (((rcvr & arg) & 1) != 0) {
					;
					/* begin booleanCheat: */
					bytecode = byteAtPointer(++localIP);
					/* begin internalPop: */
					localSP -= 2 * (BYTES_PER_WORD);
					if ((bytecode < 160) && (bytecode > 151)) {
						if (rcvr >= arg) {
							/* begin fetchNextBytecode */
							currentBytecode = byteAtPointer(++localIP);
							goto l13;
						} else {
							/* begin jump: */
							localIP = (localIP + (bytecode - 151)) + 1;
							currentBytecode = byteAtPointer(localIP);
							goto l13;
						}
					}
					if (bytecode == 172) {
						offset = byteAtPointer(++localIP);
						if (rcvr >= arg) {
							/* begin fetchNextBytecode */
							currentBytecode = byteAtPointer(++localIP);
							goto l13;
						} else {
							/* begin jump: */
							localIP = (localIP + offset) + 1;
							currentBytecode = byteAtPointer(localIP);
							goto l13;
						}
					}
					localIP -= 1;
					/* begin fetchNextBytecode */
					currentBytecode = byteAtPointer(++localIP);
					if (rcvr >= arg) {
						/* begin internalPush: */
						longAtPointerput((localSP += BYTES_PER_WORD), trueObj);
					} else {
						/* begin internalPush: */
						longAtPointerput((localSP += BYTES_PER_WORD), falseObj);
					}
					goto l13;
				}
				/* begin initPrimCall */
				primFailCode = 0;
				aBool = primitiveFloatGreaterOrEqualtoArg(rcvr, arg);
				if (!primFailCode) {
					/* begin booleanCheat: */
					bytecode1 = byteAtPointer(++localIP);
					/* begin internalPop: */
					localSP -= 2 * (BYTES_PER_WORD);
					if ((bytecode1 < 160) && (bytecode1 > 151)) {
						if (aBool) {
							/* begin fetchNextBytecode */
							currentBytecode = byteAtPointer(++localIP);
							goto l13;
						} else {
							/* begin jump: */
							localIP = (localIP + (bytecode1 - 151)) + 1;
							currentBytecode = byteAtPointer(localIP);
							goto l13;
						}
					}
					if (bytecode1 == 172) {
						offset1 = byteAtPointer(++localIP);
						if (aBool) {
							/* begin fetchNextBytecode */
							currentBytecode = byteAtPointer(++localIP);
							goto l13;
						} else {
							/* begin jump: */
							localIP = (localIP + offset1) + 1;
							currentBytecode = byteAtPointer(localIP);
							goto l13;
						}
					}
					localIP -= 1;
					/* begin fetchNextBytecode */
					currentBytecode = byteAtPointer(++localIP);
					if (aBool) {
						/* begin internalPush: */
						longAtPointerput((localSP += BYTES_PER_WORD), trueObj);
					} else {
						/* begin internalPush: */
						longAtPointerput((localSP += BYTES_PER_WORD), falseObj);
					}
					goto l13;
				}
				/* begin fetchPointer:ofObject: */
				oop = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (SpecialSelectors << (SHIFT_FOR_WORD)));
				messageSelector = longAt((oop + (BASE_HEADER_SIZE)) + ((5 * 2) << (SHIFT_FOR_WORD)));
				argumentCount = 1;
				goto normalSend;
			}
;
		l13:	/* end case */;
			break;
		case 182:
			/* bytecodePrimEqual */
			{
				sqInt aBool;
				sqInt arg;
				sqInt rcvr;
				sqInt oop;
				sqInt bytecode;
				sqInt offset;
				sqInt bytecode1;
				sqInt offset1;
				rcvr = longAtPointer(localSP - (1 * (BYTES_PER_WORD)));
				arg = longAtPointer(localSP - (0 * (BYTES_PER_WORD)));
				if (((rcvr & arg) & 1) != 0) {
					/* begin booleanCheat: */
					bytecode = byteAtPointer(++localIP);
					/* begin internalPop: */
					localSP -= 2 * (BYTES_PER_WORD);
					if ((bytecode < 160) && (bytecode > 151)) {
						if (rcvr == arg) {
							/* begin fetchNextBytecode */
							currentBytecode = byteAtPointer(++localIP);
							goto l14;
						} else {
							/* begin jump: */
							localIP = (localIP + (bytecode - 151)) + 1;
							currentBytecode = byteAtPointer(localIP);
							goto l14;
						}
					}
					if (bytecode == 172) {
						offset = byteAtPointer(++localIP);
						if (rcvr == arg) {
							/* begin fetchNextBytecode */
							currentBytecode = byteAtPointer(++localIP);
							goto l14;
						} else {
							/* begin jump: */
							localIP = (localIP + offset) + 1;
							currentBytecode = byteAtPointer(localIP);
							goto l14;
						}
					}
					localIP -= 1;
					/* begin fetchNextBytecode */
					currentBytecode = byteAtPointer(++localIP);
					if (rcvr == arg) {
						/* begin internalPush: */
						longAtPointerput((localSP += BYTES_PER_WORD), trueObj);
					} else {
						/* begin internalPush: */
						longAtPointerput((localSP += BYTES_PER_WORD), falseObj);
					}
					goto l14;
				}
				/* begin initPrimCall */
				primFailCode = 0;
				aBool = primitiveFloatEqualtoArg(rcvr, arg);
				if (!primFailCode) {
					/* begin booleanCheat: */
					bytecode1 = byteAtPointer(++localIP);
					/* begin internalPop: */
					localSP -= 2 * (BYTES_PER_WORD);
					if ((bytecode1 < 160) && (bytecode1 > 151)) {
						if (aBool) {
							/* begin fetchNextBytecode */
							currentBytecode = byteAtPointer(++localIP);
							goto l14;
						} else {
							/* begin jump: */
							localIP = (localIP + (bytecode1 - 151)) + 1;
							currentBytecode = byteAtPointer(localIP);
							goto l14;
						}
					}
					if (bytecode1 == 172) {
						offset1 = byteAtPointer(++localIP);
						if (aBool) {
							/* begin fetchNextBytecode */
							currentBytecode = byteAtPointer(++localIP);
							goto l14;
						} else {
							/* begin jump: */
							localIP = (localIP + offset1) + 1;
							currentBytecode = byteAtPointer(localIP);
							goto l14;
						}
					}
					localIP -= 1;
					/* begin fetchNextBytecode */
					currentBytecode = byteAtPointer(++localIP);
					if (aBool) {
						/* begin internalPush: */
						longAtPointerput((localSP += BYTES_PER_WORD), trueObj);
					} else {
						/* begin internalPush: */
						longAtPointerput((localSP += BYTES_PER_WORD), falseObj);
					}
					goto l14;
				}
				/* begin fetchPointer:ofObject: */
				oop = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (SpecialSelectors << (SHIFT_FOR_WORD)));
				messageSelector = longAt((oop + (BASE_HEADER_SIZE)) + ((6 * 2) << (SHIFT_FOR_WORD)));
				argumentCount = 1;
				goto normalSend;
			}
;
		l14:	/* end case */;
			break;
		case 183:
			/* bytecodePrimNotEqual */
			{
				sqInt aBool;
				sqInt arg;
				sqInt rcvr;
				sqInt oop;
				sqInt bytecode;
				sqInt offset;
				sqInt bytecode1;
				sqInt offset1;
				rcvr = longAtPointer(localSP - (1 * (BYTES_PER_WORD)));
				arg = longAtPointer(localSP - (0 * (BYTES_PER_WORD)));
				if (((rcvr & arg) & 1) != 0) {
					/* begin booleanCheat: */
					bytecode = byteAtPointer(++localIP);
					/* begin internalPop: */
					localSP -= 2 * (BYTES_PER_WORD);
					if ((bytecode < 160) && (bytecode > 151)) {
						if (rcvr != arg) {
							/* begin fetchNextBytecode */
							currentBytecode = byteAtPointer(++localIP);
							goto l15;
						} else {
							/* begin jump: */
							localIP = (localIP + (bytecode - 151)) + 1;
							currentBytecode = byteAtPointer(localIP);
							goto l15;
						}
					}
					if (bytecode == 172) {
						offset = byteAtPointer(++localIP);
						if (rcvr != arg) {
							/* begin fetchNextBytecode */
							currentBytecode = byteAtPointer(++localIP);
							goto l15;
						} else {
							/* begin jump: */
							localIP = (localIP + offset) + 1;
							currentBytecode = byteAtPointer(localIP);
							goto l15;
						}
					}
					localIP -= 1;
					/* begin fetchNextBytecode */
					currentBytecode = byteAtPointer(++localIP);
					if (rcvr != arg) {
						/* begin internalPush: */
						longAtPointerput((localSP += BYTES_PER_WORD), trueObj);
					} else {
						/* begin internalPush: */
						longAtPointerput((localSP += BYTES_PER_WORD), falseObj);
					}
					goto l15;
				}
				/* begin initPrimCall */
				primFailCode = 0;
				aBool = primitiveFloatEqualtoArg(rcvr, arg);
				if (!primFailCode) {
					/* begin booleanCheat: */
					bytecode1 = byteAtPointer(++localIP);
					/* begin internalPop: */
					localSP -= 2 * (BYTES_PER_WORD);
					if ((bytecode1 < 160) && (bytecode1 > 151)) {
						if (!aBool) {
							/* begin fetchNextBytecode */
							currentBytecode = byteAtPointer(++localIP);
							goto l15;
						} else {
							/* begin jump: */
							localIP = (localIP + (bytecode1 - 151)) + 1;
							currentBytecode = byteAtPointer(localIP);
							goto l15;
						}
					}
					if (bytecode1 == 172) {
						offset1 = byteAtPointer(++localIP);
						if (!aBool) {
							/* begin fetchNextBytecode */
							currentBytecode = byteAtPointer(++localIP);
							goto l15;
						} else {
							/* begin jump: */
							localIP = (localIP + offset1) + 1;
							currentBytecode = byteAtPointer(localIP);
							goto l15;
						}
					}
					localIP -= 1;
					/* begin fetchNextBytecode */
					currentBytecode = byteAtPointer(++localIP);
					if (!aBool) {
						/* begin internalPush: */
						longAtPointerput((localSP += BYTES_PER_WORD), trueObj);
					} else {
						/* begin internalPush: */
						longAtPointerput((localSP += BYTES_PER_WORD), falseObj);
					}
					goto l15;
				}
				/* begin fetchPointer:ofObject: */
				oop = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (SpecialSelectors << (SHIFT_FOR_WORD)));
				messageSelector = longAt((oop + (BASE_HEADER_SIZE)) + ((7 * 2) << (SHIFT_FOR_WORD)));
				argumentCount = 1;
				goto normalSend;
			}
;
		l15:	/* end case */;
			break;
		case 184:
			/* bytecodePrimMultiply */
			{
				sqInt arg;
				sqInt rcvr;
				sqInt result;
				sqInt oop;
				rcvr = longAtPointer(localSP - (1 * (BYTES_PER_WORD)));
				arg = longAtPointer(localSP - (0 * (BYTES_PER_WORD)));
				if (((rcvr & arg) & 1) != 0) {
					rcvr = (rcvr >> 1);
					arg = (arg >> 1);
					result = rcvr * arg;
					if ((arg == 0) || (((result / arg) == rcvr) && (
# ifdef SQ_HOST32  // cast to int for 64 bit image on 32 bit host
	(((((int) result)) ^ ((((int) result)) << 1)) >= 0)
# else
	((result >= -1073741824) && (result <= 1073741823))
# endif  // SQ_HOST32
))) {
						/* begin internalPop:thenPush: */
						longAtPointerput((localSP -= (2 - 1) * (BYTES_PER_WORD)), ((result << 1) | 1));
						/* begin fetchNextBytecode */
						currentBytecode = byteAtPointer(++localIP);
						goto l16;
					}
				} else {
					/* begin initPrimCall */
					primFailCode = 0;
					/* begin externalizeIPandSP */
					instructionPointer = (usqInt)oopForPointer(localIP);
					stackPointer = (usqInt)oopForPointer(localSP);
					theHomeContext = localHomeContext;
					primitiveFloatMultiplybyArg(rcvr, arg);
					/* begin internalizeIPandSP */
					localIP = pointerForOop(instructionPointer);
					localSP = pointerForOop(stackPointer);
					localHomeContext = theHomeContext;
					if (!primFailCode) {
						/* begin fetchNextBytecode */
						currentBytecode = byteAtPointer(++localIP);
						goto l16;
					}
				}
				/* begin fetchPointer:ofObject: */
				oop = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (SpecialSelectors << (SHIFT_FOR_WORD)));
				messageSelector = longAt((oop + (BASE_HEADER_SIZE)) + ((8 * 2) << (SHIFT_FOR_WORD)));
				argumentCount = 1;
				goto normalSend;
			}
;
		l16:	/* end case */;
			break;
		case 185:
			/* bytecodePrimDivide */
			{
				sqInt arg;
				sqInt rcvr;
				sqInt result;
				sqInt oop;
				rcvr = longAtPointer(localSP - (1 * (BYTES_PER_WORD)));
				arg = longAtPointer(localSP - (0 * (BYTES_PER_WORD)));
				if (((rcvr & arg) & 1) != 0) {
					rcvr = (rcvr >> 1);
					arg = (arg >> 1);
					if ((arg != 0) && ((rcvr % arg) == 0)) {
						result = rcvr / arg;
						if (
# ifdef SQ_HOST32  // cast to int for 64 bit image on 32 bit host
							(((((int) result)) ^ ((((int) result)) << 1)) >= 0)
# else
							((result >= -1073741824) && (result <= 1073741823))
# endif  // SQ_HOST32
						) {
							/* begin internalPop:thenPush: */
							longAtPointerput((localSP -= (2 - 1) * (BYTES_PER_WORD)), ((result << 1) | 1));
							/* begin fetchNextBytecode */
							currentBytecode = byteAtPointer(++localIP);
							goto l17;
						}
					}
				} else {
					/* begin initPrimCall */
					primFailCode = 0;
					/* begin externalizeIPandSP */
					instructionPointer = (usqInt)oopForPointer(localIP);
					stackPointer = (usqInt)oopForPointer(localSP);
					theHomeContext = localHomeContext;
					primitiveFloatDividebyArg(rcvr, arg);
					/* begin internalizeIPandSP */
					localIP = pointerForOop(instructionPointer);
					localSP = pointerForOop(stackPointer);
					localHomeContext = theHomeContext;
					if (!primFailCode) {
						/* begin fetchNextBytecode */
						currentBytecode = byteAtPointer(++localIP);
						goto l17;
					}
				}
				/* begin fetchPointer:ofObject: */
				oop = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (SpecialSelectors << (SHIFT_FOR_WORD)));
				messageSelector = longAt((oop + (BASE_HEADER_SIZE)) + ((9 * 2) << (SHIFT_FOR_WORD)));
				argumentCount = 1;
				goto normalSend;
			}
;
		l17:	/* end case */;
			break;
		case 186:
			/* bytecodePrimMod */
			{
				sqInt mod;
				sqInt oop;
				/* begin initPrimCall */
				primFailCode = 0;
				mod = doPrimitiveModby(longAtPointer(localSP - (1 * (BYTES_PER_WORD))), longAtPointer(localSP - (0 * (BYTES_PER_WORD))));
				if (!primFailCode) {
					/* begin internalPop:thenPush: */
					longAtPointerput((localSP -= (2 - 1) * (BYTES_PER_WORD)), ((mod << 1) | 1));
					/* begin fetchNextBytecode */
					currentBytecode = byteAtPointer(++localIP);
					goto l18;
				}
				/* begin fetchPointer:ofObject: */
				oop = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (SpecialSelectors << (SHIFT_FOR_WORD)));
				messageSelector = longAt((oop + (BASE_HEADER_SIZE)) + ((10 * 2) << (SHIFT_FOR_WORD)));
				argumentCount = 1;
				goto normalSend;
			}
;
		l18:	/* end case */;
			break;
		case 187:
			/* bytecodePrimMakePoint */
			{
				sqInt oop;
				sqInt argument;
				sqInt pt;
				sqInt rcvr;
				sqInt pointResult;
				sqInt pointResult1;
				sqInt pointResult2;
				sqInt sp;
				/* begin initPrimCall */
				primFailCode = 0;
				/* begin externalizeIPandSP */
				instructionPointer = (usqInt)oopForPointer(localIP);
				stackPointer = (usqInt)oopForPointer(localSP);
				theHomeContext = localHomeContext;
				/* begin primitiveMakePoint */
				argument = longAt(stackPointer);
				rcvr = longAt(stackPointer - (1 * (BYTES_PER_WORD)));
				if ((rcvr & 1)) {
					if ((argument & 1)) {
						/* begin makePointwithxValue:yValue: */
						pointResult = instantiateSmallClasssizeInBytes(longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassPoint << (SHIFT_FOR_WORD))), 3 * (BYTES_PER_WORD));
						longAtput((pointResult + (BASE_HEADER_SIZE)) + (XIndex << (SHIFT_FOR_WORD)), ((((rcvr >> 1)) << 1) | 1));
						longAtput((pointResult + (BASE_HEADER_SIZE)) + (YIndex << (SHIFT_FOR_WORD)), ((((argument >> 1)) << 1) | 1));
						pt = pointResult;
					} else {
						/* begin makePointwithxValue:yValue: */
						pointResult1 = instantiateSmallClasssizeInBytes(longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassPoint << (SHIFT_FOR_WORD))), 3 * (BYTES_PER_WORD));
						longAtput((pointResult1 + (BASE_HEADER_SIZE)) + (XIndex << (SHIFT_FOR_WORD)), ((((rcvr >> 1)) << 1) | 1));
						longAtput((pointResult1 + (BASE_HEADER_SIZE)) + (YIndex << (SHIFT_FOR_WORD)), ((0 << 1) | 1));
						pt = pointResult1;
						/* begin storePointer:ofObject:withValue: */
						if ((((usqInt) pt)) < (((usqInt) youngStart))) {
							possibleRootStoreIntovalue(pt, longAt(stackPointer - (0 * (BYTES_PER_WORD))));
						}
						longAtput((pt + (BASE_HEADER_SIZE)) + (1 << (SHIFT_FOR_WORD)), longAt(stackPointer - (0 * (BYTES_PER_WORD))));
					}
				} else {
					if (!((fetchClassOf(rcvr)) == (longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassFloat << (SHIFT_FOR_WORD)))))) {
						/* begin success: */
						if (!(0)) {
							if (!primFailCode) {
								primFailCode = 1;
							}
						}
						goto l20;
					}
					/* begin makePointwithxValue:yValue: */
					pointResult2 = instantiateSmallClasssizeInBytes(longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassPoint << (SHIFT_FOR_WORD))), 3 * (BYTES_PER_WORD));
					longAtput((pointResult2 + (BASE_HEADER_SIZE)) + (XIndex << (SHIFT_FOR_WORD)), ((0 << 1) | 1));
					longAtput((pointResult2 + (BASE_HEADER_SIZE)) + (YIndex << (SHIFT_FOR_WORD)), ((0 << 1) | 1));
					pt = pointResult2;
					/* begin storePointer:ofObject:withValue: */
					if ((((usqInt) pt)) < (((usqInt) youngStart))) {
						possibleRootStoreIntovalue(pt, longAt(stackPointer - (1 * (BYTES_PER_WORD))));
					}
					longAtput((pt + (BASE_HEADER_SIZE)) + (0 << (SHIFT_FOR_WORD)), longAt(stackPointer - (1 * (BYTES_PER_WORD))));
					/* begin storePointer:ofObject:withValue: */
					if ((((usqInt) pt)) < (((usqInt) youngStart))) {
						possibleRootStoreIntovalue(pt, longAt(stackPointer - (0 * (BYTES_PER_WORD))));
					}
					longAtput((pt + (BASE_HEADER_SIZE)) + (1 << (SHIFT_FOR_WORD)), longAt(stackPointer - (0 * (BYTES_PER_WORD))));
				}
				/* begin pop:thenPush: */
				longAtput((sp = stackPointer - ((2 - 1) * (BYTES_PER_WORD))), pt);
				stackPointer = sp;
			l20:	/* end primitiveMakePoint */;
				/* begin internalizeIPandSP */
				localIP = pointerForOop(instructionPointer);
				localSP = pointerForOop(stackPointer);
				localHomeContext = theHomeContext;
				if (!primFailCode) {
					/* begin fetchNextBytecode */
					currentBytecode = byteAtPointer(++localIP);
					goto l19;
				}
				/* begin fetchPointer:ofObject: */
				oop = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (SpecialSelectors << (SHIFT_FOR_WORD)));
				messageSelector = longAt((oop + (BASE_HEADER_SIZE)) + ((11 * 2) << (SHIFT_FOR_WORD)));
				argumentCount = 1;
				goto normalSend;
			}
;
		l19:	/* end case */;
			break;
		case 188:
			/* bytecodePrimBitShift */
			{
				sqInt oop;
				/* begin initPrimCall */
				primFailCode = 0;
				/* begin externalizeIPandSP */
				instructionPointer = (usqInt)oopForPointer(localIP);
				stackPointer = (usqInt)oopForPointer(localSP);
				theHomeContext = localHomeContext;
				primitiveBitShift();
				/* begin internalizeIPandSP */
				localIP = pointerForOop(instructionPointer);
				localSP = pointerForOop(stackPointer);
				localHomeContext = theHomeContext;
				if (!primFailCode) {
					/* begin fetchNextBytecode */
					currentBytecode = byteAtPointer(++localIP);
					goto l21;
				}
				/* begin fetchPointer:ofObject: */
				oop = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (SpecialSelectors << (SHIFT_FOR_WORD)));
				messageSelector = longAt((oop + (BASE_HEADER_SIZE)) + ((12 * 2) << (SHIFT_FOR_WORD)));
				argumentCount = 1;
				goto normalSend;
			}
;
		l21:	/* end case */;
			break;
		case 189:
			/* bytecodePrimDiv */
			{
				sqInt quotient;
				sqInt oop;
				/* begin initPrimCall */
				primFailCode = 0;
				quotient = doPrimitiveDivby(longAtPointer(localSP - (1 * (BYTES_PER_WORD))), longAtPointer(localSP - (0 * (BYTES_PER_WORD))));
				if (!primFailCode) {
					/* begin internalPop:thenPush: */
					longAtPointerput((localSP -= (2 - 1) * (BYTES_PER_WORD)), ((quotient << 1) | 1));
					/* begin fetchNextBytecode */
					currentBytecode = byteAtPointer(++localIP);
					goto l22;
				}
				/* begin fetchPointer:ofObject: */
				oop = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (SpecialSelectors << (SHIFT_FOR_WORD)));
				messageSelector = longAt((oop + (BASE_HEADER_SIZE)) + ((13 * 2) << (SHIFT_FOR_WORD)));
				argumentCount = 1;
				goto normalSend;
			}
;
		l22:	/* end case */;
			break;
		case 190:
			/* bytecodePrimBitAnd */
			{
				sqInt oop;
				sqInt integerArgument;
				sqInt integerReceiver;
				sqInt object;
				sqInt sp;
				sqInt top;
				sqInt top1;
				sqInt top2;
				sqInt top11;
				/* begin initPrimCall */
				primFailCode = 0;
				/* begin externalizeIPandSP */
				instructionPointer = (usqInt)oopForPointer(localIP);
				stackPointer = (usqInt)oopForPointer(localSP);
				theHomeContext = localHomeContext;
				/* begin primitiveBitAnd */
				/* begin popPos32BitInteger */
				/* begin popStack */
				top1 = longAt(stackPointer);
				stackPointer -= BYTES_PER_WORD;
				top = top1;
				integerArgument = positive32BitValueOf(top);
				/* begin popPos32BitInteger */
				/* begin popStack */
				top11 = longAt(stackPointer);
				stackPointer -= BYTES_PER_WORD;
				top2 = top11;
				integerReceiver = positive32BitValueOf(top2);
				if (!primFailCode) {
					/* begin push: */
					object = positive32BitIntegerFor(integerReceiver & integerArgument);
					longAtput((sp = stackPointer + (BYTES_PER_WORD)), object);
					stackPointer = sp;
				} else {
					/* begin unPop: */
					stackPointer += 2 * (BYTES_PER_WORD);
				}
				/* begin internalizeIPandSP */
				localIP = pointerForOop(instructionPointer);
				localSP = pointerForOop(stackPointer);
				localHomeContext = theHomeContext;
				if (!primFailCode) {
					/* begin fetchNextBytecode */
					currentBytecode = byteAtPointer(++localIP);
					goto l23;
				}
				/* begin fetchPointer:ofObject: */
				oop = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (SpecialSelectors << (SHIFT_FOR_WORD)));
				messageSelector = longAt((oop + (BASE_HEADER_SIZE)) + ((14 * 2) << (SHIFT_FOR_WORD)));
				argumentCount = 1;
				goto normalSend;
			}
;
		l23:	/* end case */;
			break;
		case 191:
			/* bytecodePrimBitOr */
			{
				sqInt oop;
				sqInt integerArgument;
				sqInt integerReceiver;
				sqInt object;
				sqInt sp;
				sqInt top;
				sqInt top1;
				sqInt top2;
				sqInt top11;
				/* begin initPrimCall */
				primFailCode = 0;
				/* begin externalizeIPandSP */
				instructionPointer = (usqInt)oopForPointer(localIP);
				stackPointer = (usqInt)oopForPointer(localSP);
				theHomeContext = localHomeContext;
				/* begin primitiveBitOr */
				/* begin popPos32BitInteger */
				/* begin popStack */
				top1 = longAt(stackPointer);
				stackPointer -= BYTES_PER_WORD;
				top = top1;
				integerArgument = positive32BitValueOf(top);
				/* begin popPos32BitInteger */
				/* begin popStack */
				top11 = longAt(stackPointer);
				stackPointer -= BYTES_PER_WORD;
				top2 = top11;
				integerReceiver = positive32BitValueOf(top2);
				if (!primFailCode) {
					/* begin push: */
					object = positive32BitIntegerFor(integerReceiver | integerArgument);
					longAtput((sp = stackPointer + (BYTES_PER_WORD)), object);
					stackPointer = sp;
				} else {
					/* begin unPop: */
					stackPointer += 2 * (BYTES_PER_WORD);
				}
				/* begin internalizeIPandSP */
				localIP = pointerForOop(instructionPointer);
				localSP = pointerForOop(stackPointer);
				localHomeContext = theHomeContext;
				if (!primFailCode) {
					/* begin fetchNextBytecode */
					currentBytecode = byteAtPointer(++localIP);
					goto l24;
				}
				/* begin fetchPointer:ofObject: */
				oop = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (SpecialSelectors << (SHIFT_FOR_WORD)));
				messageSelector = longAt((oop + (BASE_HEADER_SIZE)) + ((15 * 2) << (SHIFT_FOR_WORD)));
				argumentCount = 1;
				goto normalSend;
			}
;
		l24:	/* end case */;
			break;
		case 192:
			/* bytecodePrimAt */
			{
				sqInt atIx;
				sqInt index;
				sqInt rcvr;
				sqInt result;
				sqInt oop;
				sqInt fixedFields;
				sqInt fmt;
				sqInt result1;
				sqInt stSize;
				sqInt oop1;
				index = longAtPointer(localSP);
				rcvr = longAtPointer(localSP - (1 * (BYTES_PER_WORD)));
				if ((!((rcvr & 1))) && ((index & 1))) {
					atIx = rcvr & AtCacheMask;
					if ((atCache[atIx + AtCacheOop]) == rcvr) {
						/* begin commonVariableInternal:at:cacheIndex: */
						stSize = atCache[atIx + AtCacheSize];
						if (((((usqInt) ((index >> 1)))) >= (((usqInt) 1))) && ((((usqInt) ((index >> 1)))) <= (((usqInt) stSize)))) {
							fmt = atCache[atIx + AtCacheFmt];
							if (fmt <= 4) {
								fixedFields = atCache[atIx + AtCacheFixedFields];
								result = longAt((rcvr + (BASE_HEADER_SIZE)) + (((((index >> 1)) + fixedFields) - 1) << (SHIFT_FOR_WORD)));
								goto l26;
							}
							if (fmt < 8) {
								result1 = long32At((rcvr + (BASE_HEADER_SIZE)) + ((((index >> 1)) - 1) << 2));
								/* begin externalizeIPandSP */
								instructionPointer = (usqInt)oopForPointer(localIP);
								stackPointer = (usqInt)oopForPointer(localSP);
								theHomeContext = localHomeContext;
								result1 = positive32BitIntegerFor(result1);
								/* begin internalizeIPandSP */
								localIP = pointerForOop(instructionPointer);
								localSP = pointerForOop(stackPointer);
								localHomeContext = theHomeContext;
								result = result1;
								goto l26;
							}
							if (fmt >= 16) {
								/* begin fetchPointer:ofObject: */
								oop1 = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (CharacterTable << (SHIFT_FOR_WORD)));
								result = longAt((oop1 + (BASE_HEADER_SIZE)) + ((byteAt((rcvr + (BASE_HEADER_SIZE)) + (((index >> 1)) - 1))) << (SHIFT_FOR_WORD)));
								goto l26;
							} else {
								result = (((byteAt((rcvr + (BASE_HEADER_SIZE)) + (((index >> 1)) - 1))) << 1) | 1);
								goto l26;
							}
						}
						/* begin primitiveFail */
						if (primFailCode == 0) {
							primFailCode = 1;
						}
					l26:	/* end commonVariableInternal:at:cacheIndex: */;
						if (!primFailCode) {
							/* begin fetchNextBytecode */
							currentBytecode = byteAtPointer(++localIP);
							/* begin internalPop:thenPush: */
							longAtPointerput((localSP -= (2 - 1) * (BYTES_PER_WORD)), result);
							goto l25;
						}
					}
				} else {
					/* begin primitiveFail */
					if (primFailCode == 0) {
						primFailCode = 1;
					}
				}
				/* begin fetchPointer:ofObject: */
				oop = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (SpecialSelectors << (SHIFT_FOR_WORD)));
				messageSelector = longAt((oop + (BASE_HEADER_SIZE)) + ((16 * 2) << (SHIFT_FOR_WORD)));
				argumentCount = 1;
				goto normalSend;
			}
;
		l25:	/* end case */;
			break;
		case 193:
			/* bytecodePrimAtPut */
			{
				sqInt atIx;
				sqInt index;
				sqInt rcvr;
				sqInt value;
				sqInt oop;
				sqInt fixedFields;
				sqInt fmt;
				sqInt stSize;
				sqInt valToPut;
				value = longAtPointer(localSP);
				index = longAtPointer(localSP - (1 * (BYTES_PER_WORD)));
				rcvr = longAtPointer(localSP - (2 * (BYTES_PER_WORD)));
				if ((!((rcvr & 1))) && ((index & 1))) {
					atIx = (rcvr & AtCacheMask) + AtPutBase;
					if ((atCache[atIx + AtCacheOop]) == rcvr) {
						/* begin commonVariable:at:put:cacheIndex: */
						stSize = atCache[atIx + AtCacheSize];
						if (((((usqInt) ((index >> 1)))) >= (((usqInt) 1))) && ((((usqInt) ((index >> 1)))) <= (((usqInt) stSize)))) {
							fmt = atCache[atIx + AtCacheFmt];
							if (fmt <= 4) {
								fixedFields = atCache[atIx + AtCacheFixedFields];
								/* begin storePointer:ofObject:withValue: */
								if ((((usqInt) rcvr)) < (((usqInt) youngStart))) {
									possibleRootStoreIntovalue(rcvr, value);
								}
								longAtput((rcvr + (BASE_HEADER_SIZE)) + (((((index >> 1)) + fixedFields) - 1) << (SHIFT_FOR_WORD)), value);
								goto l28;
							}
							if (fmt < 8) {
								valToPut = positive32BitValueOf(value);
								if (!primFailCode) {
									long32Atput((rcvr + (BASE_HEADER_SIZE)) + ((((index >> 1)) - 1) << 2), valToPut);
								}
								goto l28;
							}
							if (fmt >= 16) {
								valToPut = asciiOfCharacter(value);
								if (!(!primFailCode)) {
									goto l28;
								}
							} else {
								valToPut = value;
							}
							if ((valToPut & 1)) {
								valToPut = (valToPut >> 1);
								if (!((valToPut >= 0) && (valToPut <= 255))) {
									/* begin primitiveFail */
									if (primFailCode == 0) {
										primFailCode = 1;
									}
									goto l28;
								}
								byteAtput((rcvr + (BASE_HEADER_SIZE)) + (((index >> 1)) - 1), valToPut);
								goto l28;
							}
						}
						/* begin primitiveFail */
						if (primFailCode == 0) {
							primFailCode = 1;
						}
					l28:	/* end commonVariable:at:put:cacheIndex: */;
						if (!primFailCode) {
							/* begin fetchNextBytecode */
							currentBytecode = byteAtPointer(++localIP);
							/* begin internalPop:thenPush: */
							longAtPointerput((localSP -= (3 - 1) * (BYTES_PER_WORD)), value);
							goto l27;
						}
					}
				} else {
					/* begin primitiveFail */
					if (primFailCode == 0) {
						primFailCode = 1;
					}
				}
				/* begin fetchPointer:ofObject: */
				oop = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (SpecialSelectors << (SHIFT_FOR_WORD)));
				messageSelector = longAt((oop + (BASE_HEADER_SIZE)) + ((17 * 2) << (SHIFT_FOR_WORD)));
				argumentCount = 2;
				goto normalSend;
			}
;
		l27:	/* end case */;
			break;
		case 194:
			/* bytecodePrimSize */
			{
				sqInt oop;
				/* begin fetchPointer:ofObject: */
				oop = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (SpecialSelectors << (SHIFT_FOR_WORD)));
				messageSelector = longAt((oop + (BASE_HEADER_SIZE)) + ((18 * 2) << (SHIFT_FOR_WORD)));
				argumentCount = 0;
				goto normalSend;
			}
;
			break;
		case 195:
			/* bytecodePrimNext */
			{
				sqInt oop;
				/* begin fetchPointer:ofObject: */
				oop = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (SpecialSelectors << (SHIFT_FOR_WORD)));
				messageSelector = longAt((oop + (BASE_HEADER_SIZE)) + ((19 * 2) << (SHIFT_FOR_WORD)));
				argumentCount = 0;
				goto normalSend;
			}
;
			break;
		case 196:
			/* bytecodePrimNextPut */
			{
				sqInt oop;
				/* begin fetchPointer:ofObject: */
				oop = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (SpecialSelectors << (SHIFT_FOR_WORD)));
				messageSelector = longAt((oop + (BASE_HEADER_SIZE)) + ((20 * 2) << (SHIFT_FOR_WORD)));
				argumentCount = 1;
				goto normalSend;
			}
;
			break;
		case 197:
			/* bytecodePrimAtEnd */
			{
				sqInt oop;
				/* begin fetchPointer:ofObject: */
				oop = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (SpecialSelectors << (SHIFT_FOR_WORD)));
				messageSelector = longAt((oop + (BASE_HEADER_SIZE)) + ((21 * 2) << (SHIFT_FOR_WORD)));
				argumentCount = 0;
				goto normalSend;
			}
;
			break;
		case 198:
			/* bytecodePrimEquivalent */
			{
				sqInt arg;
				sqInt rcvr;
				sqInt bytecode;
				sqInt offset;
				rcvr = longAtPointer(localSP - (1 * (BYTES_PER_WORD)));
				arg = longAtPointer(localSP - (0 * (BYTES_PER_WORD)));
				/* begin booleanCheat: */
				bytecode = byteAtPointer(++localIP);
				/* begin internalPop: */
				localSP -= 2 * (BYTES_PER_WORD);
				if ((bytecode < 160) && (bytecode > 151)) {
					if (rcvr == arg) {
						/* begin fetchNextBytecode */
						currentBytecode = byteAtPointer(++localIP);
						goto l29;
					} else {
						/* begin jump: */
						localIP = (localIP + (bytecode - 151)) + 1;
						currentBytecode = byteAtPointer(localIP);
						goto l29;
					}
				}
				if (bytecode == 172) {
					offset = byteAtPointer(++localIP);
					if (rcvr == arg) {
						/* begin fetchNextBytecode */
						currentBytecode = byteAtPointer(++localIP);
						goto l29;
					} else {
						/* begin jump: */
						localIP = (localIP + offset) + 1;
						currentBytecode = byteAtPointer(localIP);
						goto l29;
					}
				}
				localIP -= 1;
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				if (rcvr == arg) {
					/* begin internalPush: */
					longAtPointerput((localSP += BYTES_PER_WORD), trueObj);
				} else {
					/* begin internalPush: */
					longAtPointerput((localSP += BYTES_PER_WORD), falseObj);
				}
			l29:	/* end booleanCheat: */;
			}
;
			break;
		case 199:
			/* bytecodePrimClass */
			{
				sqInt rcvr;
				sqInt oop;
				sqInt ccIndex;
				sqInt oop1;
				rcvr = longAtPointer(localSP);
				/* begin internalPop:thenPush: */
				/* begin fetchClassOf: */
				if ((rcvr & 1)) {
					oop = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassInteger << (SHIFT_FOR_WORD)));
					goto l30;
				}
				ccIndex = (((usqInt) (longAt(rcvr))) >> 12) & 31;
				if (ccIndex == 0) {
					oop = (longAt(rcvr - (BASE_HEADER_SIZE))) & (ALL_BUT_TYPE_MASK);
					goto l30;
				} else {
					/* begin fetchPointer:ofObject: */
					oop1 = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (CompactClasses << (SHIFT_FOR_WORD)));
					oop = longAt((oop1 + (BASE_HEADER_SIZE)) + ((ccIndex - 1) << (SHIFT_FOR_WORD)));
					goto l30;
				}
			l30:	/* end fetchClassOf: */;
				longAtPointerput((localSP -= (1 - 1) * (BYTES_PER_WORD)), oop);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
			}
;
			break;
		case 200:
			/* bytecodePrimBlockCopy */
			{
				sqInt hdr;
				sqInt rcvr;
				sqInt oop;
				sqInt successBoolean;
				sqInt context;
				sqInt contextSize;
				sqInt initialIP;
				sqInt methodContext;
				sqInt newContext;
				sqInt header;
				sqInt oop1;
				sqInt sp;
				rcvr = longAtPointer(localSP - (1 * (BYTES_PER_WORD)));
				/* begin initPrimCall */
				primFailCode = 0;
				hdr = longAt(rcvr);
				/* begin success: */
				successBoolean = (((((usqInt) hdr) >> 12) & 31) == 13) || ((((((usqInt) hdr) >> 12) & 31) == 14) || (((((usqInt) hdr) >> 12) & 31) == 4));
				if (!(successBoolean)) {
					if (!primFailCode) {
						primFailCode = 1;
					}
				}
				if (!primFailCode) {
					/* begin externalizeIPandSP */
					instructionPointer = (usqInt)oopForPointer(localIP);
					stackPointer = (usqInt)oopForPointer(localSP);
					theHomeContext = localHomeContext;
					/* begin primitiveBlockCopy */
					context = longAt(stackPointer - (1 * (BYTES_PER_WORD)));
					if (((longAt((context + (BASE_HEADER_SIZE)) + (MethodIndex << (SHIFT_FOR_WORD)))) & 1)) {
						methodContext = longAt((context + (BASE_HEADER_SIZE)) + (HomeIndex << (SHIFT_FOR_WORD)));
					} else {
						methodContext = context;
					}
					/* begin sizeBitsOf: */
					header = longAt(methodContext);
					if ((header & TypeMask) == HeaderTypeSizeAndClass) {
						contextSize = (longAt(methodContext - ((BYTES_PER_WORD) * 2))) & (LONG_SIZE_MASK);
						goto l32;
					} else {
						contextSize = header & (SIZE_MASK);
						goto l32;
					}
				l32:	/* end sizeBitsOf: */;
					context = null;
					/* begin pushRemappableOop: */
					remapBuffer[(remapBufferCount += 1)] = methodContext;
					newContext = instantiateContextsizeInBytes(longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassBlockContext << (SHIFT_FOR_WORD))), contextSize);
					/* begin popRemappableOop */
					oop1 = remapBuffer[remapBufferCount];
					remapBufferCount -= 1;
					methodContext = oop1;
					initialIP = (((((instructionPointer + 1) + 3) - (method + (BASE_HEADER_SIZE))) << 1) | 1);
					longAtput((newContext + (BASE_HEADER_SIZE)) + (InitialIPIndex << (SHIFT_FOR_WORD)), initialIP);
					longAtput((newContext + (BASE_HEADER_SIZE)) + (InstructionPointerIndex << (SHIFT_FOR_WORD)), initialIP);
					/* begin storeStackPointerValue:inContext: */
					longAtput((newContext + (BASE_HEADER_SIZE)) + (StackPointerIndex << (SHIFT_FOR_WORD)), ((0 << 1) | 1));
					longAtput((newContext + (BASE_HEADER_SIZE)) + (BlockArgumentCountIndex << (SHIFT_FOR_WORD)), longAt(stackPointer - (0 * (BYTES_PER_WORD))));
					longAtput((newContext + (BASE_HEADER_SIZE)) + (HomeIndex << (SHIFT_FOR_WORD)), methodContext);
					longAtput((newContext + (BASE_HEADER_SIZE)) + (SenderIndex << (SHIFT_FOR_WORD)), nilObj);
					/* begin pop:thenPush: */
					longAtput((sp = stackPointer - ((2 - 1) * (BYTES_PER_WORD))), newContext);
					stackPointer = sp;
					/* begin internalizeIPandSP */
					localIP = pointerForOop(instructionPointer);
					localSP = pointerForOop(stackPointer);
					localHomeContext = theHomeContext;
				}
				if (!(!primFailCode)) {
					/* begin fetchPointer:ofObject: */
					oop = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (SpecialSelectors << (SHIFT_FOR_WORD)));
					messageSelector = longAt((oop + (BASE_HEADER_SIZE)) + ((24 * 2) << (SHIFT_FOR_WORD)));
					argumentCount = 1;
					goto normalSend;
					goto l31;
				}
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
			}
;
		l31:	/* end case */;
			break;
		case 201:
			/* bytecodePrimValue */
			{
				sqInt maybeBlock;
				sqInt rcvrClass;
				sqInt oop;
				sqInt ccIndex;
				sqInt oop1;
				maybeBlock = longAtPointer(localSP);
				argumentCount = 0;
				/* begin initPrimCall */
				primFailCode = 0;
				if ((maybeBlock & 1) == 0) {
					/* begin fetchClassOfNonInt: */
					ccIndex = (((usqInt) (longAt(maybeBlock))) >> 12) & 31;
					if (ccIndex == 0) {
						rcvrClass = (longAt(maybeBlock - (BASE_HEADER_SIZE))) & (ALL_BUT_TYPE_MASK);
						goto l34;
					} else {
						/* begin fetchPointer:ofObject: */
						oop1 = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (CompactClasses << (SHIFT_FOR_WORD)));
						rcvrClass = longAt((oop1 + (BASE_HEADER_SIZE)) + ((ccIndex - 1) << (SHIFT_FOR_WORD)));
						goto l34;
					}
				l34:	/* end fetchClassOfNonInt: */;
					if (rcvrClass == (longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassBlockClosure << (SHIFT_FOR_WORD))))) {
						/* begin externalizeIPandSP */
						instructionPointer = (usqInt)oopForPointer(localIP);
						stackPointer = (usqInt)oopForPointer(localSP);
						theHomeContext = localHomeContext;
						primitiveClosureValue();
						/* begin internalizeIPandSP */
						localIP = pointerForOop(instructionPointer);
						localSP = pointerForOop(stackPointer);
						localHomeContext = theHomeContext;
					} else {
						if (rcvrClass == (longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassBlockContext << (SHIFT_FOR_WORD))))) {
							/* begin externalizeIPandSP */
							instructionPointer = (usqInt)oopForPointer(localIP);
							stackPointer = (usqInt)oopForPointer(localSP);
							theHomeContext = localHomeContext;
							primitiveValue();
							/* begin internalizeIPandSP */
							localIP = pointerForOop(instructionPointer);
							localSP = pointerForOop(stackPointer);
							localHomeContext = theHomeContext;
						} else {
							/* begin primitiveFail */
							if (primFailCode == 0) {
								primFailCode = 1;
							}
						}
					}
				}
				if (!(!primFailCode)) {
					/* begin fetchPointer:ofObject: */
					oop = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (SpecialSelectors << (SHIFT_FOR_WORD)));
					messageSelector = longAt((oop + (BASE_HEADER_SIZE)) + ((25 * 2) << (SHIFT_FOR_WORD)));
					goto normalSend;
					goto l33;
				}
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
			}
;
		l33:	/* end case */;
			break;
		case 202:
			/* bytecodePrimValueWithArg */
			{
				sqInt maybeBlock;
				sqInt rcvrClass;
				sqInt oop;
				sqInt ccIndex;
				sqInt oop1;
				maybeBlock = longAtPointer(localSP - (1 * (BYTES_PER_WORD)));
				argumentCount = 1;
				/* begin initPrimCall */
				primFailCode = 0;
				if ((maybeBlock & 1) == 0) {
					/* begin fetchClassOfNonInt: */
					ccIndex = (((usqInt) (longAt(maybeBlock))) >> 12) & 31;
					if (ccIndex == 0) {
						rcvrClass = (longAt(maybeBlock - (BASE_HEADER_SIZE))) & (ALL_BUT_TYPE_MASK);
						goto l36;
					} else {
						/* begin fetchPointer:ofObject: */
						oop1 = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (CompactClasses << (SHIFT_FOR_WORD)));
						rcvrClass = longAt((oop1 + (BASE_HEADER_SIZE)) + ((ccIndex - 1) << (SHIFT_FOR_WORD)));
						goto l36;
					}
				l36:	/* end fetchClassOfNonInt: */;
					if (rcvrClass == (longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassBlockClosure << (SHIFT_FOR_WORD))))) {
						/* begin externalizeIPandSP */
						instructionPointer = (usqInt)oopForPointer(localIP);
						stackPointer = (usqInt)oopForPointer(localSP);
						theHomeContext = localHomeContext;
						primitiveClosureValue();
						/* begin internalizeIPandSP */
						localIP = pointerForOop(instructionPointer);
						localSP = pointerForOop(stackPointer);
						localHomeContext = theHomeContext;
					} else {
						if (rcvrClass == (longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassBlockContext << (SHIFT_FOR_WORD))))) {
							/* begin externalizeIPandSP */
							instructionPointer = (usqInt)oopForPointer(localIP);
							stackPointer = (usqInt)oopForPointer(localSP);
							theHomeContext = localHomeContext;
							primitiveValue();
							/* begin internalizeIPandSP */
							localIP = pointerForOop(instructionPointer);
							localSP = pointerForOop(stackPointer);
							localHomeContext = theHomeContext;
						} else {
							/* begin primitiveFail */
							if (primFailCode == 0) {
								primFailCode = 1;
							}
						}
					}
				}
				if (!(!primFailCode)) {
					/* begin fetchPointer:ofObject: */
					oop = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (SpecialSelectors << (SHIFT_FOR_WORD)));
					messageSelector = longAt((oop + (BASE_HEADER_SIZE)) + ((26 * 2) << (SHIFT_FOR_WORD)));
					goto normalSend;
					goto l35;
				}
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
			}
;
		l35:	/* end case */;
			break;
		case 203:
			/* bytecodePrimDo */
			{
				sqInt oop;
				/* begin fetchPointer:ofObject: */
				oop = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (SpecialSelectors << (SHIFT_FOR_WORD)));
				messageSelector = longAt((oop + (BASE_HEADER_SIZE)) + ((27 * 2) << (SHIFT_FOR_WORD)));
				argumentCount = 1;
				goto normalSend;
			}
;
			break;
		case 204:
			/* bytecodePrimNew */
			{
				sqInt oop;
				/* begin fetchPointer:ofObject: */
				oop = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (SpecialSelectors << (SHIFT_FOR_WORD)));
				messageSelector = longAt((oop + (BASE_HEADER_SIZE)) + ((28 * 2) << (SHIFT_FOR_WORD)));
				argumentCount = 0;
				goto normalSend;
			}
;
			break;
		case 205:
			/* bytecodePrimNewWithArg */
			{
				sqInt oop;
				/* begin fetchPointer:ofObject: */
				oop = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (SpecialSelectors << (SHIFT_FOR_WORD)));
				messageSelector = longAt((oop + (BASE_HEADER_SIZE)) + ((29 * 2) << (SHIFT_FOR_WORD)));
				argumentCount = 1;
				goto normalSend;
			}
;
			break;
		case 206:
			/* bytecodePrimPointX */
			{
				sqInt rcvr;
				sqInt oop;
				sqInt oop1;
				sqInt classOop;
				sqInt ccIndex;
				sqInt cl;
				sqInt oop11;
				/* begin initPrimCall */
				primFailCode = 0;
				rcvr = longAtPointer(localSP);
				/* begin assertClassOf:is: */
				classOop = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassPoint << (SHIFT_FOR_WORD)));
				if ((rcvr & 1)) {
					/* begin primitiveFail */
					if (primFailCode == 0) {
						primFailCode = 1;
					}
					goto l38;
				}
				ccIndex = (((usqInt) (longAt(rcvr))) >> 12) & 31;
				if (ccIndex == 0) {
					cl = (longAt(rcvr - (BASE_HEADER_SIZE))) & (ALL_BUT_TYPE_MASK);
				} else {
					/* begin fetchPointer:ofObject: */
					oop11 = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (CompactClasses << (SHIFT_FOR_WORD)));
					cl = longAt((oop11 + (BASE_HEADER_SIZE)) + ((ccIndex - 1) << (SHIFT_FOR_WORD)));
				}
				/* begin success: */
				if (!(cl == classOop)) {
					if (!primFailCode) {
						primFailCode = 1;
					}
				}
			l38:	/* end assertClassOf:is: */;
				if (!primFailCode) {
					/* begin internalPop:thenPush: */
					oop = longAt((rcvr + (BASE_HEADER_SIZE)) + (XIndex << (SHIFT_FOR_WORD)));
					longAtPointerput((localSP -= (1 - 1) * (BYTES_PER_WORD)), oop);
					/* begin fetchNextBytecode */
					currentBytecode = byteAtPointer(++localIP);
					goto l37;
				}
				/* begin fetchPointer:ofObject: */
				oop1 = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (SpecialSelectors << (SHIFT_FOR_WORD)));
				messageSelector = longAt((oop1 + (BASE_HEADER_SIZE)) + ((30 * 2) << (SHIFT_FOR_WORD)));
				argumentCount = 0;
				goto normalSend;
			}
;
		l37:	/* end case */;
			break;
		case 207:
			/* bytecodePrimPointY */
			{
				sqInt rcvr;
				sqInt oop;
				sqInt oop1;
				sqInt classOop;
				sqInt ccIndex;
				sqInt cl;
				sqInt oop11;
				/* begin initPrimCall */
				primFailCode = 0;
				rcvr = longAtPointer(localSP);
				/* begin assertClassOf:is: */
				classOop = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassPoint << (SHIFT_FOR_WORD)));
				if ((rcvr & 1)) {
					/* begin primitiveFail */
					if (primFailCode == 0) {
						primFailCode = 1;
					}
					goto l40;
				}
				ccIndex = (((usqInt) (longAt(rcvr))) >> 12) & 31;
				if (ccIndex == 0) {
					cl = (longAt(rcvr - (BASE_HEADER_SIZE))) & (ALL_BUT_TYPE_MASK);
				} else {
					/* begin fetchPointer:ofObject: */
					oop11 = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (CompactClasses << (SHIFT_FOR_WORD)));
					cl = longAt((oop11 + (BASE_HEADER_SIZE)) + ((ccIndex - 1) << (SHIFT_FOR_WORD)));
				}
				/* begin success: */
				if (!(cl == classOop)) {
					if (!primFailCode) {
						primFailCode = 1;
					}
				}
			l40:	/* end assertClassOf:is: */;
				if (!primFailCode) {
					/* begin internalPop:thenPush: */
					oop = longAt((rcvr + (BASE_HEADER_SIZE)) + (YIndex << (SHIFT_FOR_WORD)));
					longAtPointerput((localSP -= (1 - 1) * (BYTES_PER_WORD)), oop);
					/* begin fetchNextBytecode */
					currentBytecode = byteAtPointer(++localIP);
					goto l39;
				}
				/* begin fetchPointer:ofObject: */
				oop1 = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (SpecialSelectors << (SHIFT_FOR_WORD)));
				messageSelector = longAt((oop1 + (BASE_HEADER_SIZE)) + ((31 * 2) << (SHIFT_FOR_WORD)));
				argumentCount = 0;
				goto normalSend;
			}
;
		l39:	/* end case */;
			break;
		case 208:
			/* sendLiteralSelectorBytecode */
			{
				messageSelector = longAt((method + (BASE_HEADER_SIZE)) + (((208 & 15) + LiteralStart) << (SHIFT_FOR_WORD)));
				argumentCount = ((((usqInt) 208) >> 4) & 3) - 1;
				goto normalSend;
			}
;
			break;
		case 209:
			/* sendLiteralSelectorBytecode */
			{
				messageSelector = longAt((method + (BASE_HEADER_SIZE)) + (((209 & 15) + LiteralStart) << (SHIFT_FOR_WORD)));
				argumentCount = ((((usqInt) 209) >> 4) & 3) - 1;
				goto normalSend;
			}
;
			break;
		case 210:
			/* sendLiteralSelectorBytecode */
			{
				messageSelector = longAt((method + (BASE_HEADER_SIZE)) + (((210 & 15) + LiteralStart) << (SHIFT_FOR_WORD)));
				argumentCount = ((((usqInt) 210) >> 4) & 3) - 1;
				goto normalSend;
			}
;
			break;
		case 211:
			/* sendLiteralSelectorBytecode */
			{
				messageSelector = longAt((method + (BASE_HEADER_SIZE)) + (((211 & 15) + LiteralStart) << (SHIFT_FOR_WORD)));
				argumentCount = ((((usqInt) 211) >> 4) & 3) - 1;
				goto normalSend;
			}
;
			break;
		case 212:
			/* sendLiteralSelectorBytecode */
			{
				messageSelector = longAt((method + (BASE_HEADER_SIZE)) + (((212 & 15) + LiteralStart) << (SHIFT_FOR_WORD)));
				argumentCount = ((((usqInt) 212) >> 4) & 3) - 1;
				goto normalSend;
			}
;
			break;
		case 213:
			/* sendLiteralSelectorBytecode */
			{
				messageSelector = longAt((method + (BASE_HEADER_SIZE)) + (((213 & 15) + LiteralStart) << (SHIFT_FOR_WORD)));
				argumentCount = ((((usqInt) 213) >> 4) & 3) - 1;
				goto normalSend;
			}
;
			break;
		case 214:
			/* sendLiteralSelectorBytecode */
			{
				messageSelector = longAt((method + (BASE_HEADER_SIZE)) + (((214 & 15) + LiteralStart) << (SHIFT_FOR_WORD)));
				argumentCount = ((((usqInt) 214) >> 4) & 3) - 1;
				goto normalSend;
			}
;
			break;
		case 215:
			/* sendLiteralSelectorBytecode */
			{
				messageSelector = longAt((method + (BASE_HEADER_SIZE)) + (((215 & 15) + LiteralStart) << (SHIFT_FOR_WORD)));
				argumentCount = ((((usqInt) 215) >> 4) & 3) - 1;
				goto normalSend;
			}
;
			break;
		case 216:
			/* sendLiteralSelectorBytecode */
			{
				messageSelector = longAt((method + (BASE_HEADER_SIZE)) + (((216 & 15) + LiteralStart) << (SHIFT_FOR_WORD)));
				argumentCount = ((((usqInt) 216) >> 4) & 3) - 1;
				goto normalSend;
			}
;
			break;
		case 217:
			/* sendLiteralSelectorBytecode */
			{
				messageSelector = longAt((method + (BASE_HEADER_SIZE)) + (((217 & 15) + LiteralStart) << (SHIFT_FOR_WORD)));
				argumentCount = ((((usqInt) 217) >> 4) & 3) - 1;
				goto normalSend;
			}
;
			break;
		case 218:
			/* sendLiteralSelectorBytecode */
			{
				messageSelector = longAt((method + (BASE_HEADER_SIZE)) + (((218 & 15) + LiteralStart) << (SHIFT_FOR_WORD)));
				argumentCount = ((((usqInt) 218) >> 4) & 3) - 1;
				goto normalSend;
			}
;
			break;
		case 219:
			/* sendLiteralSelectorBytecode */
			{
				messageSelector = longAt((method + (BASE_HEADER_SIZE)) + (((219 & 15) + LiteralStart) << (SHIFT_FOR_WORD)));
				argumentCount = ((((usqInt) 219) >> 4) & 3) - 1;
				goto normalSend;
			}
;
			break;
		case 220:
			/* sendLiteralSelectorBytecode */
			{
				messageSelector = longAt((method + (BASE_HEADER_SIZE)) + (((220 & 15) + LiteralStart) << (SHIFT_FOR_WORD)));
				argumentCount = ((((usqInt) 220) >> 4) & 3) - 1;
				goto normalSend;
			}
;
			break;
		case 221:
			/* sendLiteralSelectorBytecode */
			{
				messageSelector = longAt((method + (BASE_HEADER_SIZE)) + (((221 & 15) + LiteralStart) << (SHIFT_FOR_WORD)));
				argumentCount = ((((usqInt) 221) >> 4) & 3) - 1;
				goto normalSend;
			}
;
			break;
		case 222:
			/* sendLiteralSelectorBytecode */
			{
				messageSelector = longAt((method + (BASE_HEADER_SIZE)) + (((222 & 15) + LiteralStart) << (SHIFT_FOR_WORD)));
				argumentCount = ((((usqInt) 222) >> 4) & 3) - 1;
				goto normalSend;
			}
;
			break;
		case 223:
			/* sendLiteralSelectorBytecode */
			{
				messageSelector = longAt((method + (BASE_HEADER_SIZE)) + (((223 & 15) + LiteralStart) << (SHIFT_FOR_WORD)));
				argumentCount = ((((usqInt) 223) >> 4) & 3) - 1;
				goto normalSend;
			}
;
			break;
		case 224:
			/* sendLiteralSelectorBytecode */
			{
				messageSelector = longAt((method + (BASE_HEADER_SIZE)) + (((224 & 15) + LiteralStart) << (SHIFT_FOR_WORD)));
				argumentCount = ((((usqInt) 224) >> 4) & 3) - 1;
				goto normalSend;
			}
;
			break;
		case 225:
			/* sendLiteralSelectorBytecode */
			{
				messageSelector = longAt((method + (BASE_HEADER_SIZE)) + (((225 & 15) + LiteralStart) << (SHIFT_FOR_WORD)));
				argumentCount = ((((usqInt) 225) >> 4) & 3) - 1;
				goto normalSend;
			}
;
			break;
		case 226:
			/* sendLiteralSelectorBytecode */
			{
				messageSelector = longAt((method + (BASE_HEADER_SIZE)) + (((226 & 15) + LiteralStart) << (SHIFT_FOR_WORD)));
				argumentCount = ((((usqInt) 226) >> 4) & 3) - 1;
				goto normalSend;
			}
;
			break;
		case 227:
			/* sendLiteralSelectorBytecode */
			{
				messageSelector = longAt((method + (BASE_HEADER_SIZE)) + (((227 & 15) + LiteralStart) << (SHIFT_FOR_WORD)));
				argumentCount = ((((usqInt) 227) >> 4) & 3) - 1;
				goto normalSend;
			}
;
			break;
		case 228:
			/* sendLiteralSelectorBytecode */
			{
				messageSelector = longAt((method + (BASE_HEADER_SIZE)) + (((228 & 15) + LiteralStart) << (SHIFT_FOR_WORD)));
				argumentCount = ((((usqInt) 228) >> 4) & 3) - 1;
				goto normalSend;
			}
;
			break;
		case 229:
			/* sendLiteralSelectorBytecode */
			{
				messageSelector = longAt((method + (BASE_HEADER_SIZE)) + (((229 & 15) + LiteralStart) << (SHIFT_FOR_WORD)));
				argumentCount = ((((usqInt) 229) >> 4) & 3) - 1;
				goto normalSend;
			}
;
			break;
		case 230:
			/* sendLiteralSelectorBytecode */
			{
				messageSelector = longAt((method + (BASE_HEADER_SIZE)) + (((230 & 15) + LiteralStart) << (SHIFT_FOR_WORD)));
				argumentCount = ((((usqInt) 230) >> 4) & 3) - 1;
				goto normalSend;
			}
;
			break;
		case 231:
			/* sendLiteralSelectorBytecode */
			{
				messageSelector = longAt((method + (BASE_HEADER_SIZE)) + (((231 & 15) + LiteralStart) << (SHIFT_FOR_WORD)));
				argumentCount = ((((usqInt) 231) >> 4) & 3) - 1;
				goto normalSend;
			}
;
			break;
		case 232:
			/* sendLiteralSelectorBytecode */
			{
				messageSelector = longAt((method + (BASE_HEADER_SIZE)) + (((232 & 15) + LiteralStart) << (SHIFT_FOR_WORD)));
				argumentCount = ((((usqInt) 232) >> 4) & 3) - 1;
				goto normalSend;
			}
;
			break;
		case 233:
			/* sendLiteralSelectorBytecode */
			{
				messageSelector = longAt((method + (BASE_HEADER_SIZE)) + (((233 & 15) + LiteralStart) << (SHIFT_FOR_WORD)));
				argumentCount = ((((usqInt) 233) >> 4) & 3) - 1;
				goto normalSend;
			}
;
			break;
		case 234:
			/* sendLiteralSelectorBytecode */
			{
				messageSelector = longAt((method + (BASE_HEADER_SIZE)) + (((234 & 15) + LiteralStart) << (SHIFT_FOR_WORD)));
				argumentCount = ((((usqInt) 234) >> 4) & 3) - 1;
				goto normalSend;
			}
;
			break;
		case 235:
			/* sendLiteralSelectorBytecode */
			{
				messageSelector = longAt((method + (BASE_HEADER_SIZE)) + (((235 & 15) + LiteralStart) << (SHIFT_FOR_WORD)));
				argumentCount = ((((usqInt) 235) >> 4) & 3) - 1;
				goto normalSend;
			}
;
			break;
		case 236:
			/* sendLiteralSelectorBytecode */
			{
				messageSelector = longAt((method + (BASE_HEADER_SIZE)) + (((236 & 15) + LiteralStart) << (SHIFT_FOR_WORD)));
				argumentCount = ((((usqInt) 236) >> 4) & 3) - 1;
				goto normalSend;
			}
;
			break;
		case 237:
			/* sendLiteralSelectorBytecode */
			{
				messageSelector = longAt((method + (BASE_HEADER_SIZE)) + (((237 & 15) + LiteralStart) << (SHIFT_FOR_WORD)));
				argumentCount = ((((usqInt) 237) >> 4) & 3) - 1;
				goto normalSend;
			}
;
			break;
		case 238:
			/* sendLiteralSelectorBytecode */
			{
				messageSelector = longAt((method + (BASE_HEADER_SIZE)) + (((238 & 15) + LiteralStart) << (SHIFT_FOR_WORD)));
				argumentCount = ((((usqInt) 238) >> 4) & 3) - 1;
				goto normalSend;
			}
;
			break;
		case 239:
			/* sendLiteralSelectorBytecode */
			{
				messageSelector = longAt((method + (BASE_HEADER_SIZE)) + (((239 & 15) + LiteralStart) << (SHIFT_FOR_WORD)));
				argumentCount = ((((usqInt) 239) >> 4) & 3) - 1;
				goto normalSend;
			}
;
			break;
		case 240:
			/* sendLiteralSelectorBytecode */
			{
				messageSelector = longAt((method + (BASE_HEADER_SIZE)) + (((240 & 15) + LiteralStart) << (SHIFT_FOR_WORD)));
				argumentCount = ((((usqInt) 240) >> 4) & 3) - 1;
				goto normalSend;
			}
;
			break;
		case 241:
			/* sendLiteralSelectorBytecode */
			{
				messageSelector = longAt((method + (BASE_HEADER_SIZE)) + (((241 & 15) + LiteralStart) << (SHIFT_FOR_WORD)));
				argumentCount = ((((usqInt) 241) >> 4) & 3) - 1;
				goto normalSend;
			}
;
			break;
		case 242:
			/* sendLiteralSelectorBytecode */
			{
				messageSelector = longAt((method + (BASE_HEADER_SIZE)) + (((242 & 15) + LiteralStart) << (SHIFT_FOR_WORD)));
				argumentCount = ((((usqInt) 242) >> 4) & 3) - 1;
				goto normalSend;
			}
;
			break;
		case 243:
			/* sendLiteralSelectorBytecode */
			{
				messageSelector = longAt((method + (BASE_HEADER_SIZE)) + (((243 & 15) + LiteralStart) << (SHIFT_FOR_WORD)));
				argumentCount = ((((usqInt) 243) >> 4) & 3) - 1;
				goto normalSend;
			}
;
			break;
		case 244:
			/* sendLiteralSelectorBytecode */
			{
				messageSelector = longAt((method + (BASE_HEADER_SIZE)) + (((244 & 15) + LiteralStart) << (SHIFT_FOR_WORD)));
				argumentCount = ((((usqInt) 244) >> 4) & 3) - 1;
				goto normalSend;
			}
;
			break;
		case 245:
			/* sendLiteralSelectorBytecode */
			{
				messageSelector = longAt((method + (BASE_HEADER_SIZE)) + (((245 & 15) + LiteralStart) << (SHIFT_FOR_WORD)));
				argumentCount = ((((usqInt) 245) >> 4) & 3) - 1;
				goto normalSend;
			}
;
			break;
		case 246:
			/* sendLiteralSelectorBytecode */
			{
				messageSelector = longAt((method + (BASE_HEADER_SIZE)) + (((246 & 15) + LiteralStart) << (SHIFT_FOR_WORD)));
				argumentCount = ((((usqInt) 246) >> 4) & 3) - 1;
				goto normalSend;
			}
;
			break;
		case 247:
			/* sendLiteralSelectorBytecode */
			{
				messageSelector = longAt((method + (BASE_HEADER_SIZE)) + (((247 & 15) + LiteralStart) << (SHIFT_FOR_WORD)));
				argumentCount = ((((usqInt) 247) >> 4) & 3) - 1;
				goto normalSend;
			}
;
			break;
		case 248:
			/* sendLiteralSelectorBytecode */
			{
				messageSelector = longAt((method + (BASE_HEADER_SIZE)) + (((248 & 15) + LiteralStart) << (SHIFT_FOR_WORD)));
				argumentCount = ((((usqInt) 248) >> 4) & 3) - 1;
				goto normalSend;
			}
;
			break;
		case 249:
			/* sendLiteralSelectorBytecode */
			{
				messageSelector = longAt((method + (BASE_HEADER_SIZE)) + (((249 & 15) + LiteralStart) << (SHIFT_FOR_WORD)));
				argumentCount = ((((usqInt) 249) >> 4) & 3) - 1;
				goto normalSend;
			}
;
			break;
		case 250:
			/* sendLiteralSelectorBytecode */
			{
				messageSelector = longAt((method + (BASE_HEADER_SIZE)) + (((250 & 15) + LiteralStart) << (SHIFT_FOR_WORD)));
				argumentCount = ((((usqInt) 250) >> 4) & 3) - 1;
				goto normalSend;
			}
;
			break;
		case 251:
			/* sendLiteralSelectorBytecode */
			{
				messageSelector = longAt((method + (BASE_HEADER_SIZE)) + (((251 & 15) + LiteralStart) << (SHIFT_FOR_WORD)));
				argumentCount = ((((usqInt) 251) >> 4) & 3) - 1;
				goto normalSend;
			}
;
			break;
		case 252:
			/* sendLiteralSelectorBytecode */
			{
				messageSelector = longAt((method + (BASE_HEADER_SIZE)) + (((252 & 15) + LiteralStart) << (SHIFT_FOR_WORD)));
				argumentCount = ((((usqInt) 252) >> 4) & 3) - 1;
				goto normalSend;
			}
;
			break;
		case 253:
			/* sendLiteralSelectorBytecode */
			{
				messageSelector = longAt((method + (BASE_HEADER_SIZE)) + (((253 & 15) + LiteralStart) << (SHIFT_FOR_WORD)));
				argumentCount = ((((usqInt) 253) >> 4) & 3) - 1;
				goto normalSend;
			}
;
			break;
		case 254:
			/* sendLiteralSelectorBytecode */
			{
				messageSelector = longAt((method + (BASE_HEADER_SIZE)) + (((254 & 15) + LiteralStart) << (SHIFT_FOR_WORD)));
				argumentCount = ((((usqInt) 254) >> 4) & 3) - 1;
				goto normalSend;
			}
;
			break;
		case 255:
			/* sendLiteralSelectorBytecode */
			{
				messageSelector = longAt((method + (BASE_HEADER_SIZE)) + (((255 & 15) + LiteralStart) << (SHIFT_FOR_WORD)));
				argumentCount = ((((usqInt) 255) >> 4) & 3) - 1;
				goto normalSend;
			}
;
			break;
		}
	}

	/* undo the pre-increment of IP before returning */

	localIP -= 1;
	/* begin externalizeIPandSP */
	instructionPointer = (usqInt)oopForPointer(localIP);
	stackPointer = (usqInt)oopForPointer(localSP);
	theHomeContext = localHomeContext;
	return null;
}


/*	the vm has to convert aFilenameString via any canonicalization and char-mapping and put the result in aCharBuffer.
Note the resolveAliases flag - this is an awful artefact of OSX and Apples demented alias handling. When opening a file, the flag must be  true, when closing or renaming it must be false. Sigh. */

sqInt ioFilenamefromStringofLengthresolveAliases(char *aCharBuffer, char *aFilenameString, sqInt filenameLength, sqInt aBoolean) {
	sqGetFilenameFromString(aCharBuffer, aFilenameString, filenameLength, aBoolean);
	return null;
}


/*	Answer the UTC microseconds since the Smalltalk epoch. The value is
	derived from the Posix epoch (see primitiveUTCMicrosecondClock) with a
	constant offset corresponding to elapsed microseconds between the two
	epochs according to RFC 868. */
/*	Added to Cross/vm/sqVirtualMachine but incompatible with existing timer
	support in Cross. Implemented here to provide the function not present in
	the support code. See also primitiveUTCMicrosecondClock. */

EXPORT(usqLong) ioUTCMicroseconds(void) {
    sqLong clock;
    static usqLong epochDelta= 2177452800000000ULL;
    int offset;
    sqInt uSecs;

	flag("FIXME");
	if ((ioUtcWithOffset(&clock, &offset)) == -1) {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		return null;
	}
	clock += epochDelta;
	uSecs = positive64BitIntegerFor(clock);
	return uSecs;
}


/*	Support for external primitives. */

sqInt isKindOf(sqInt oop, char *className) {
    sqInt oopClass;
    sqInt ccIndex;
    sqInt oop1;

	/* begin fetchClassOf: */
	if ((oop & 1)) {
		oopClass = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassInteger << (SHIFT_FOR_WORD)));
		goto l1;
	}
	ccIndex = (((usqInt) (longAt(oop))) >> 12) & 31;
	if (ccIndex == 0) {
		oopClass = (longAt(oop - (BASE_HEADER_SIZE))) & (ALL_BUT_TYPE_MASK);
		goto l1;
	} else {
		/* begin fetchPointer:ofObject: */
		oop1 = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (CompactClasses << (SHIFT_FOR_WORD)));
		oopClass = longAt((oop1 + (BASE_HEADER_SIZE)) + ((ccIndex - 1) << (SHIFT_FOR_WORD)));
		goto l1;
	}
l1:	/* end fetchClassOf: */;
	while (!(oopClass == nilObj)) {
		if (classNameOfIs(oopClass, className)) {
			return 1;
		}
		oopClass = longAt((oopClass + (BASE_HEADER_SIZE)) + (SuperclassIndex << (SHIFT_FOR_WORD)));
	}
	return 0;
}


/*	Support for external primitives. */

sqInt isKindOfClass(sqInt oop, sqInt aClass) {
    sqInt oopClass;
    sqInt ccIndex;
    sqInt oop1;

	/* begin fetchClassOf: */
	if ((oop & 1)) {
		oopClass = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassInteger << (SHIFT_FOR_WORD)));
		goto l1;
	}
	ccIndex = (((usqInt) (longAt(oop))) >> 12) & 31;
	if (ccIndex == 0) {
		oopClass = (longAt(oop - (BASE_HEADER_SIZE))) & (ALL_BUT_TYPE_MASK);
		goto l1;
	} else {
		/* begin fetchPointer:ofObject: */
		oop1 = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (CompactClasses << (SHIFT_FOR_WORD)));
		oopClass = longAt((oop1 + (BASE_HEADER_SIZE)) + ((ccIndex - 1) << (SHIFT_FOR_WORD)));
		goto l1;
	}
l1:	/* end fetchClassOf: */;
	while (!(oopClass == nilObj)) {
		if (oopClass == aClass) {
			return 1;
		}
		oopClass = longAt((oopClass + (BASE_HEADER_SIZE)) + (SuperclassIndex << (SHIFT_FOR_WORD)));
	}
	return 0;
}


/*	Support for external primitives */

sqInt isMemberOf(sqInt oop, char *className) {
    sqInt oopClass;
    sqInt ccIndex;
    sqInt oop1;

	/* begin fetchClassOf: */
	if ((oop & 1)) {
		oopClass = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassInteger << (SHIFT_FOR_WORD)));
		goto l1;
	}
	ccIndex = (((usqInt) (longAt(oop))) >> 12) & 31;
	if (ccIndex == 0) {
		oopClass = (longAt(oop - (BASE_HEADER_SIZE))) & (ALL_BUT_TYPE_MASK);
		goto l1;
	} else {
		/* begin fetchPointer:ofObject: */
		oop1 = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (CompactClasses << (SHIFT_FOR_WORD)));
		oopClass = longAt((oop1 + (BASE_HEADER_SIZE)) + ((ccIndex - 1) << (SHIFT_FOR_WORD)));
		goto l1;
	}
l1:	/* end fetchClassOf: */;
	return classNameOfIs(oopClass, className);
}


/*	Answer true if this is an indexable object with pointer elements, e.g., an array */

sqInt isArray(sqInt oop) {
	return ((oop & 1) == 0) && (((((usqInt) (longAt(oop))) >> 8) & 15) == 2);
}


/*	Answer true (non-zero) if running on a big endian machine. */

sqInt isBigEnder(void) {
    sqInt anInt;
    char *cString;
    static sqInt endianness = -1;
    sqInt i;
    sqInt len;

	if (!(endianness == -1)) {
		return endianness;
	}
	len = sizeof(anInt);
	cString = (char *) &anInt;
	i = 0;
	while (i < len) {
		cString[i] = i;
		i += 1;
	}
	endianness = anInt & 255;
	return endianness;
}


/*	Answer true if the argument contains indexable bytes. See comment in formatOf: */
/*	Note: Includes CompiledMethods. */

sqInt isBytes(sqInt oop) {
	return ((oop & 1) == 0) && (((((usqInt) (longAt(oop))) >> 8) & 15) >= 8);
}


/*	Answer true if size is greater than (((2 raisedTo: 31) - 1) >> bits). Used
	to limit size of allocation requests to 31 bit integer maximum to prevent
	arithmetic overflow in subsequent calculations. Always answers false
	in interpreter simulation.
	
	In the case of a 64-bit object memory running on a 64-bit host platform,
	allow larger allocation requests.

	Assumes that sizeof(int) is 4 for all platforms. */

sqInt isExcessiveAllocationRequestshift(sqInt size, sqInt bits) {
    int int32;
    sqInt int64;
    sqInt shiftCount;


	/* 32 bit signed integer */

	
# ifdef SQ_IMAGE64  // a 64-bit object memory word size
	
# ifdef SQ_HOST64  // running on a 64-bit host platform

	/* use 64 bit check if both image and host are 64 bits */

	int64 = size;
	shiftCount = 0;
	if (int64 < 0) {
		return 1;
	}
	while (shiftCount < bits) {
		int64 = int64 << 1;
		if (int64 < 0) {
			return 1;
		}
		shiftCount += 1;
	}
	return 0;
# else

	/* if sqInt is 64 bit, size parameter may overflow int32 */

	if (size > 4294967295U) {
		return 0;
	}
# endif  // SQ_HOST64
	
# else

	/* common case of 32 bit image on either 32 or 64 bit host */

	int32 = size;
	shiftCount = 0;
	if (int32 < 0) {
		return 1;
	}
	while (shiftCount < bits) {
		int32 = int32 << 1;
		if (int32 < 0) {
			return 1;
		}
		shiftCount += 1;
	}
	return 0;
# endif  // SQ_IMAGE64
	
	return null;
}

sqInt isFloatObject(sqInt oop) {
	return (fetchClassOf(oop)) == (longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassFloat << (SHIFT_FOR_WORD))));
}


/*	Is this a MethodContext whose meth has a primitive number of 199? */
/*	NB: the use of a primitive number for marking the method is pretty grungy, but it is simple to use for a test sytem, not too expensive and we don't actually have the two spare method header bits we need. We can probably obtain them when the method format is changed.
	NB 2: actually, the jitter will probably implement the prim to actually mark the volatile frame by changing the return function pointer. */

sqInt isHandlerMarked(sqInt aContext) {
    sqInt header;
    sqInt meth;
    sqInt pIndex;
    sqInt primBits;

	header = longAt(aContext);
	if (!(((((usqInt) header) >> 12) & 31) == 14)) {
		return 0;
	}
	meth = longAt((aContext + (BASE_HEADER_SIZE)) + (MethodIndex << (SHIFT_FOR_WORD)));
	/* begin primitiveIndexOf: */
	primBits = (((usqInt) (longAt((meth + (BASE_HEADER_SIZE)) + (HeaderIndex << (SHIFT_FOR_WORD))))) >> 1) & 268435967;
	pIndex = (primBits & 511) + (((usqInt) primBits) >> 19);
	return pIndex == 199;
}


/*	Return true if the given address is in ST object memory */

sqInt isInMemory(sqInt address) {
	return ((((usqInt) address)) >= (((usqInt) memory))) && ((((usqInt) address)) < (((usqInt) endOfMemory)));
}

sqInt isIndexable(sqInt oop) {
	return ((((usqInt) (longAt(oop))) >> 8) & 15) >= 2;
}

sqInt isIntegerObject(sqInt objectPointer) {
	return (objectPointer & 1) > 0;
}


/*	Return true if the given value can be represented as a Smalltalk integer value. */
/*	Use a shift and XOR to set the sign bit if and only if the top two bits of the given
	value are the same, then test the sign bit. Note that the top two bits are equal for
	exactly those integers in the range that can be represented in 31-bits or 63-bits.

	Operands are coerced to machine integer size so the test will work with 64 bit
	images on 32 bit hosts. When running on a 32 bit host, the cast to int has little
	or no performance impact for either 32 bit or 64 bit images.

	On a 64 bit host, the shift and XOR test is replaced by an explicit range check,
	which provides the best performance for both 32 bit and 64 bit images.

	If the range of small integers is enlarged for 64 bit images, this method must
	be updated accordingly. */

sqInt isIntegerValue(sqInt intValue) {
	return 
# ifdef SQ_HOST32  // cast to int for 64 bit image on 32 bit host
		(((((int) intValue)) ^ ((((int) intValue)) << 1)) >= 0)
# else
		((intValue >= -1073741824) && (intValue <= 1073741823))
# endif  // SQ_HOST32
	;
}


/*	Answer true if integer object is negative.
	Fail if object pointed by oop i not an integer. */

sqInt isNegativeIntegerValueOf(sqInt oop) {
    sqInt ok;
    sqInt smallInt;
    sqInt classOop;
    sqInt ccIndex;
    sqInt classOop1;
    sqInt ccIndex1;

	if ((oop & 1)) {
		smallInt = (oop >> 1);
		return smallInt < 0;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	classOop = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassLargePositiveInteger << (SHIFT_FOR_WORD)));
	assert(!((oop & 1)));
	ccIndex = (((usqInt) (longAt(oop))) >> 12) & 31;
	ok = (ClassLargePositiveIntegerCompactIndex == 0
		? (ccIndex == 0
	? ((longAt(oop - (BASE_HEADER_SIZE))) & (ALL_BUT_TYPE_MASK)) == classOop
	: 0)
		: ClassLargePositiveIntegerCompactIndex == ccIndex);
	if (ok) {
		return 0;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	classOop1 = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassLargeNegativeInteger << (SHIFT_FOR_WORD)));
	assert(!((oop & 1)));
	ccIndex1 = (((usqInt) (longAt(oop))) >> 12) & 31;
	ok = (ClassLargeNegativeIntegerCompactIndex == 0
		? (ccIndex1 == 0
	? ((longAt(oop - (BASE_HEADER_SIZE))) & (ALL_BUT_TYPE_MASK)) == classOop1
	: 0)
		: ClassLargeNegativeIntegerCompactIndex == ccIndex1);
	if (ok) {
		return 1;
	}
	/* begin primitiveFail */
	if (primFailCode == 0) {
		primFailCode = 1;
	}
	return 0;
}


/*	Answer true if the argument has only fields that can hold oops. See comment in formatOf: */

sqInt isPointers(sqInt oop) {
	return ((oop & 1) == 0) && (((((usqInt) (longAt(oop))) >> 8) & 15) <= 4);
}


/*	Answer true if the argument has only weak fields that can hold oops. See comment in formatOf: */

sqInt isWeak(sqInt oop) {
	return ((oop & 1) == 0) && (((((usqInt) (longAt(oop))) >> 8) & 15) == 4);
}


/*	Answer true if the argument contains only indexable words (no oops). See comment in formatOf: */

sqInt isWords(sqInt oop) {
	return ((oop & 1) == 0) && (((((usqInt) (longAt(oop))) >> 8) & 15) == 6);
}


/*	Answer true if the contains only indexable words or bytes (no oops). See comment in formatOf: */
/*	Note: Excludes CompiledMethods. */

sqInt isWordsOrBytes(sqInt oop) {
	return ((oop & 1) == 0) && (isWordsOrBytesNonInt(oop));
}


/*	Answer true if the contains only indexable words or bytes (no oops). See comment in formatOf: */
/*	Note: Excludes CompiledMethods. */

sqInt isWordsOrBytesNonInt(sqInt oop) {
    sqInt fmt;

	fmt = (((usqInt) (longAt(oop))) >> 8) & 15;
	return (fmt == 6) || ((fmt >= 8) && (fmt <= 11));
}

sqInt isYoung(sqInt oop) {
	return ((oop & 1) == 0) && ((((usqInt) oop)) >= (((usqInt) youngStart)));
}


/*	Return the byte offset of the last pointer field of the given object.  
	Works with CompiledMethods, as well as ordinary objects. 
	Can be used even when the type bits are not correct. */

sqInt lastPointerOf(sqInt oop) {
    sqInt contextSize;
    sqInt fmt;
    sqInt header;
    sqInt methodHeader;
    sqInt sz;
    sqInt sp;
    sqInt header1;
    sqInt type;

	header = longAt(oop);
	fmt = (((usqInt) header) >> 8) & 15;
	if (fmt <= 4) {
		if ((fmt == 3) && ((((((usqInt) header) >> 12) & 31) == 13) || ((((((usqInt) header) >> 12) & 31) == 14) || (((((usqInt) header) >> 12) & 31) == 4)))) {

			/* contexts end at the stack pointer */

			/* begin fetchStackPointerOf: */
			sp = longAt((oop + (BASE_HEADER_SIZE)) + (StackPointerIndex << (SHIFT_FOR_WORD)));
			if (!((sp & 1))) {
				contextSize = 0;
				goto l1;
			}
			contextSize = (sp >> 1);
		l1:	/* end fetchStackPointerOf: */;
			return (CtxtTempFrameStart + contextSize) * (BYTES_PER_WORD);
		}
		/* begin sizeBitsOfSafe: */
		header1 = longAt(oop);
		/* begin rightType: */
		if ((header1 & (SIZE_MASK)) == 0) {
			type = HeaderTypeSizeAndClass;
			goto l2;
		} else {
			if ((header1 & CompactClassMask) == 0) {
				type = HeaderTypeClass;
				goto l2;
			} else {
				type = HeaderTypeShort;
				goto l2;
			}
		}
	l2:	/* end rightType: */;
		if (type == HeaderTypeSizeAndClass) {
			sz = (longAt(oop - ((BYTES_PER_WORD) * 2))) & (ALL_BUT_TYPE_MASK);
			goto l3;
		} else {
			sz = header1 & (SIZE_MASK);
			goto l3;
		}
	l3:	/* end sizeBitsOfSafe: */;
		return sz - (BASE_HEADER_SIZE);
	}
	if (fmt < 12) {
		return 0;
	}
	methodHeader = longAt(oop + (BASE_HEADER_SIZE));
	return (((((usqInt) methodHeader) >> 10) & 255) * (BYTES_PER_WORD)) + (BASE_HEADER_SIZE);
}


/*	Return the number of indexable bytes or words in the given object. Assume the argument is not an integer. For a CompiledMethod, the size of the method header (in bytes) should be subtracted from the result. */

sqInt lengthOf(sqInt oop) {
    sqInt header;
    sqInt sz;

	header = longAt(oop);
	/* begin lengthOf:baseHeader:format: */
	if ((header & TypeMask) == HeaderTypeSizeAndClass) {
		sz = (longAt(oop - ((BYTES_PER_WORD) * 2))) & (LONG_SIZE_MASK);
	} else {
		sz = header & (SIZE_MASK);
	}
	sz -= header & (SIZE_4_BIT);
	if (((((usqInt) header) >> 8) & 15) <= 4) {
		return ((usqInt) (sz - (BASE_HEADER_SIZE))) >> (SHIFT_FOR_WORD);
	}
	if (((((usqInt) header) >> 8) & 15) < 8) {
		return ((usqInt) (sz - (BASE_HEADER_SIZE))) >> 2;
	} else {
		return (sz - (BASE_HEADER_SIZE)) - (((((usqInt) header) >> 8) & 15) & 3);
	}
	return null;
}

sqInt literalofMethod(sqInt offset, sqInt methodPointer) {
	return longAt((methodPointer + (BASE_HEADER_SIZE)) + ((offset + LiteralStart) << (SHIFT_FOR_WORD)));
}

sqInt literalCountOf(sqInt methodPointer) {
    sqInt headerPointer;

	/* begin literalCountOfHeader: */
	headerPointer = longAt((methodPointer + (BASE_HEADER_SIZE)) + (HeaderIndex << (SHIFT_FOR_WORD)));
	return (((usqInt) headerPointer) >> 10) & 255;
}

sqInt literalCountOfHeader(sqInt headerPointer) {
	return (((usqInt) headerPointer) >> 10) & 255;
}


/*	This entry point needs to be implemented for the interpreter proxy.
	Since BitBlt is now a plugin we need to look up BitBltPlugin:=loadBitBltFrom
	and call it. This entire mechanism should eventually go away and be
	replaced with a dynamic lookup from BitBltPlugin itself but for backward
	compatibility this stub is provided */

sqInt loadBitBltFrom(sqInt bb) {
    void *fn;

	fn = ioLoadFunctionFrom("loadBitBltFrom", "BitBltPlugin");
	if (fn == 0) {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		return null;
	}
	return ((sqInt (*)(sqInt))fn)(bb);
}

sqInt loadInitialContext(void) {
    sqInt proc;
    sqInt sched;
    sqInt oop;
    sqInt tmp;

	/* begin fetchPointer:ofObject: */
	oop = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (SchedulerAssociation << (SHIFT_FOR_WORD)));
	sched = longAt((oop + (BASE_HEADER_SIZE)) + (ValueIndex << (SHIFT_FOR_WORD)));
	proc = longAt((sched + (BASE_HEADER_SIZE)) + (ActiveProcessIndex << (SHIFT_FOR_WORD)));
	activeContext = (usqInt)longAt((proc + (BASE_HEADER_SIZE)) + (SuspendedContextIndex << (SHIFT_FOR_WORD)));
	if ((((usqInt) activeContext)) < (((usqInt) youngStart))) {
		beRootIfOld((sqInt)activeContext);
	}
	/* begin fetchContextRegisters: */
	tmp = longAt((activeContext + (BASE_HEADER_SIZE)) + (MethodIndex << (SHIFT_FOR_WORD)));
	if ((tmp & 1)) {
		tmp = longAt((activeContext + (BASE_HEADER_SIZE)) + (HomeIndex << (SHIFT_FOR_WORD)));
		if ((((usqInt) tmp)) < (((usqInt) youngStart))) {
			beRootIfOld(tmp);
		}
	} else {
		tmp = activeContext;
	}
	theHomeContext = tmp;
	receiver = longAt((tmp + (BASE_HEADER_SIZE)) + (ReceiverIndex << (SHIFT_FOR_WORD)));
	method = (usqInt)longAt((tmp + (BASE_HEADER_SIZE)) + (MethodIndex << (SHIFT_FOR_WORD)));
	tmp = ((longAt((activeContext + (BASE_HEADER_SIZE)) + (InstructionPointerIndex << (SHIFT_FOR_WORD)))) >> 1);
	instructionPointer = (usqInt)((method + tmp) + (BASE_HEADER_SIZE)) - 2;
	tmp = ((longAt((activeContext + (BASE_HEADER_SIZE)) + (StackPointerIndex << (SHIFT_FOR_WORD)))) >> 1);
	stackPointer = (usqInt)(activeContext + (BASE_HEADER_SIZE)) + (((TempFrameStart + tmp) - 1) * (BYTES_PER_WORD));
	reclaimableContextCount = 0;
	return null;
}


/*	This method implements a simple method lookup cache. If an entry for the given selector and class is found in the cache, set the values of 'newMethod' and 'primitiveIndex' and return true. Otherwise, return false. */
/*	About the re-probe scheme: The hash is the low bits of the XOR of two large addresses, minus their useless lowest two bits. If a probe doesn't get a hit, the hash is shifted right one bit to compute the next probe, introducing a new randomish bit. The cache is probed CacheProbeMax times before giving up. */
/*	WARNING: Since the hash computation is based on the object addresses of the class and selector, we must rehash or flush when compacting storage. We've chosen to flush, since that also saves the trouble of updating the addresses of the objects in the cache. */

sqInt lookupInMethodCacheSelclass(sqInt selector, sqInt class) {
    sqInt hash;
    sqInt probe;


	/* shift drops two low-order zeros from addresses */

	hash = selector ^ class;

	/* first probe */

	probe = hash & MethodCacheMask;
	if (((methodCache[probe + MethodCacheSelector]) == selector) && ((methodCache[probe + MethodCacheClass]) == class)) {
		newMethod = (usqInt)methodCache[probe + MethodCacheMethod];
		primitiveIndex = methodCache[probe + MethodCachePrim];
		newNativeMethod = methodCache[probe + MethodCacheNative];
		primitiveFunctionPointer = ((void (*)(void)) (methodCache[probe + MethodCachePrimFunction]));
		return 1;
	}

	/* second probe */

	probe = (((usqInt) hash) >> 1) & MethodCacheMask;
	if (((methodCache[probe + MethodCacheSelector]) == selector) && ((methodCache[probe + MethodCacheClass]) == class)) {
		newMethod = (usqInt)methodCache[probe + MethodCacheMethod];
		primitiveIndex = methodCache[probe + MethodCachePrim];
		newNativeMethod = methodCache[probe + MethodCacheNative];
		primitiveFunctionPointer = ((void (*)(void)) (methodCache[probe + MethodCachePrimFunction]));
		return 1;
	}
	probe = (((usqInt) hash) >> 2) & MethodCacheMask;
	if (((methodCache[probe + MethodCacheSelector]) == selector) && ((methodCache[probe + MethodCacheClass]) == class)) {
		newMethod = (usqInt)methodCache[probe + MethodCacheMethod];
		primitiveIndex = methodCache[probe + MethodCachePrim];
		newNativeMethod = methodCache[probe + MethodCacheNative];
		primitiveFunctionPointer = ((void (*)(void)) (methodCache[probe + MethodCachePrimFunction]));
		return 1;
	}
	return 0;
}

sqInt lookupMethodInClass(sqInt class) {
    sqInt currentClass;
    sqInt dictionary;
    sqInt found;
    sqInt rclass;
    sqInt oop;
    sqInt oop1;
    sqInt index;
    sqInt length;
    sqInt mask;
    sqInt methodArray;
    sqInt nextSelector;
    sqInt wrapAround;
    sqInt sz;
    sqInt primBits;
    sqInt header;

	currentClass = class;
	while (currentClass != nilObj) {
		dictionary = longAt((currentClass + (BASE_HEADER_SIZE)) + (MessageDictionaryIndex << (SHIFT_FOR_WORD)));
		if (dictionary == nilObj) {

			/* MethodDict pointer is nil (hopefully due a swapped out stub)
				-- raise exception #cannotInterpret:. */

			/* begin pushRemappableOop: */
			remapBuffer[(remapBufferCount += 1)] = currentClass;
			createActualMessageTo(class);
			/* begin popRemappableOop */
			oop = remapBuffer[remapBufferCount];
			remapBufferCount -= 1;
			currentClass = oop;
			messageSelector = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (SelectorCannotInterpret << (SHIFT_FOR_WORD)));
			return lookupMethodInClass(longAt((currentClass + (BASE_HEADER_SIZE)) + (SuperclassIndex << (SHIFT_FOR_WORD))));
		}
		/* begin lookupMethodInDictionary: */
		/* begin fetchWordLengthOf: */
		/* begin sizeBitsOf: */
		header = longAt(dictionary);
		if ((header & TypeMask) == HeaderTypeSizeAndClass) {
			sz = (longAt(dictionary - ((BYTES_PER_WORD) * 2))) & (LONG_SIZE_MASK);
			goto l1;
		} else {
			sz = header & (SIZE_MASK);
			goto l1;
		}
	l1:	/* end sizeBitsOf: */;
		length = ((usqInt) (sz - (BASE_HEADER_SIZE))) >> (SHIFT_FOR_WORD);
		mask = (length - SelectorStart) - 1;
		if ((messageSelector & 1)) {
			index = (mask & ((messageSelector >> 1))) + SelectorStart;
		} else {
			index = (mask & ((((usqInt) (longAt(messageSelector))) >> 17) & 4095)) + SelectorStart;
		}
		wrapAround = 0;
		while (1) {
			nextSelector = longAt((dictionary + (BASE_HEADER_SIZE)) + (index << (SHIFT_FOR_WORD)));
			if (nextSelector == nilObj) {
				found = 0;
				goto l2;
			}
			if (nextSelector == messageSelector) {
				methodArray = longAt((dictionary + (BASE_HEADER_SIZE)) + (MethodArrayIndex << (SHIFT_FOR_WORD)));
				newMethod = (usqInt)longAt((methodArray + (BASE_HEADER_SIZE)) + ((index - SelectorStart) << (SHIFT_FOR_WORD)));
				if (((((usqInt) (longAt(newMethod))) >> 8) & 15) >= 12) {
					/* begin primitiveIndexOf: */
					primBits = (((usqInt) (longAt((newMethod + (BASE_HEADER_SIZE)) + (HeaderIndex << (SHIFT_FOR_WORD))))) >> 1) & 268435967;
					primitiveIndex = (primBits & 511) + (((usqInt) primBits) >> 19);
					if (primitiveIndex > MaxPrimitiveIndex) {
						primitiveIndex = 0;
					}
				} else {
					primitiveIndex = 248;
				}
				found = 1;
				goto l2;
			}
			index += 1;
			if (index == length) {
				if (wrapAround) {
					found = 0;
					goto l2;
				}
				wrapAround = 1;
				index = SelectorStart;
			}
		}
	l2:	/* end lookupMethodInDictionary: */;
		if (found) {
			return (methodClass = currentClass);
		}
		currentClass = longAt((currentClass + (BASE_HEADER_SIZE)) + (SuperclassIndex << (SHIFT_FOR_WORD)));
	}
	if (messageSelector == (longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (SelectorDoesNotUnderstand << (SHIFT_FOR_WORD))))) {
		error("Recursive not understood error encountered");
	}
	/* begin pushRemappableOop: */
	remapBuffer[(remapBufferCount += 1)] = class;
	createActualMessageTo(class);
	/* begin popRemappableOop */
	oop1 = remapBuffer[remapBufferCount];
	remapBufferCount -= 1;
	rclass = oop1;
	messageSelector = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (SelectorDoesNotUnderstand << (SHIFT_FOR_WORD)));
	return lookupMethodInClass(rclass);
}


/*	This method lookup tolerates integers as Dictionary keys to 
	support execution of images in which Symbols have been 
	compacted out */

sqInt lookupMethodInDictionary(sqInt dictionary) {
    sqInt index;
    sqInt length;
    sqInt mask;
    sqInt methodArray;
    sqInt nextSelector;
    sqInt wrapAround;
    sqInt sz;
    sqInt primBits;
    sqInt header;

	/* begin fetchWordLengthOf: */
	/* begin sizeBitsOf: */
	header = longAt(dictionary);
	if ((header & TypeMask) == HeaderTypeSizeAndClass) {
		sz = (longAt(dictionary - ((BYTES_PER_WORD) * 2))) & (LONG_SIZE_MASK);
		goto l1;
	} else {
		sz = header & (SIZE_MASK);
		goto l1;
	}
l1:	/* end sizeBitsOf: */;
	length = ((usqInt) (sz - (BASE_HEADER_SIZE))) >> (SHIFT_FOR_WORD);
	mask = (length - SelectorStart) - 1;
	if ((messageSelector & 1)) {
		index = (mask & ((messageSelector >> 1))) + SelectorStart;
	} else {
		index = (mask & ((((usqInt) (longAt(messageSelector))) >> 17) & 4095)) + SelectorStart;
	}
	wrapAround = 0;
	while (1) {
		nextSelector = longAt((dictionary + (BASE_HEADER_SIZE)) + (index << (SHIFT_FOR_WORD)));
		if (nextSelector == nilObj) {
			return 0;
		}
		if (nextSelector == messageSelector) {
			methodArray = longAt((dictionary + (BASE_HEADER_SIZE)) + (MethodArrayIndex << (SHIFT_FOR_WORD)));

			/* Check if newMethod is a CompiledMethod. */

			newMethod = (usqInt)longAt((methodArray + (BASE_HEADER_SIZE)) + ((index - SelectorStart) << (SHIFT_FOR_WORD)));
			if (((((usqInt) (longAt(newMethod))) >> 8) & 15) >= 12) {
				/* begin primitiveIndexOf: */
				primBits = (((usqInt) (longAt((newMethod + (BASE_HEADER_SIZE)) + (HeaderIndex << (SHIFT_FOR_WORD))))) >> 1) & 268435967;
				primitiveIndex = (primBits & 511) + (((usqInt) primBits) >> 19);
				if (primitiveIndex > MaxPrimitiveIndex) {

					/* If primitiveIndex is out of range, set to zero before putting in 
									cache. This is equiv to primFail, and avoids the need to check on 
									every send. */

					primitiveIndex = 0;
				}
			} else {

				/* indicate that this is no compiled method - use primitiveInvokeObjectAsMethod */

				primitiveIndex = 248;
			}
			return 1;
		}
		index += 1;
		if (index == length) {
			if (wrapAround) {
				return 0;
			}
			wrapAround = 1;
			index = SelectorStart;
		}
	}
	return null;
}


/*	Lookup.  Answer false on failure father than performing MNU processing etc. */

sqInt lookupMethodNoMNUEtcInClass(sqInt class) {
    sqInt currentClass;
    sqInt dictionary;

	currentClass = class;
	while (currentClass != nilObj) {
		dictionary = longAt((currentClass + (BASE_HEADER_SIZE)) + (MessageDictionaryIndex << (SHIFT_FOR_WORD)));
		if ((dictionary != nilObj) && (lookupMethodInDictionary(dictionary))) {
			methodClass = currentClass;
			return 1;
		}
		currentClass = longAt((currentClass + (BASE_HEADER_SIZE)) + (SuperclassIndex << (SHIFT_FOR_WORD)));
	}
	return 0;
}


/*	Return the first free block after the given chunk in memory. */

sqInt lowestFreeAfter(sqInt chunk) {
    sqInt oop;
    sqInt oopHeader;
    sqInt oopHeaderType;
    sqInt oopSize;

	oop = chunk + (headerTypeBytes[(longAt(chunk)) & TypeMask]);
	while ((((usqInt) oop)) < (((usqInt) endOfMemory))) {
		oopHeader = longAt(oop);
		oopHeaderType = oopHeader & TypeMask;
		if (oopHeaderType == HeaderTypeFree) {
			return oop;
		} else {
			if (oopHeaderType == HeaderTypeSizeAndClass) {
				oopSize = (longAt(oop - ((BYTES_PER_WORD) * 2))) & (ALL_BUT_TYPE_MASK);
			} else {
				oopSize = oopHeader & (SIZE_MASK);
			}
		}
		oop = (oop + oopSize) + (headerTypeBytes[(longAt(oop + oopSize)) & TypeMask]);
	}
	error("expected to find at least one free object");
	return null;
}


/*	Return a Large Integer object for the given integer magnitude and sign */

sqInt magnitude64BitIntegerForneg(usqLong magnitude, sqInt isNegative) {
    usqInt highWord;
    sqInt i;
    sqInt intValue;
    sqInt isSmall;
    sqInt largeClass;
    sqInt newLargeInteger;
    sqInt smallVal;
    sqInt sz;

	isSmall = (isNegative
		? magnitude <= 1073741824
		: magnitude < 1073741824);
	if (isSmall) {
		smallVal = ((sqInt) magnitude);
		if (isNegative) {
			smallVal = 0 - smallVal;
		}
		return ((smallVal << 1) | 1);
	}
	if (isNegative) {
		largeClass = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassLargeNegativeInteger << (SHIFT_FOR_WORD)));
	} else {
		largeClass = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassLargePositiveInteger << (SHIFT_FOR_WORD)));
	}

	/* shift is coerced to usqInt otherwise */

	highWord = magnitude >> 32;
	if (highWord == 0) {
		sz = 4;
	} else {
		sz = 5;
		if (!(((highWord = ((usqInt) highWord) >> 8)) == 0)) {
			sz += 1;
		}
		if (!(((highWord = ((usqInt) highWord) >> 8)) == 0)) {
			sz += 1;
		}
		if (!(((highWord = ((usqInt) highWord) >> 8)) == 0)) {
			sz += 1;
		}
	}
	newLargeInteger = instantiateClassindexableSize(largeClass, sz);
	for (i = 0; i <= (sz - 1); i += 1) {
		intValue = (magnitude >> (i * 8)) & 255;
		byteAtput((newLargeInteger + (BASE_HEADER_SIZE)) + i, intValue);
	}
	return newLargeInteger;
}


/*	Convert the given object into an integer value.
	The object may be either a positive SmallInteger or a eight-byte LargeInteger. */

usqLong magnitude64BitValueOf(sqInt oop) {
    sqInt i;
    sqInt ok;
    sqInt smallIntValue;
    sqInt sz;
    usqLong value;
    sqInt classOop;
    sqInt ccIndex;
    sqInt classOop1;
    sqInt ccIndex1;
    sqInt header;
    sqInt sz1;

	if ((oop & 1)) {
		smallIntValue = (oop >> 1);
		if (smallIntValue < 0) {
			smallIntValue = 0 - smallIntValue;
		}
		return ((usqLong) smallIntValue);
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	classOop1 = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassLargePositiveInteger << (SHIFT_FOR_WORD)));
	assert(!((oop & 1)));
	ccIndex1 = (((usqInt) (longAt(oop))) >> 12) & 31;
	ok = (ClassLargePositiveIntegerCompactIndex == 0
		? (ccIndex1 == 0
	? ((longAt(oop - (BASE_HEADER_SIZE))) & (ALL_BUT_TYPE_MASK)) == classOop1
	: 0)
		: ClassLargePositiveIntegerCompactIndex == ccIndex1);
	if (!(ok)) {
		/* begin isClassOfNonImm:equalTo:compactClassIndex: */
		classOop = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassLargeNegativeInteger << (SHIFT_FOR_WORD)));
		assert(!((oop & 1)));
		ccIndex = (((usqInt) (longAt(oop))) >> 12) & 31;
		ok = (ClassLargeNegativeIntegerCompactIndex == 0
			? (ccIndex == 0
	? ((longAt(oop - (BASE_HEADER_SIZE))) & (ALL_BUT_TYPE_MASK)) == classOop
	: 0)
			: ClassLargeNegativeIntegerCompactIndex == ccIndex);
		if (!(ok)) {
			/* begin primitiveFail */
			if (primFailCode == 0) {
				primFailCode = 1;
			}
			return null;
		}
	}
	/* begin lengthOf: */
	header = longAt(oop);
	/* begin lengthOf:baseHeader:format: */
	if ((header & TypeMask) == HeaderTypeSizeAndClass) {
		sz1 = (longAt(oop - ((BYTES_PER_WORD) * 2))) & (LONG_SIZE_MASK);
	} else {
		sz1 = header & (SIZE_MASK);
	}
	sz1 -= header & (SIZE_4_BIT);
	if (((((usqInt) header) >> 8) & 15) <= 4) {
		sz = ((usqInt) (sz1 - (BASE_HEADER_SIZE))) >> (SHIFT_FOR_WORD);
		goto l1;
	}
	if (((((usqInt) header) >> 8) & 15) < 8) {
		sz = ((usqInt) (sz1 - (BASE_HEADER_SIZE))) >> 2;
		goto l1;
	} else {
		sz = (sz1 - (BASE_HEADER_SIZE)) - (((((usqInt) header) >> 8) & 15) & 3);
		goto l1;
	}
l1:	/* end lengthOf:baseHeader:format: */;
	if (sz > (sizeof(sqLong))) {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		return null;
	}
	value = 0;
	for (i = 0; i <= (sz - 1); i += 1) {
		value += (((sqLong) (byteAt((oop + (BASE_HEADER_SIZE)) + i)))) << (i * 8);
	}
	return value;
}


/*	make a Point xValue@yValue.
We know both will be integers so no value nor root checking is needed */

sqInt makePointwithxValueyValue(sqInt xValue, sqInt yValue) {
    sqInt pointResult;

	pointResult = instantiateSmallClasssizeInBytes(longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassPoint << (SHIFT_FOR_WORD))), 3 * (BYTES_PER_WORD));
	longAtput((pointResult + (BASE_HEADER_SIZE)) + (XIndex << (SHIFT_FOR_WORD)), ((xValue << 1) | 1));
	longAtput((pointResult + (BASE_HEADER_SIZE)) + (YIndex << (SHIFT_FOR_WORD)), ((yValue << 1) | 1));
	return pointResult;
}


/*	Use the forwarding table to update the pointers of all non-free objects in the given range of memory. Also remap pointers in root objects which may contains pointers into the given memory range, and don't forget to flush the method cache based on the range */

sqInt mapPointersInObjectsFromto(sqInt memStart, sqInt memEnd) {
    sqInt i;
    sqInt oop;
    sqInt i1;
    sqInt probe;
    sqInt i2;
    sqInt oop1;
    sqInt iLimiT;
    sqInt value;

	/* begin compilerMapHookFrom:to: */
	if (compilerInitialized) {
		compilerMapFromto(memStart, memEnd);
	}
	/* begin mapInterpreterOops */
	/* begin mapRootObjects */
	nilObj = remap(nilObj);
	falseObj = remap(falseObj);
	trueObj = remap(trueObj);
	specialObjectsOop = remap(specialObjectsOop);
	if (!(compilerInitialized)) {
		stackPointer -= activeContext;
		activeContext = (usqInt)remap((sqInt)activeContext);
		stackPointer += activeContext;
		theHomeContext = (usqInt)remap((sqInt)theHomeContext);
	}
	instructionPointer -= method;
	method = (usqInt)remap((sqInt)method);
	instructionPointer += method;
	receiver = remap(receiver);
	messageSelector = remap(messageSelector);
	newMethod = (usqInt)remap((sqInt)newMethod);
	methodClass = remap(methodClass);
	lkupClass = remap(lkupClass);
	receiverClass = remap(receiverClass);
	for (i2 = 1, iLimiT = remapBufferCount; i2 <= iLimiT; i2 += 1) {
		oop1 = remapBuffer[i2];
		if (!((oop1 & 1))) {
			/* begin remapBufferAt:put: */
			value = remap(oop1);
			remapBuffer[i2] = value;
		}
	}
	for (i2 = 1; i2 <= jmpDepth; i2 += 1) {
		oop1 = suspendedCallbacks[i2];
		if (!((oop1 & 1))) {
			suspendedCallbacks[i2] = (remap(oop1));
		}
		oop1 = suspendedMethods[i2];
		if (!((oop1 & 1))) {
			suspendedMethods[i2] = (remap(oop1));
		}
	}
	for (i = 1; i <= extraRootCount; i += 1) {
		oop = (extraRoots[i])[0];
		if (!((oop & 1))) {
			(extraRoots[i])[0] = (remap(oop));
		}
	}
	/* begin flushMethodCacheFrom:to: */
	probe = 0;
	for (i1 = 1; i1 <= MethodCacheEntries; i1 += 1) {
		if (!((methodCache[probe + MethodCacheSelector]) == 0)) {
			if ((((((((usqInt) (methodCache[probe + MethodCacheSelector]))) >= (((usqInt) memStart))) && ((((usqInt) (methodCache[probe + MethodCacheSelector]))) < (((usqInt) memEnd)))) || (((((usqInt) (methodCache[probe + MethodCacheClass]))) >= (((usqInt) memStart))) && ((((usqInt) (methodCache[probe + MethodCacheClass]))) < (((usqInt) memEnd))))) || (((((usqInt) (methodCache[probe + MethodCacheMethod]))) >= (((usqInt) memStart))) && ((((usqInt) (methodCache[probe + MethodCacheMethod]))) < (((usqInt) memEnd))))) || (((((usqInt) (methodCache[probe + MethodCacheNative]))) >= (((usqInt) memStart))) && ((((usqInt) (methodCache[probe + MethodCacheNative]))) < (((usqInt) memEnd))))) {
				methodCache[probe + MethodCacheSelector] = 0;
			}
		}
		probe += MethodCacheEntrySize;
	}
	for (i1 = 1; i1 <= AtCacheTotalSize; i1 += 1) {
		atCache[i1] = 0;
	}
	updatePointersInRootObjectsFromto(memStart, memEnd);
	updatePointersInRangeFromto(memStart, memEnd);
	return null;
}


/*	Mark all objects reachable from the given one.
	Trace from the given object even if it is old.
	Do not trace if it is already marked.
	Mark it only if it is a young object. */
/*	Tracer state variables:
		child		object being examined
		field		next field of child to examine
		parentField	field where child was stored in its referencing object */

sqInt markAndTrace(sqInt oop) {
    sqInt action;
    sqInt header;
    sqInt lastFieldOffset;
    sqInt statMarkCountLocal;
    sqInt contextSize;
    sqInt fmt;
    sqInt header1;
    sqInt methodHeader;
    sqInt sz;
    sqInt sp;
    sqInt header2;
    sqInt lastFieldOffset1;
    sqInt oop1;
    sqInt header3;
    sqInt type;
    sqInt childType;
    sqInt typeBits;
    sqInt contextSize1;
    sqInt fmt1;
    sqInt header4;
    sqInt methodHeader1;
    sqInt sz1;
    sqInt sp1;
    sqInt header11;
    sqInt type1;
    sqInt header5;
    sqInt type2;
    sqInt child;
    usqInt youngStartLocal;
    sqInt parentField;
    sqInt field;

	header = longAt(oop);
	if (!((header & (MARK_BIT)) == 0)) {
		return 0;
	}
	header = (header & (ALL_BUT_TYPE_MASK)) | HeaderTypeGC;
	if ((((usqInt) oop)) >= (((usqInt) youngStart))) {
		header = header | (MARK_BIT);
	}
	longAtput(oop, header);
	parentField = GCTopMarker;
	child = oop;
	if (((((usqInt) (longAt(oop))) >> 8) & 15) == 4) {

		/* Set lastFieldOffset before the weak fields in the receiver */


		/* And remember as weak root */

		lastFieldOffset = (nonWeakFieldsOf(oop)) << (SHIFT_FOR_WORD);
		weakRootCount += 1;
		weakRoots[weakRootCount] = oop;
	} else {

		/* Do it the usual way */

		/* begin lastPointerOf: */
		header1 = longAt(oop);
		fmt = (((usqInt) header1) >> 8) & 15;
		if (fmt <= 4) {
			if ((fmt == 3) && ((((((usqInt) header1) >> 12) & 31) == 13) || ((((((usqInt) header1) >> 12) & 31) == 14) || (((((usqInt) header1) >> 12) & 31) == 4)))) {
				/* begin fetchStackPointerOf: */
				sp = longAt((oop + (BASE_HEADER_SIZE)) + (StackPointerIndex << (SHIFT_FOR_WORD)));
				if (!((sp & 1))) {
					contextSize = 0;
					goto l1;
				}
				contextSize = (sp >> 1);
			l1:	/* end fetchStackPointerOf: */;
				lastFieldOffset = (CtxtTempFrameStart + contextSize) * (BYTES_PER_WORD);
				goto l2;
			}
			/* begin sizeBitsOfSafe: */
			header3 = longAt(oop);
			/* begin rightType: */
			if ((header3 & (SIZE_MASK)) == 0) {
				type = HeaderTypeSizeAndClass;
				goto l4;
			} else {
				if ((header3 & CompactClassMask) == 0) {
					type = HeaderTypeClass;
					goto l4;
				} else {
					type = HeaderTypeShort;
					goto l4;
				}
			}
		l4:	/* end rightType: */;
			if (type == HeaderTypeSizeAndClass) {
				sz = (longAt(oop - ((BYTES_PER_WORD) * 2))) & (ALL_BUT_TYPE_MASK);
				goto l5;
			} else {
				sz = header3 & (SIZE_MASK);
				goto l5;
			}
		l5:	/* end sizeBitsOfSafe: */;
			lastFieldOffset = sz - (BASE_HEADER_SIZE);
			goto l2;
		}
		if (fmt < 12) {
			lastFieldOffset = 0;
			goto l2;
		}
		methodHeader = longAt(oop + (BASE_HEADER_SIZE));
		lastFieldOffset = (((((usqInt) methodHeader) >> 10) & 255) * (BYTES_PER_WORD)) + (BASE_HEADER_SIZE);
	l2:	/* end lastPointerOf: */;
	}
	field = oop + lastFieldOffset;
	action = StartField;
	youngStartLocal = youngStart;

	/* run the tracer state machine until all objects reachable from oop are marked */

	statMarkCountLocal = statMarkCount;
	while (!(action == Done)) {
		statMarkCountLocal += 1;
		if (action == StartField) {
			/* begin startField */
			child = longAt(field);
			typeBits = child & TypeMask;
			if ((typeBits & 1) == 1) {
				field -= BYTES_PER_WORD;
				action = StartField;
				goto l7;
			}
			if (typeBits == 0) {
				longAtput(field, parentField);
				parentField = field;
				action = StartObj;
				goto l7;
			}
			if (typeBits == 2) {
				if ((child & CompactClassMask) != 0) {
					child = child & (ALL_BUT_TYPE_MASK);
					/* begin rightType: */
					if ((child & (SIZE_MASK)) == 0) {
						childType = HeaderTypeSizeAndClass;
						goto l6;
					} else {
						if ((child & CompactClassMask) == 0) {
							childType = HeaderTypeClass;
							goto l6;
						} else {
							childType = HeaderTypeShort;
							goto l6;
						}
					}
				l6:	/* end rightType: */;
					longAtput(field, child | childType);
					action = Upward;
					goto l7;
				} else {
					child = longAt(field - (BYTES_PER_WORD));
					child = child & (ALL_BUT_TYPE_MASK);
					longAtput(field - (BYTES_PER_WORD), parentField);
					parentField = (field - (BYTES_PER_WORD)) | 1;
					action = StartObj;
					goto l7;
				}
			}
		l7:	/* end startField */;
		}
		if (action == StartObj) {
			/* begin startObj */
			oop1 = child;
			if ((((usqInt) oop1)) < (((usqInt) youngStartLocal))) {
				field = oop1;
				action = Upward;
				goto l3;
			}
			header2 = longAt(oop1);
			if ((header2 & (MARK_BIT)) == 0) {
				if (((((usqInt) (longAt(oop1))) >> 8) & 15) == 4) {
					lastFieldOffset1 = (nonWeakFieldsOf(oop1)) << (SHIFT_FOR_WORD);
				} else {
					/* begin lastPointerOf: */
					header4 = longAt(oop1);
					fmt1 = (((usqInt) header4) >> 8) & 15;
					if (fmt1 <= 4) {
						if ((fmt1 == 3) && ((((((usqInt) header4) >> 12) & 31) == 13) || ((((((usqInt) header4) >> 12) & 31) == 14) || (((((usqInt) header4) >> 12) & 31) == 4)))) {
							/* begin fetchStackPointerOf: */
							sp1 = longAt((oop1 + (BASE_HEADER_SIZE)) + (StackPointerIndex << (SHIFT_FOR_WORD)));
							if (!((sp1 & 1))) {
								contextSize1 = 0;
								goto l8;
							}
							contextSize1 = (sp1 >> 1);
						l8:	/* end fetchStackPointerOf: */;
							lastFieldOffset1 = (CtxtTempFrameStart + contextSize1) * (BYTES_PER_WORD);
							goto l11;
						}
						/* begin sizeBitsOfSafe: */
						header11 = longAt(oop1);
						/* begin rightType: */
						if ((header11 & (SIZE_MASK)) == 0) {
							type1 = HeaderTypeSizeAndClass;
							goto l9;
						} else {
							if ((header11 & CompactClassMask) == 0) {
								type1 = HeaderTypeClass;
								goto l9;
							} else {
								type1 = HeaderTypeShort;
								goto l9;
							}
						}
					l9:	/* end rightType: */;
						if (type1 == HeaderTypeSizeAndClass) {
							sz1 = (longAt(oop1 - ((BYTES_PER_WORD) * 2))) & (ALL_BUT_TYPE_MASK);
							goto l10;
						} else {
							sz1 = header11 & (SIZE_MASK);
							goto l10;
						}
					l10:	/* end sizeBitsOfSafe: */;
						lastFieldOffset1 = sz1 - (BASE_HEADER_SIZE);
						goto l11;
					}
					if (fmt1 < 12) {
						lastFieldOffset1 = 0;
						goto l11;
					}
					methodHeader1 = longAt(oop1 + (BASE_HEADER_SIZE));
					lastFieldOffset1 = (((((usqInt) methodHeader1) >> 10) & 255) * (BYTES_PER_WORD)) + (BASE_HEADER_SIZE);
				l11:	/* end lastPointerOf: */;
				}
				header2 = header2 & (ALL_BUT_TYPE_MASK);
				header2 = (header2 | (MARK_BIT)) | HeaderTypeGC;
				longAtput(oop1, header2);
				field = oop1 + lastFieldOffset1;
				action = StartField;
				goto l3;
			} else {
				field = oop1;
				action = Upward;
				goto l3;
			}
		l3:	/* end startObj */;
		}
		if (action == Upward) {
			/* begin upward */
			if ((parentField & 1) == 1) {
				if (parentField == GCTopMarker) {
					header5 = (longAt(field)) & (ALL_BUT_TYPE_MASK);
					/* begin rightType: */
					if ((header5 & (SIZE_MASK)) == 0) {
						type2 = HeaderTypeSizeAndClass;
						goto l12;
					} else {
						if ((header5 & CompactClassMask) == 0) {
							type2 = HeaderTypeClass;
							goto l12;
						} else {
							type2 = HeaderTypeShort;
							goto l12;
						}
					}
				l12:	/* end rightType: */;
					longAtput(field, header5 | type2);
					action = Done;
					goto l14;
				} else {
					child = field;
					field = parentField - 1;
					parentField = longAt(field);
					header5 = longAt(field + (BYTES_PER_WORD));
					/* begin rightType: */
					if ((header5 & (SIZE_MASK)) == 0) {
						type2 = HeaderTypeSizeAndClass;
						goto l13;
					} else {
						if ((header5 & CompactClassMask) == 0) {
							type2 = HeaderTypeClass;
							goto l13;
						} else {
							type2 = HeaderTypeShort;
							goto l13;
						}
					}
				l13:	/* end rightType: */;
					longAtput(field, child | type2);
					field += BYTES_PER_WORD;
					header5 = header5 & (ALL_BUT_TYPE_MASK);
					longAtput(field, header5 | type2);
					action = Upward;
					goto l14;
				}
			} else {
				child = field;
				field = parentField;
				parentField = longAt(field);
				longAtput(field, child);
				field -= BYTES_PER_WORD;
				action = StartField;
				goto l14;
			}
		l14:	/* end upward */;
		}
	}
	statMarkCount = statMarkCountLocal;
	return null;
}


/*	Mark and trace all oops in the interpreter's state. */
/*	Assume: All traced variables contain valid oops. */

sqInt markAndTraceInterpreterOops(sqInt fullGCFlag) {
    sqInt i;
    sqInt oop;
    sqInt iLimiT;

	/* begin compilerMarkHook */
	if (compilerInitialized) {
		compilerMark();
	}
	markAndTrace(specialObjectsOop);
	if (compilerInitialized) {
		markAndTrace(receiver);
		markAndTrace((sqInt)method);
	} else {
		markAndTrace((sqInt)activeContext);
	}
	markAndTrace(messageSelector);
	markAndTrace((sqInt)newMethod);
	markAndTrace(methodClass);
	markAndTrace(lkupClass);
	markAndTrace(receiverClass);
	for (i = 1, iLimiT = remapBufferCount; i <= iLimiT; i += 1) {
		oop = remapBuffer[i];
		if (!((oop & 1))) {
			markAndTrace(oop);
		}
	}
	for (i = 1; i <= jmpDepth; i += 1) {
		oop = suspendedCallbacks[i];
		if (!((oop & 1))) {
			markAndTrace(oop);
		}
		oop = suspendedMethods[i];
		if (!((oop & 1))) {
			markAndTrace(oop);
		}
	}
	return null;
}


/*	Mark phase of the mark and sweep garbage collector. Set 
	the mark bits of all reachable objects. Free chunks are 
	untouched by this process. */
/*	Assume: All non-free objects are initially unmarked. Root 
	objects were unmarked when they were made roots. (Make 
	sure this stays true!!). */

sqInt markPhase(void) {
    sqInt i;
    sqInt oop;


	/* clear the recycled context lists */

	freeContexts = NilContext;

	/* trace the interpreter's objects, including the active stack 
	and special objects array */

	freeLargeContexts = NilContext;
	markAndTraceInterpreterOops(1);

	/* trace the roots */

	statSpecialMarkCount = statMarkCount;
	for (i = 1; i <= rootTableCount; i += 1) {
		oop = rootTable[i];
		markAndTrace(oop);
	}
	for (i = 1; i <= extraRootCount; i += 1) {
		oop = (extraRoots[i])[0];
		if (!((oop & 1))) {
			markAndTrace(oop);
		}
	}
	return null;
}


/*	Like #stackValue: but access method arguments left-to-right */

sqInt methodArg(sqInt index) {
	if ((index > argumentCount) + 1) {
		fprintf(stderr,"[VM]: Attempt to access method args beyond range\n");
		printCallStackOf((sqInt)activeContext);
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		return 0;
	}
	return longAt(stackPointer - ((argumentCount - index) * (BYTES_PER_WORD)));
}

sqInt methodArgumentCount(void) {
	return argumentCount;
}

sqInt methodPrimitiveIndex(void) {
	return primitiveIndex;
}


/*	Sets the return value for a method.  In the CoInterpreter we replace the cumbersome
	 primResult machinery. */

sqInt methodReturnValue(sqInt oop) {
    sqInt sp;

	/* begin pop:thenPush: */
	longAtput((sp = stackPointer - (((argumentCount + 1) - 1) * (BYTES_PER_WORD))), oop);
	stackPointer = sp;
	return 0;
}


/*	The module with the given name was just unloaded. 
	Make sure we have no dangling references. */

EXPORT(sqInt) moduleUnloaded(char *aModuleName) {
	if ((strcmp(aModuleName, "SurfacePlugin")) == 0) {

		/* Surface plugin went away. Should never happen. But  then, who knows */

		showSurfaceFn = 0;
	}
	return null;
}


/*	For access from BitBlt module */

sqInt nilObject(void) {
	return nilObj;
}


/*	Return the number of non-weak fields in oop (i.e. the number of fixed fields).
	Note: The following is copied from fixedFieldsOf:format:length: since we do know
	the format of the oop (e.g. format = 4) and thus don't need the length. */

sqInt nonWeakFieldsOf(sqInt oop) {
    sqInt class;
    sqInt classFormat;
    sqInt ccIndex;
    sqInt oop1;


	/* No need to inline - we won't call this often */

	if (!(((((usqInt) (longAt(oop))) >> 8) & 15) == 4)) {
		error("Called fixedFieldsOfWeak: with a non-weak oop");
	}
	/* begin fetchClassOf: */
	if ((oop & 1)) {
		class = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassInteger << (SHIFT_FOR_WORD)));
		goto l1;
	}
	ccIndex = (((usqInt) (longAt(oop))) >> 12) & 31;
	if (ccIndex == 0) {
		class = (longAt(oop - (BASE_HEADER_SIZE))) & (ALL_BUT_TYPE_MASK);
		goto l1;
	} else {
		/* begin fetchPointer:ofObject: */
		oop1 = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (CompactClasses << (SHIFT_FOR_WORD)));
		class = longAt((oop1 + (BASE_HEADER_SIZE)) + ((ccIndex - 1) << (SHIFT_FOR_WORD)));
		goto l1;
	}
l1:	/* end fetchClassOf: */;
	classFormat = (longAt((class + (BASE_HEADER_SIZE)) + (InstanceSpecificationIndex << (SHIFT_FOR_WORD)))) - 1;
	return (((((usqInt) classFormat) >> 11) & 192) + ((((usqInt) classFormat) >> 2) & 63)) - 1;
}


/*	Float objects were saved in platform word ordering. Reorder them into the
	traditional object format. */

sqInt normalizeFloatOrderingInImage(void) {
    unsigned int *floatData;
    sqInt oop;
    unsigned int val;
    sqInt obj;
    sqInt obj1;
    sqInt sz;
    sqInt header;
    sqInt sz1;
    sqInt header1;
    sqInt sz2;
    sqInt header2;

	if (!(isBigEnder())) {

		/* Swap words within Float objects, taking them out of native platform ordering */

		/* begin firstAccessibleObject */
		obj1 = memory + (headerTypeBytes[(longAt(memory)) & TypeMask]);
		while ((((usqInt) obj1)) < (((usqInt) endOfMemory))) {
			if (!(((longAt(obj1)) & TypeMask) == HeaderTypeFree)) {
				oop = obj1;
				goto l2;
			}
			/* begin objectAfter: */
			if (DoAssertionChecks) {
				if ((((usqInt) obj1)) >= (((usqInt) endOfMemory))) {
					error("no objects after the end of memory");
				}
			}
			if (((longAt(obj1)) & TypeMask) == HeaderTypeFree) {
				sz = (longAt(obj1)) & (ALL_BUT_TYPE_MASK);
			} else {
				/* begin sizeBitsOf: */
				header = longAt(obj1);
				if ((header & TypeMask) == HeaderTypeSizeAndClass) {
					sz = (longAt(obj1 - ((BYTES_PER_WORD) * 2))) & (LONG_SIZE_MASK);
					goto l3;
				} else {
					sz = header & (SIZE_MASK);
					goto l3;
				}
			l3:	/* end sizeBitsOf: */;
			}
			obj1 = (obj1 + sz) + (headerTypeBytes[(longAt(obj1 + sz)) & TypeMask]);
		}
		error("heap is empty");
	l2:	/* end firstAccessibleObject */;
		while (!(oop == null)) {
			if (!(((longAt(oop)) & TypeMask) == HeaderTypeFree)) {
				if ((fetchClassOf(oop)) == (longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassFloat << (SHIFT_FOR_WORD))))) {
					floatData = ((unsigned int *) (firstIndexableField(oop)));
					val = floatData[0];
					floatData[0] = (floatData[1]);
					floatData[1] = val;
				}
				/* begin accessibleObjectAfter: */
				/* begin objectAfter: */
				if (DoAssertionChecks) {
					if ((((usqInt) oop)) >= (((usqInt) endOfMemory))) {
						error("no objects after the end of memory");
					}
				}
				if (((longAt(oop)) & TypeMask) == HeaderTypeFree) {
					sz2 = (longAt(oop)) & (ALL_BUT_TYPE_MASK);
				} else {
					/* begin sizeBitsOf: */
					header2 = longAt(oop);
					if ((header2 & TypeMask) == HeaderTypeSizeAndClass) {
						sz2 = (longAt(oop - ((BYTES_PER_WORD) * 2))) & (LONG_SIZE_MASK);
						goto l5;
					} else {
						sz2 = header2 & (SIZE_MASK);
						goto l5;
					}
				l5:	/* end sizeBitsOf: */;
				}
				obj = (oop + sz2) + (headerTypeBytes[(longAt(oop + sz2)) & TypeMask]);
				while ((((usqInt) obj)) < (((usqInt) endOfMemory))) {
					if (!(((longAt(obj)) & TypeMask) == HeaderTypeFree)) {
						oop = obj;
						goto l1;
					}
					/* begin objectAfter: */
					if (DoAssertionChecks) {
						if ((((usqInt) obj)) >= (((usqInt) endOfMemory))) {
							error("no objects after the end of memory");
						}
					}
					if (((longAt(obj)) & TypeMask) == HeaderTypeFree) {
						sz1 = (longAt(obj)) & (ALL_BUT_TYPE_MASK);
					} else {
						/* begin sizeBitsOf: */
						header1 = longAt(obj);
						if ((header1 & TypeMask) == HeaderTypeSizeAndClass) {
							sz1 = (longAt(obj - ((BYTES_PER_WORD) * 2))) & (LONG_SIZE_MASK);
							goto l4;
						} else {
							sz1 = header1 & (SIZE_MASK);
							goto l4;
						}
					l4:	/* end sizeBitsOf: */;
					}
					obj = (obj + sz1) + (headerTypeBytes[(longAt(obj + sz1)) & TypeMask]);
				}
				oop = null;
			l1:	/* end accessibleObjectAfter: */;
			}
		}
	}
	return null;
}


/*	Record that the given oop in the old object area points to an 
	object in the young area. 
	HeaderLoc is usually = oop, but may be an addr in a 
	forwarding block. */

sqInt noteAsRootheaderLoc(sqInt oop, sqInt headerLoc) {
    sqInt header;

	header = longAt(headerLoc);
	if ((header & (ROOT_BIT)) == 0) {

		/* record oop as root only if not already recorded */

		if (rootTableCount < RootTableRedZone) {

			/* record root if there is enough room in the roots 
					table  */

			rootTableCount += 1;
			rootTable[rootTableCount] = oop;
			longAtput(headerLoc, header | (ROOT_BIT));
		} else {

			/* we're getting in the red zone */

			if (rootTableCount < RootTableSize) {

				/* but there's still space to record it */

				rootTableCount += 1;
				rootTable[rootTableCount] = oop;
				longAtput(headerLoc, header | (ROOT_BIT));
				allocationCount = allocationsBetweenGCs + 1;
			}
		}
	}
	return null;
}


/*	This should never be called: either the compiler is uninitialised (in which case the hooks should never be reached) or the compiler initialisation should have replaced all the hook with their external implementations. */

sqInt nullCompilerHook(void) {
	error("uninitialised compiler hook called");
	return 0;
}


/*	Return the object or free chunk immediately following the 
	given object or free chunk in memory. Return endOfMemory 
	when enumeration is complete. */

sqInt objectAfter(sqInt oop) {
    sqInt sz;
    sqInt header;

	if (DoAssertionChecks) {
		if ((((usqInt) oop)) >= (((usqInt) endOfMemory))) {
			error("no objects after the end of memory");
		}
	}
	if (((longAt(oop)) & TypeMask) == HeaderTypeFree) {
		sz = (longAt(oop)) & (ALL_BUT_TYPE_MASK);
	} else {
		/* begin sizeBitsOf: */
		header = longAt(oop);
		if ((header & TypeMask) == HeaderTypeSizeAndClass) {
			sz = (longAt(oop - ((BYTES_PER_WORD) * 2))) & (LONG_SIZE_MASK);
			goto l1;
		} else {
			sz = header & (SIZE_MASK);
			goto l1;
		}
	l1:	/* end sizeBitsOf: */;
	}
	return (oop + sz) + (headerTypeBytes[(longAt(oop + sz)) & TypeMask]);
}


/*	Like #stackObjectValue: but access method arguments left-to-right */

sqInt objectArg(sqInt index) {
    sqInt oop;

	oop = methodArg(index);
	if (oop == 0) {
		return 0.0;
	}
	if ((oop & 1)) {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		return null;
	}
	return oop;
}


/*	This message is deprecated but supported for a while via a tweak to sqVirtualMachine.[ch] Use fetchLong32, fetchLong64 or fetchPointer instead for new code */

sqInt obsoleteDontUseThisFetchWordofObject(sqInt fieldIndex, sqInt oop) {
	return long32At((oop + (BASE_HEADER_SIZE)) + (fieldIndex << 2));
}


/*	If this is a pointers object, check that its fields are all okay oops. */

sqInt okayFields(sqInt oop) {
    sqInt c;
    sqInt fieldOop;
    sqInt i;
    sqInt ccIndex;
    sqInt oop1;

	if ((oop == null) || (oop == 0)) {
		return 1;
	}
	if ((oop & 1)) {
		return 1;
	}
	okayOop(oop);
	oopHasOkayClass(oop);
	if (!(((oop & 1) == 0) && (((((usqInt) (longAt(oop))) >> 8) & 15) <= 4))) {
		return 1;
	}
	/* begin fetchClassOf: */
	if ((oop & 1)) {
		c = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassInteger << (SHIFT_FOR_WORD)));
		goto l1;
	}
	ccIndex = (((usqInt) (longAt(oop))) >> 12) & 31;
	if (ccIndex == 0) {
		c = (longAt(oop - (BASE_HEADER_SIZE))) & (ALL_BUT_TYPE_MASK);
		goto l1;
	} else {
		/* begin fetchPointer:ofObject: */
		oop1 = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (CompactClasses << (SHIFT_FOR_WORD)));
		c = longAt((oop1 + (BASE_HEADER_SIZE)) + ((ccIndex - 1) << (SHIFT_FOR_WORD)));
		goto l1;
	}
l1:	/* end fetchClassOf: */;
	if ((c == (longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassMethodContext << (SHIFT_FOR_WORD))))) || (c == (longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassBlockContext << (SHIFT_FOR_WORD)))))) {
		i = (CtxtTempFrameStart + (fetchStackPointerOf(oop))) - 1;
	} else {
		i = (lengthOf(oop)) - 1;
	}
	while (i >= 0) {
		fieldOop = longAt((oop + (BASE_HEADER_SIZE)) + (i << (SHIFT_FOR_WORD)));
		if (!((fieldOop & 1))) {
			okayOop(fieldOop);
			oopHasOkayClass(fieldOop);
		}
		i -= 1;
	}
	return null;
}


/*	Verify that the given oop is legitimate. Check address, header, and size but not class. */

sqInt okayOop(sqInt signedOop) {
    sqInt fmt;
    usqInt oop;
    sqInt sz;
    sqInt type;
    sqInt unusedBit;
    sqInt header;


	/* address and size checks */

	oop = ((usqInt) signedOop);
	if ((oop & 1)) {
		return 1;
	}
	if (!(oop < endOfMemory)) {
		error("oop is not a valid address");
	}
	if (!((oop % (BYTES_PER_WORD)) == 0)) {
		error("oop is not a word-aligned address");
	}
	/* begin sizeBitsOf: */
	header = longAt(oop);
	if ((header & TypeMask) == HeaderTypeSizeAndClass) {
		sz = (longAt(oop - ((BYTES_PER_WORD) * 2))) & (LONG_SIZE_MASK);
		goto l1;
	} else {
		sz = header & (SIZE_MASK);
		goto l1;
	}
l1:	/* end sizeBitsOf: */;
	if (!((oop + sz) < endOfMemory)) {
		error("oop size would make it extend beyond the end of memory");
	}
	type = (longAt(oop)) & TypeMask;
	if (type == HeaderTypeFree) {
		error("oop is a free chunk, not an object");
	}
	if (type == HeaderTypeShort) {
		if (((((usqInt) (longAt(oop))) >> 12) & 31) == 0) {
			error("cannot have zero compact class field in a short header");
		}
	}
	if (type == HeaderTypeClass) {
		if (!((oop >= (BYTES_PER_WORD)) && (((longAt(oop - (BYTES_PER_WORD))) & TypeMask) == type))) {
			error("class header word has wrong type");
		}
	}
	if (type == HeaderTypeSizeAndClass) {
		if (!((oop >= ((BYTES_PER_WORD) * 2)) && ((((longAt(oop - ((BYTES_PER_WORD) * 2))) & TypeMask) == type) && (((longAt(oop - (BYTES_PER_WORD))) & TypeMask) == type)))) {
			error("class header word has wrong type");
		}
	}
	fmt = (((usqInt) (longAt(oop))) >> 8) & 15;
	if ((fmt == 5) || (fmt == 7)) {
		error("oop has an unknown format type");
	}
	unusedBit = 536870912;
	if ((BYTES_PER_WORD) == 8) {
		unusedBit = unusedBit << 16;
		unusedBit = unusedBit << 16;
	}
	if (!(((longAt(oop)) & unusedBit) == 0)) {
		error("unused header bit 30 is set; should be zero");
	}
	if ((((longAt(oop)) & (ROOT_BIT)) == 1) && (oop >= youngStart)) {
		error("root bit is set in a young object");
	}
	return 1;
}


/*	Compare two oop values, treating them as object memory locations.
	Use #cCoerce:to: to ensure comparison of unsigned magnitudes. This
	method will be inlined during C translation. */

sqInt oopisGreaterThan(sqInt anOop, sqInt otherOop) {
	return (((usqInt) anOop)) > (((usqInt) otherOop));
}


/*	Compare two oop values, treating them as object memory locations.
	Use #cCoerce:to: to ensure comparison of unsigned magnitudes. This
	method will be inlined during C translation. */

sqInt oopisGreaterThanOrEqualTo(sqInt anOop, sqInt otherOop) {
	return (((usqInt) anOop)) >= (((usqInt) otherOop));
}


/*	Compare two oop values, treating them as object memory locations.
	Use #cCoerce:to: to ensure comparison of unsigned magnitudes. This
	method will be inlined during C translation. */

sqInt oopisLessThan(sqInt anOop, sqInt otherOop) {
	return (((usqInt) anOop)) < (((usqInt) otherOop));
}


/*	Similar to oopHasOkayClass:, except that it only returns true or false. */

sqInt oopHasAcceptableClass(sqInt signedOop) {
    sqInt behaviorFormatBits;
    sqInt formatMask;
    usqInt oop;
    usqInt oopClass;
    sqInt oopFormatBits;

	if ((signedOop & 1)) {
		return 1;
	}
	oop = ((usqInt) signedOop);
	if (!(oop < endOfMemory)) {
		return 0;
	}
	if (!((oop % (BYTES_PER_WORD)) == 0)) {
		return 0;
	}
	if (!((oop + (sizeBitsOf(oop))) < endOfMemory)) {
		return 0;
	}
	oopClass = ((usqInt) (fetchClassOf(oop)));
	if ((oopClass & 1)) {
		return 0;
	}
	if (!(oopClass < endOfMemory)) {
		return 0;
	}
	if (!((oopClass % (BYTES_PER_WORD)) == 0)) {
		return 0;
	}
	if (!((oopClass + (sizeBitsOf(oopClass))) < endOfMemory)) {
		return 0;
	}
	if (!((((oopClass & 1) == 0) && (((((usqInt) (longAt(oopClass))) >> 8) & 15) <= 4)) && ((lengthOf(oopClass)) >= 3))) {
		return 0;
	}
	if (((oop & 1) == 0) && (((((usqInt) (longAt(oop))) >> 8) & 15) >= 8)) {

		/* ignore extra bytes size bits */

		formatMask = 3072;
	} else {
		formatMask = 3840;
	}
	behaviorFormatBits = ((longAt((oopClass + (BASE_HEADER_SIZE)) + (InstanceSpecificationIndex << (SHIFT_FOR_WORD)))) - 1) & formatMask;
	oopFormatBits = (longAt(oop)) & formatMask;
	if (!(behaviorFormatBits == oopFormatBits)) {
		return 0;
	}
	return 1;
}


/*	Attempt to verify that the given oop has a reasonable behavior. The class must be a valid, non-integer oop and must not be nilObj. It must be a pointers object with three or more fields. Finally, the instance specification field of the behavior must match that of the instance. */

sqInt oopHasOkayClass(sqInt signedOop) {
    sqInt behaviorFormatBits;
    sqInt formatMask;
    usqInt oop;
    usqInt oopClass;
    sqInt oopFormatBits;

	oop = ((usqInt) signedOop);
	okayOop(oop);
	oopClass = ((usqInt) (fetchClassOf(oop)));
	if ((oopClass & 1)) {
		error("a SmallInteger is not a valid class or behavior");
	}
	okayOop(oopClass);
	if (!((((oopClass & 1) == 0) && (((((usqInt) (longAt(oopClass))) >> 8) & 15) <= 4)) && ((lengthOf(oopClass)) >= 3))) {
		error("a class (behavior) must be a pointers object of size >= 3");
	}
	if (((oop & 1) == 0) && (((((usqInt) (longAt(oop))) >> 8) & 15) >= 8)) {

		/* ignore extra bytes size bits */

		formatMask = 3072;
	} else {
		formatMask = 3840;
	}
	behaviorFormatBits = ((longAt((oopClass + (BASE_HEADER_SIZE)) + (InstanceSpecificationIndex << (SHIFT_FOR_WORD)))) - 1) & formatMask;
	oopFormatBits = (longAt(oop)) & formatMask;
	if (!(behaviorFormatBits == oopFormatBits)) {
		error("object and its class (behavior) formats differ");
	}
	return 1;
}


/*	Note: May be called by translated primitive code. */

sqInt pop(sqInt nItems) {
	stackPointer -= nItems * (BYTES_PER_WORD);
	return null;
}

sqInt popthenPush(sqInt nItems, sqInt oop) {
    sqInt sp;

	longAtput((sp = stackPointer - ((nItems - 1) * (BYTES_PER_WORD))), oop);
	stackPointer = sp;
	return null;
}


/*	Note: May be called by translated primitive code. */

double popFloat(void) {
    double  result;
    sqInt top;
    sqInt top1;
    sqInt classOop;
    sqInt ccIndex;
    sqInt cl;
    sqInt oop1;

	/* begin popStack */
	top1 = longAt(stackPointer);
	stackPointer -= BYTES_PER_WORD;
	top = top1;
	/* begin assertClassOf:is: */
	classOop = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassFloat << (SHIFT_FOR_WORD)));
	if ((top & 1)) {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		goto l1;
	}
	ccIndex = (((usqInt) (longAt(top))) >> 12) & 31;
	if (ccIndex == 0) {
		cl = (longAt(top - (BASE_HEADER_SIZE))) & (ALL_BUT_TYPE_MASK);
	} else {
		/* begin fetchPointer:ofObject: */
		oop1 = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (CompactClasses << (SHIFT_FOR_WORD)));
		cl = longAt((oop1 + (BASE_HEADER_SIZE)) + ((ccIndex - 1) << (SHIFT_FOR_WORD)));
	}
	/* begin success: */
	if (!(cl == classOop)) {
		if (!primFailCode) {
			primFailCode = 1;
		}
	}
l1:	/* end assertClassOf:is: */;
	if (!primFailCode) {
		;
		fetchFloatAtinto(top + (BASE_HEADER_SIZE), result);
	}
	return result;
}


/*	Pop and return the possibly remapped object from the remap buffer. */

sqInt popRemappableOop(void) {
    sqInt oop;

	oop = remapBuffer[remapBufferCount];
	remapBufferCount -= 1;
	return oop;
}

sqInt popStack(void) {
    sqInt top;

	top = longAt(stackPointer);
	stackPointer -= BYTES_PER_WORD;
	return top;
}


/*	Note - integerValue is interpreted as POSITIVE, eg, as the result of
		Bitmap>at:, or integer>bitAnd:. */

sqInt positive32BitIntegerFor(sqInt integerValue) {
    sqInt newLargeInteger;

	if (integerValue >= 0) {
		if (
# ifdef SQ_HOST32  // cast to int for 64 bit image on 32 bit host
			(((((int) integerValue)) ^ ((((int) integerValue)) << 1)) >= 0)
# else
			((integerValue >= -1073741824) && (integerValue <= 1073741823))
# endif  // SQ_HOST32
		) {
			return ((integerValue << 1) | 1);
		}
	}
	if ((BYTES_PER_WORD) == 4) {

		/* Faster instantiateSmallClass: currently only works with integral word size. */

		newLargeInteger = instantiateSmallClasssizeInBytes(longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassLargePositiveInteger << (SHIFT_FOR_WORD))), (BASE_HEADER_SIZE) + 4);
	} else {

		/* Cant use instantiateSmallClass: due to integral word requirement. */

		newLargeInteger = instantiateClassindexableSize(longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassLargePositiveInteger << (SHIFT_FOR_WORD))), 4);
	}
	byteAtput((newLargeInteger + (BASE_HEADER_SIZE)) + 3, (((usqInt) integerValue) >> 24) & 255);
	byteAtput((newLargeInteger + (BASE_HEADER_SIZE)) + 2, (((usqInt) integerValue) >> 16) & 255);
	byteAtput((newLargeInteger + (BASE_HEADER_SIZE)) + 1, (((usqInt) integerValue) >> 8) & 255);
	byteAtput((newLargeInteger + (BASE_HEADER_SIZE)) + 0, integerValue & 255);
	return newLargeInteger;
}


/*	Convert the given object into an integer value.
	The object may be either a positive ST integer or a four-byte LargePositiveInteger. */

sqInt positive32BitValueOf(sqInt oop) {
    sqInt sz;
    sqInt value;
    sqInt header;
    sqInt sz1;
    sqInt classOop;
    sqInt ccIndex;
    sqInt cl;
    sqInt oop1;

	if ((oop & 1)) {
		value = (oop >> 1);
		if (value < 0) {
			/* begin primitiveFail */
			if (primFailCode == 0) {
				primFailCode = 1;
			}
			return null;
		}
		return value;
	}
	/* begin assertClassOf:is: */
	classOop = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassLargePositiveInteger << (SHIFT_FOR_WORD)));
	if ((oop & 1)) {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		goto l2;
	}
	ccIndex = (((usqInt) (longAt(oop))) >> 12) & 31;
	if (ccIndex == 0) {
		cl = (longAt(oop - (BASE_HEADER_SIZE))) & (ALL_BUT_TYPE_MASK);
	} else {
		/* begin fetchPointer:ofObject: */
		oop1 = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (CompactClasses << (SHIFT_FOR_WORD)));
		cl = longAt((oop1 + (BASE_HEADER_SIZE)) + ((ccIndex - 1) << (SHIFT_FOR_WORD)));
	}
	/* begin success: */
	if (!(cl == classOop)) {
		if (!primFailCode) {
			primFailCode = 1;
		}
	}
l2:	/* end assertClassOf:is: */;
	if (!primFailCode) {
		/* begin lengthOf: */
		header = longAt(oop);
		/* begin lengthOf:baseHeader:format: */
		if ((header & TypeMask) == HeaderTypeSizeAndClass) {
			sz1 = (longAt(oop - ((BYTES_PER_WORD) * 2))) & (LONG_SIZE_MASK);
		} else {
			sz1 = header & (SIZE_MASK);
		}
		sz1 -= header & (SIZE_4_BIT);
		if (((((usqInt) header) >> 8) & 15) <= 4) {
			sz = ((usqInt) (sz1 - (BASE_HEADER_SIZE))) >> (SHIFT_FOR_WORD);
			goto l1;
		}
		if (((((usqInt) header) >> 8) & 15) < 8) {
			sz = ((usqInt) (sz1 - (BASE_HEADER_SIZE))) >> 2;
			goto l1;
		} else {
			sz = (sz1 - (BASE_HEADER_SIZE)) - (((((usqInt) header) >> 8) & 15) & 3);
			goto l1;
		}
	l1:	/* end lengthOf:baseHeader:format: */;
		if (!(sz == 4)) {
			/* begin primitiveFail */
			if (primFailCode == 0) {
				primFailCode = 1;
			}
			return null;
		}
	}
	if (!primFailCode) {
		return (((byteAt((oop + (BASE_HEADER_SIZE)) + 0)) + ((byteAt((oop + (BASE_HEADER_SIZE)) + 1)) << 8)) + ((byteAt((oop + (BASE_HEADER_SIZE)) + 2)) << 16)) + ((byteAt((oop + (BASE_HEADER_SIZE)) + 3)) << 24);
	}
	return null;
}


/*	Note - integerValue is interpreted as POSITIVE, eg, as the result of
		Bitmap>at:, or integer>bitAnd:. */

sqInt positive64BitIntegerFor(sqLong integerValue) {
    sqInt highWord;
    sqInt i;
    sqInt newLargeInteger;
    sqInt sz;
    sqInt value;

	if ((sizeof(integerValue)) == 4) {
		return positive32BitIntegerFor(integerValue);
	}

	/* shift is coerced to usqInt otherwise */

	highWord = integerValue >> 32;
	if (highWord == 0) {
		return positive32BitIntegerFor(integerValue);
	}
	sz = 5;
	if (!(((highWord = ((usqInt) highWord) >> 8)) == 0)) {
		sz += 1;
	}
	if (!(((highWord = ((usqInt) highWord) >> 8)) == 0)) {
		sz += 1;
	}
	if (!(((highWord = ((usqInt) highWord) >> 8)) == 0)) {
		sz += 1;
	}
	newLargeInteger = instantiateClassindexableSize(longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassLargePositiveInteger << (SHIFT_FOR_WORD))), sz);
	for (i = 0; i <= (sz - 1); i += 1) {
		value = (integerValue >> (i * 8)) & 255;
		byteAtput((newLargeInteger + (BASE_HEADER_SIZE)) + i, value);
	}
	return newLargeInteger;
}


/*	Convert the given object into an integer value.
	The object may be either a positive ST integer or a eight-byte LargePositiveInteger. */

sqLong positive64BitValueOf(sqInt oop) {
    sqInt i;
    sqInt sz;
    sqInt szsqLong;
    sqLong value;
    sqInt header;
    sqInt classOop;
    sqInt ccIndex;
    sqInt cl;
    sqInt oop1;
    sqInt sz1;

	if ((oop & 1)) {
		value = (oop >> 1);
		if (value < 0) {
			/* begin primitiveFail */
			if (primFailCode == 0) {
				primFailCode = 1;
			}
			return null;
		}
		return value;
	}
	/* begin assertClassOf:is: */
	classOop = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassLargePositiveInteger << (SHIFT_FOR_WORD)));
	if ((oop & 1)) {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		goto l1;
	}
	ccIndex = (((usqInt) (longAt(oop))) >> 12) & 31;
	if (ccIndex == 0) {
		cl = (longAt(oop - (BASE_HEADER_SIZE))) & (ALL_BUT_TYPE_MASK);
	} else {
		/* begin fetchPointer:ofObject: */
		oop1 = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (CompactClasses << (SHIFT_FOR_WORD)));
		cl = longAt((oop1 + (BASE_HEADER_SIZE)) + ((ccIndex - 1) << (SHIFT_FOR_WORD)));
	}
	/* begin success: */
	if (!(cl == classOop)) {
		if (!primFailCode) {
			primFailCode = 1;
		}
	}
l1:	/* end assertClassOf:is: */;
	if (!(!primFailCode)) {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		return null;
	}
	szsqLong = sizeof(sqLong);
	/* begin lengthOf: */
	header = longAt(oop);
	/* begin lengthOf:baseHeader:format: */
	if ((header & TypeMask) == HeaderTypeSizeAndClass) {
		sz1 = (longAt(oop - ((BYTES_PER_WORD) * 2))) & (LONG_SIZE_MASK);
	} else {
		sz1 = header & (SIZE_MASK);
	}
	sz1 -= header & (SIZE_4_BIT);
	if (((((usqInt) header) >> 8) & 15) <= 4) {
		sz = ((usqInt) (sz1 - (BASE_HEADER_SIZE))) >> (SHIFT_FOR_WORD);
		goto l2;
	}
	if (((((usqInt) header) >> 8) & 15) < 8) {
		sz = ((usqInt) (sz1 - (BASE_HEADER_SIZE))) >> 2;
		goto l2;
	} else {
		sz = (sz1 - (BASE_HEADER_SIZE)) - (((((usqInt) header) >> 8) & 15) & 3);
		goto l2;
	}
l2:	/* end lengthOf:baseHeader:format: */;
	if (sz > szsqLong) {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		return null;
	}
	value = 0;
	for (i = 0; i <= (sz - 1); i += 1) {
		value += (((sqLong) (byteAt((oop + (BASE_HEADER_SIZE)) + i)))) << (i * 8);
	}
	return value;
}


/*	oop is an old object. If valueObj is young, mark the object as a root. */

sqInt possibleRootStoreIntovalue(sqInt oop, sqInt valueObj) {
    sqInt header;

	if (((((usqInt) valueObj)) >= (((usqInt) youngStart))) && (!((valueObj & 1)))) {

		/* Yes, valueObj is a young object */

		/* begin noteAsRoot:headerLoc: */
		header = longAt(oop);
		if ((header & (ROOT_BIT)) == 0) {
			if (rootTableCount < RootTableRedZone) {
				rootTableCount += 1;
				rootTable[rootTableCount] = oop;
				longAtput(oop, header | (ROOT_BIT));
			} else {
				if (rootTableCount < RootTableSize) {
					rootTableCount += 1;
					rootTable[rootTableCount] = oop;
					longAtput(oop, header | (ROOT_BIT));
					allocationCount = allocationsBetweenGCs + 1;
				}
			}
		}
	}
	return null;
}


/*	Mark the active and home contexts as roots if old. This 
	allows the interpreter to use storePointerUnchecked to 
	store into them. */

sqInt postGCAction(void) {
    sqInt delta;
    sqInt limit;

	if (compilerInitialized) {
		compilerPostGC();
	} else {
		if ((((usqInt) activeContext)) < (((usqInt) youngStart))) {
			beRootIfOld((sqInt)activeContext);
		}
		if ((((usqInt) theHomeContext)) < (((usqInt) youngStart))) {
			beRootIfOld((sqInt)theHomeContext);
		}
	}
	if (oopisGreaterThan((longAt(freeBlock)) & (ALL_BUT_TYPE_MASK), (sqInt)shrinkThreshold)) {

		/* Attempt to shrink memory after successfully 
			reclaiming lots of memory */

		/* begin shrinkObjectMemory: */
		delta = ((longAt(freeBlock)) & (ALL_BUT_TYPE_MASK)) - growHeadroom;
		statShrinkMemory += 1;
		limit = sqShrinkMemoryBy(memoryLimit, delta);
		if (!(limit == memoryLimit)) {
			memoryLimit = (usqInt)limit - 24;
			initializeMemoryFirstFree(freeBlock);
		}
	}
	/* begin signalSemaphoreWithIndex: */
	if (gcSemaphoreIndex <= 0) {
		goto l1;
	}
	if (semaphoresUseBufferA) {
		if (semaphoresToSignalCountA < SemaphoresToSignalSize) {
			semaphoresToSignalCountA += 1;
			semaphoresToSignalA[semaphoresToSignalCountA] = gcSemaphoreIndex;
		}
	} else {
		if (semaphoresToSignalCountB < SemaphoresToSignalSize) {
			semaphoresToSignalCountB += 1;
			semaphoresToSignalB[semaphoresToSignalCountB] = gcSemaphoreIndex;
		}
	}
	/* begin forceInterruptCheck */
	interruptCheckCounter = -1000;
	nextPollTick = 0;
l1:	/* end signalSemaphoreWithIndex: */;
	return null;
}


/*	Ensure that there are enough forwarding blocks to 
	accomodate this become, then prepare forwarding blocks for 
	the pointer swap. Return true if successful. */
/*	Details: Doing a GC might generate enough space for 
	forwarding blocks if we're short. However, this is an 
	uncommon enough case that it is better handled by primitive 
	fail code at the Smalltalk level. */
/*	Important note on multiple references to same object  - since the preparation of
	fwdBlocks is NOT idempotent we get VM crashes if the same object is referenced more
	than once in such a way as to require multiple fwdBlocks.
	oop1 forwardBecome: oop1 is ok since only a single fwdBlock is needed.
	oop1 become: oop1 would fail because the second fwdBlock woudl not have the actual object
	header but rather the mutated ref to the first fwdBlock.
	Further problems can arise with an array1 or array2 that refer multiply to the same 
	object. This would notbe expected input for programmer writen code but might arise from
	automatic usage such as in ImageSegment loading.
	To avoid the simple and rather common case of oop1 become*: oop1, we skip such pairs
	and simply avoid making fwdBlocks - it is redundant anyway */

sqInt prepareForwardingTableForBecomingwithtwoWay(sqInt array1, sqInt array2, sqInt twoWayFlag) {
    sqInt entriesAvailable;
    sqInt entriesNeeded;
    sqInt fieldOffset;
    sqInt fwdBlkSize;
    sqInt fwdBlock;
    sqInt oop1;
    sqInt oop2;
    sqInt originalHeader;
    sqInt originalHeaderType;
    sqInt originalHeader1;
    sqInt originalHeaderType1;
    sqInt contextSize;
    sqInt fmt;
    sqInt header;
    sqInt methodHeader;
    sqInt sz;
    sqInt sp;
    sqInt header1;
    sqInt type;


	/* need enough entries for all oops */
	/* Note: Forward blocks must be quadword aligned - see fwdTableInit:. */

	entriesNeeded = (lastPointerOf(array1)) / (BYTES_PER_WORD);
	if (twoWayFlag) {

		/* Double the number of blocks for two-way become */

		entriesNeeded = entriesNeeded * 2;
		fwdBlkSize = (BYTES_PER_WORD) * 2;
	} else {

		/* One-way become needs backPointers in fwd blocks. */

		fwdBlkSize = (BYTES_PER_WORD) * 4;
	}
	entriesAvailable = fwdTableInit(fwdBlkSize);
	if (entriesAvailable < entriesNeeded) {
		initializeMemoryFirstFree(freeBlock);
		return 0;
	}
	/* begin lastPointerOf: */
	header = longAt(array1);
	fmt = (((usqInt) header) >> 8) & 15;
	if (fmt <= 4) {
		if ((fmt == 3) && ((((((usqInt) header) >> 12) & 31) == 13) || ((((((usqInt) header) >> 12) & 31) == 14) || (((((usqInt) header) >> 12) & 31) == 4)))) {
			/* begin fetchStackPointerOf: */
			sp = longAt((array1 + (BASE_HEADER_SIZE)) + (StackPointerIndex << (SHIFT_FOR_WORD)));
			if (!((sp & 1))) {
				contextSize = 0;
				goto l3;
			}
			contextSize = (sp >> 1);
		l3:	/* end fetchStackPointerOf: */;
			fieldOffset = (CtxtTempFrameStart + contextSize) * (BYTES_PER_WORD);
			goto l4;
		}
		/* begin sizeBitsOfSafe: */
		header1 = longAt(array1);
		/* begin rightType: */
		if ((header1 & (SIZE_MASK)) == 0) {
			type = HeaderTypeSizeAndClass;
			goto l5;
		} else {
			if ((header1 & CompactClassMask) == 0) {
				type = HeaderTypeClass;
				goto l5;
			} else {
				type = HeaderTypeShort;
				goto l5;
			}
		}
	l5:	/* end rightType: */;
		if (type == HeaderTypeSizeAndClass) {
			sz = (longAt(array1 - ((BYTES_PER_WORD) * 2))) & (ALL_BUT_TYPE_MASK);
			goto l6;
		} else {
			sz = header1 & (SIZE_MASK);
			goto l6;
		}
	l6:	/* end sizeBitsOfSafe: */;
		fieldOffset = sz - (BASE_HEADER_SIZE);
		goto l4;
	}
	if (fmt < 12) {
		fieldOffset = 0;
		goto l4;
	}
	methodHeader = longAt(array1 + (BASE_HEADER_SIZE));
	fieldOffset = (((((usqInt) methodHeader) >> 10) & 255) * (BYTES_PER_WORD)) + (BASE_HEADER_SIZE);
l4:	/* end lastPointerOf: */;
	while (fieldOffset >= (BASE_HEADER_SIZE)) {
		oop1 = longAt(array1 + fieldOffset);

		/* if oop1 == oop2, no need to do any work for this pair.
			May still be other entries in the arrays though so keep looking */

		oop2 = longAt(array2 + fieldOffset);
		if (!(oop1 == oop2)) {
			/* begin fwdBlockGet: */
			fwdTableNext += fwdBlkSize;
			if (fwdTableNext <= fwdTableLast) {
				fwdBlock = fwdTableNext;
				goto l2;
			} else {
				fwdBlock = null;
				goto l2;
			}
		l2:	/* end fwdBlockGet: */;
			/* begin initForwardBlock:mapping:to:withBackPtr: */
			originalHeader1 = longAt(oop1);
			if (DoAssertionChecks) {
				if (fwdBlock == null) {
					error("ran out of forwarding blocks in become");
				}
				if ((originalHeader1 & (MARK_BIT)) != 0) {
					error("object already has a forwarding table entry");
				}
			}
			originalHeaderType1 = originalHeader1 & TypeMask;
			longAtput(fwdBlock, oop2);
			longAtput(fwdBlock + (BYTES_PER_WORD), originalHeader1);
			if (!twoWayFlag) {
				longAtput(fwdBlock + ((BYTES_PER_WORD) * 2), oop1);
			}
			longAtput(oop1, (((usqInt) fwdBlock) >> 1) | ((MARK_BIT) | originalHeaderType1));
			if (twoWayFlag) {

				/* Second block maps oop2 back to oop1 for two-way become */

				/* begin fwdBlockGet: */
				fwdTableNext += fwdBlkSize;
				if (fwdTableNext <= fwdTableLast) {
					fwdBlock = fwdTableNext;
					goto l1;
				} else {
					fwdBlock = null;
					goto l1;
				}
			l1:	/* end fwdBlockGet: */;
				/* begin initForwardBlock:mapping:to:withBackPtr: */
				originalHeader = longAt(oop2);
				if (DoAssertionChecks) {
					if (fwdBlock == null) {
						error("ran out of forwarding blocks in become");
					}
					if ((originalHeader & (MARK_BIT)) != 0) {
						error("object already has a forwarding table entry");
					}
				}
				originalHeaderType = originalHeader & TypeMask;
				longAtput(fwdBlock, oop1);
				longAtput(fwdBlock + (BYTES_PER_WORD), originalHeader);
				if (!twoWayFlag) {
					longAtput(fwdBlock + ((BYTES_PER_WORD) * 2), oop2);
				}
				longAtput(oop2, (((usqInt) fwdBlock) >> 1) | ((MARK_BIT) | originalHeaderType));
			}
		}
		fieldOffset -= BYTES_PER_WORD;
	}
	return 1;
}

sqInt primitiveAdd(void) {
    sqInt integerResult;
    sqInt sp;

	/* begin pop2AndPushIntegerIfOK: */
	integerResult = (stackIntegerValue(1)) + (stackIntegerValue(0));
	if (!primFailCode) {
		if (
# ifdef SQ_HOST32  // cast to int for 64 bit image on 32 bit host
			(((((int) integerResult)) ^ ((((int) integerResult)) << 1)) >= 0)
# else
			((integerResult >= -1073741824) && (integerResult <= 1073741823))
# endif  // SQ_HOST32
		) {
			/* begin pop:thenPush: */
			longAtput((sp = stackPointer - ((2 - 1) * (BYTES_PER_WORD))), ((integerResult << 1) | 1));
			stackPointer = sp;
		} else {
			/* begin primitiveFail */
			if (primFailCode == 0) {
				primFailCode = 1;
			}
		}
	}
	return null;
}


/*	Primitive arithmetic operations for large integers in 64 bit range */

EXPORT(sqInt) primitiveAddLargeIntegers(void) {
    usqLong a;
    sqInt aIsNegative;
    usqLong b;
    sqInt bIsNegative;
    sqInt oopArg;
    sqInt oopRcvr;
    sqInt oopResult;
    usqLong result;
    sqInt resultIsNegative;
    sqInt sp;

	oopArg = longAt(stackPointer - (0 * (BYTES_PER_WORD)));
	oopRcvr = longAt(stackPointer - (1 * (BYTES_PER_WORD)));
	aIsNegative = isNegativeIntegerValueOf(oopRcvr);
	bIsNegative = isNegativeIntegerValueOf(oopArg);
	a = magnitude64BitValueOf(oopRcvr);
	b = magnitude64BitValueOf(oopArg);
	if (!(!primFailCode)) {
		return null;
	}
	if (aIsNegative == bIsNegative) {

		/* Protect against overflow */

		if (a > (18446744073709551615U - b)) {
			/* begin primitiveFail */
			if (primFailCode == 0) {
				primFailCode = 1;
			}
			return null;
		}
		result = a + b;
		resultIsNegative = aIsNegative;
	} else {
		if (a >= b) {
			result = a - b;
			resultIsNegative = aIsNegative;
		} else {
			result = b - a;
			resultIsNegative = bIsNegative;
		}
	}
	oopResult = magnitude64BitIntegerForneg(result, resultIsNegative);
	if (!primFailCode) {
		/* begin pop:thenPush: */
		longAtput((sp = stackPointer - ((2 - 1) * (BYTES_PER_WORD))), oopResult);
		stackPointer = sp;
	}
	return null;
}


/*	Primitive. Change the class of the argument to make it an instance of the receiver
	 given that the format of the receiver matches the format of the argument's class.
	 Fail if receiver or argument are SmallIntegers, or the receiver is an instance of a
	 compact class and the argument isn't, or when the argument's class is compact and
	 the receiver isn't, or when the format of the receiver is different from the format of
	 the argument's class, or when the arguments class is fixed and the receiver's size
	 differs from the size that an instance of the argument's class should have. */

sqInt primitiveAdoptInstance(void) {
    sqInt arg;
    sqInt err;
    sqInt rcvr;
    sqInt i;
    sqInt oop;
    sqInt oop1;

	/* begin stackObjectValue: */
	oop = longAt(stackPointer - (0 * (BYTES_PER_WORD)));
	if ((oop & 1)) {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		arg = null;
		goto l1;
	}
	arg = oop;
l1:	/* end stackObjectValue: */;
	/* begin stackObjectValue: */
	oop1 = longAt(stackPointer - (1 * (BYTES_PER_WORD)));
	if ((oop1 & 1)) {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		rcvr = null;
		goto l2;
	}
	rcvr = oop1;
l2:	/* end stackObjectValue: */;
	err = changeClassOfto(arg, rcvr);
	if (err == 0) {

		/* Flush at cache because rcvr's class has changed. */

		/* begin flushAtCache */
		for (i = 1; i <= AtCacheTotalSize; i += 1) {
			atCache[i] = 0;
		}
		/* begin pop: */
		stackPointer -= argumentCount * (BYTES_PER_WORD);
	} else {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
	}
	return null;
}


/*	Answer an array of all objects that exist when the primitive
	 is called, excluding those that may be garbage collected as
	 a side effect of allocating the result array. */

EXPORT(sqInt) primitiveAllObjects(void) {
    sqInt result;
    sqInt sp;
    sqInt count;
    sqInt newCount;
    sqInt obj;
    sqInt resultArray;
    sqInt obj1;
    sqInt obj2;
    sqInt sz;
    sqInt header;
    sqInt sz1;
    sqInt header1;
    sqInt sz2;
    sqInt header2;
    sqInt sz3;
    sqInt header3;
    sqInt obj3;
    sqInt sz4;
    sqInt header4;
    sqInt obj4;
    sqInt sz5;
    sqInt header5;

	/* begin allObjects */
	count = 0;
	/* begin firstAccessibleObject */
	obj3 = memory + (headerTypeBytes[(longAt(memory)) & TypeMask]);
	while ((((usqInt) obj3)) < (((usqInt) endOfMemory))) {
		if (!(((longAt(obj3)) & TypeMask) == HeaderTypeFree)) {
			obj = obj3;
			goto l9;
		}
		/* begin objectAfter: */
		if (DoAssertionChecks) {
			if ((((usqInt) obj3)) >= (((usqInt) endOfMemory))) {
				error("no objects after the end of memory");
			}
		}
		if (((longAt(obj3)) & TypeMask) == HeaderTypeFree) {
			sz4 = (longAt(obj3)) & (ALL_BUT_TYPE_MASK);
		} else {
			/* begin sizeBitsOf: */
			header4 = longAt(obj3);
			if ((header4 & TypeMask) == HeaderTypeSizeAndClass) {
				sz4 = (longAt(obj3 - ((BYTES_PER_WORD) * 2))) & (LONG_SIZE_MASK);
				goto l8;
			} else {
				sz4 = header4 & (SIZE_MASK);
				goto l8;
			}
		l8:	/* end sizeBitsOf: */;
		}
		obj3 = (obj3 + sz4) + (headerTypeBytes[(longAt(obj3 + sz4)) & TypeMask]);
	}
	error("heap is empty");
l9:	/* end firstAccessibleObject */;
	while (!(obj == null)) {
		count += 1;
		/* begin accessibleObjectAfter: */
		/* begin objectAfter: */
		if (DoAssertionChecks) {
			if ((((usqInt) obj)) >= (((usqInt) endOfMemory))) {
				error("no objects after the end of memory");
			}
		}
		if (((longAt(obj)) & TypeMask) == HeaderTypeFree) {
			sz1 = (longAt(obj)) & (ALL_BUT_TYPE_MASK);
		} else {
			/* begin sizeBitsOf: */
			header1 = longAt(obj);
			if ((header1 & TypeMask) == HeaderTypeSizeAndClass) {
				sz1 = (longAt(obj - ((BYTES_PER_WORD) * 2))) & (LONG_SIZE_MASK);
				goto l5;
			} else {
				sz1 = header1 & (SIZE_MASK);
				goto l5;
			}
		l5:	/* end sizeBitsOf: */;
		}
		obj1 = (obj + sz1) + (headerTypeBytes[(longAt(obj + sz1)) & TypeMask]);
		while ((((usqInt) obj1)) < (((usqInt) endOfMemory))) {
			if (!(((longAt(obj1)) & TypeMask) == HeaderTypeFree)) {
				obj = obj1;
				goto l1;
			}
			/* begin objectAfter: */
			if (DoAssertionChecks) {
				if ((((usqInt) obj1)) >= (((usqInt) endOfMemory))) {
					error("no objects after the end of memory");
				}
			}
			if (((longAt(obj1)) & TypeMask) == HeaderTypeFree) {
				sz = (longAt(obj1)) & (ALL_BUT_TYPE_MASK);
			} else {
				/* begin sizeBitsOf: */
				header = longAt(obj1);
				if ((header & TypeMask) == HeaderTypeSizeAndClass) {
					sz = (longAt(obj1 - ((BYTES_PER_WORD) * 2))) & (LONG_SIZE_MASK);
					goto l4;
				} else {
					sz = header & (SIZE_MASK);
					goto l4;
				}
			l4:	/* end sizeBitsOf: */;
			}
			obj1 = (obj1 + sz) + (headerTypeBytes[(longAt(obj1 + sz)) & TypeMask]);
		}
		obj = null;
	l1:	/* end accessibleObjectAfter: */;
	}
	resultArray = instantiateClassindexableSize(longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassArray << (SHIFT_FOR_WORD))), count);
	if (resultArray == null) {
		result = 0;
		goto l3;
	}
	newCount = 0;
	/* begin firstAccessibleObject */
	obj4 = memory + (headerTypeBytes[(longAt(memory)) & TypeMask]);
	while ((((usqInt) obj4)) < (((usqInt) endOfMemory))) {
		if (!(((longAt(obj4)) & TypeMask) == HeaderTypeFree)) {
			obj = obj4;
			goto l11;
		}
		/* begin objectAfter: */
		if (DoAssertionChecks) {
			if ((((usqInt) obj4)) >= (((usqInt) endOfMemory))) {
				error("no objects after the end of memory");
			}
		}
		if (((longAt(obj4)) & TypeMask) == HeaderTypeFree) {
			sz5 = (longAt(obj4)) & (ALL_BUT_TYPE_MASK);
		} else {
			/* begin sizeBitsOf: */
			header5 = longAt(obj4);
			if ((header5 & TypeMask) == HeaderTypeSizeAndClass) {
				sz5 = (longAt(obj4 - ((BYTES_PER_WORD) * 2))) & (LONG_SIZE_MASK);
				goto l10;
			} else {
				sz5 = header5 & (SIZE_MASK);
				goto l10;
			}
		l10:	/* end sizeBitsOf: */;
		}
		obj4 = (obj4 + sz5) + (headerTypeBytes[(longAt(obj4 + sz5)) & TypeMask]);
	}
	error("heap is empty");
l11:	/* end firstAccessibleObject */;
	while (!((obj == null) || (newCount >= count))) {
		if (!(obj == resultArray)) {
			newCount += 1;
			stObjectatput(resultArray, newCount, obj);
		}
		/* begin accessibleObjectAfter: */
		/* begin objectAfter: */
		if (DoAssertionChecks) {
			if ((((usqInt) obj)) >= (((usqInt) endOfMemory))) {
				error("no objects after the end of memory");
			}
		}
		if (((longAt(obj)) & TypeMask) == HeaderTypeFree) {
			sz3 = (longAt(obj)) & (ALL_BUT_TYPE_MASK);
		} else {
			/* begin sizeBitsOf: */
			header3 = longAt(obj);
			if ((header3 & TypeMask) == HeaderTypeSizeAndClass) {
				sz3 = (longAt(obj - ((BYTES_PER_WORD) * 2))) & (LONG_SIZE_MASK);
				goto l7;
			} else {
				sz3 = header3 & (SIZE_MASK);
				goto l7;
			}
		l7:	/* end sizeBitsOf: */;
		}
		obj2 = (obj + sz3) + (headerTypeBytes[(longAt(obj + sz3)) & TypeMask]);
		while ((((usqInt) obj2)) < (((usqInt) endOfMemory))) {
			if (!(((longAt(obj2)) & TypeMask) == HeaderTypeFree)) {
				obj = obj2;
				goto l2;
			}
			/* begin objectAfter: */
			if (DoAssertionChecks) {
				if ((((usqInt) obj2)) >= (((usqInt) endOfMemory))) {
					error("no objects after the end of memory");
				}
			}
			if (((longAt(obj2)) & TypeMask) == HeaderTypeFree) {
				sz2 = (longAt(obj2)) & (ALL_BUT_TYPE_MASK);
			} else {
				/* begin sizeBitsOf: */
				header2 = longAt(obj2);
				if ((header2 & TypeMask) == HeaderTypeSizeAndClass) {
					sz2 = (longAt(obj2 - ((BYTES_PER_WORD) * 2))) & (LONG_SIZE_MASK);
					goto l6;
				} else {
					sz2 = header2 & (SIZE_MASK);
					goto l6;
				}
			l6:	/* end sizeBitsOf: */;
			}
			obj2 = (obj2 + sz2) + (headerTypeBytes[(longAt(obj2 + sz2)) & TypeMask]);
		}
		obj = null;
	l2:	/* end accessibleObjectAfter: */;
	}
	if (newCount < count) {
		shortentoIndexableSize(resultArray, newCount);
	}
	result = resultArray;
l3:	/* end allObjects */;
	if (result == 0) {
		return (primFailCode = PrimErrNoMemory);
	}
	/* begin pop:thenPush: */
	longAtput((sp = stackPointer - (((argumentCount + 1) - 1) * (BYTES_PER_WORD))), result);
	stackPointer = sp;
	return null;
}

sqInt primitiveArctan(void) {
    double rcvr;

	rcvr = popFloat();
	if (!primFailCode) {
		pushFloat(atan(rcvr));
	} else {
		/* begin unPop: */
		stackPointer += 1 * (BYTES_PER_WORD);
	}
	return null;
}


/*	We must flush the method cache here, to eliminate stale references
	to mutated classes and/or selectors. */

sqInt primitiveArrayBecome(void) {
    sqInt arg;
    sqInt rcvr;
    sqInt successBoolean;

	arg = longAt(stackPointer);
	rcvr = longAt(stackPointer - (1 * (BYTES_PER_WORD)));
	/* begin success: */
	successBoolean = becomewithtwoWaycopyHash(rcvr, arg, 1, 1);
	if (!(successBoolean)) {
		if (!primFailCode) {
			primFailCode = 1;
		}
	}
	if (!primFailCode) {
		/* begin pop: */
		stackPointer -= 1 * (BYTES_PER_WORD);
	}
	return null;
}


/*	We must flush the method cache here, to eliminate stale references
	to mutated classes and/or selectors. */

sqInt primitiveArrayBecomeOneWay(void) {
    sqInt arg;
    sqInt rcvr;
    sqInt successBoolean;

	arg = longAt(stackPointer);
	rcvr = longAt(stackPointer - (1 * (BYTES_PER_WORD)));
	/* begin success: */
	successBoolean = becomewithtwoWaycopyHash(rcvr, arg, 0, 1);
	if (!(successBoolean)) {
		if (!primFailCode) {
			primFailCode = 1;
		}
	}
	if (!primFailCode) {
		/* begin pop: */
		stackPointer -= 1 * (BYTES_PER_WORD);
	}
	return null;
}


/*	Similar to primitiveArrayBecomeOneWay but accepts a third argument whether to copy
	the receiver's identity hash over the argument's identity hash. */

sqInt primitiveArrayBecomeOneWayCopyHash(void) {
    sqInt arg;
    sqInt copyHashFlag;
    sqInt rcvr;
    sqInt successBoolean;

	/* begin booleanValueOf: */
	if ((longAt(stackPointer)) == trueObj) {
		copyHashFlag = 1;
		goto l1;
	}
	if ((longAt(stackPointer)) == falseObj) {
		copyHashFlag = 0;
		goto l1;
	}
	/* begin primitiveFail */
	if (primFailCode == 0) {
		primFailCode = 1;
	}
	copyHashFlag = null;
l1:	/* end booleanValueOf: */;
	arg = longAt(stackPointer - (1 * (BYTES_PER_WORD)));
	rcvr = longAt(stackPointer - (2 * (BYTES_PER_WORD)));
	/* begin success: */
	successBoolean = becomewithtwoWaycopyHash(rcvr, arg, 0, copyHashFlag);
	if (!(successBoolean)) {
		if (!primFailCode) {
			primFailCode = 1;
		}
	}
	if (!primFailCode) {
		/* begin pop: */
		stackPointer -= 2 * (BYTES_PER_WORD);
	}
	return null;
}

sqInt primitiveAsFloat(void) {
    sqInt arg;
    sqInt integerPointer;
    sqInt top;

	/* begin popInteger */
	/* begin popStack */
	top = longAt(stackPointer);
	stackPointer -= BYTES_PER_WORD;
	integerPointer = top;
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		arg = (integerPointer >> 1);
		goto l1;
	} else {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		arg = 0;
		goto l1;
	}
	arg = null;
l1:	/* end popInteger */;
	if (!primFailCode) {
		pushFloat(((double) arg));
	} else {
		/* begin unPop: */
		stackPointer += 1 * (BYTES_PER_WORD);
	}
	return null;
}

void primitiveAsOop(void) {
    sqInt thisReceiver;
    sqInt sp;

	thisReceiver = longAt(stackPointer);
	/* begin success: */
	if (!(!((thisReceiver & 1)))) {
		if (!primFailCode) {
			primFailCode = 1;
		}
	}
	if (!primFailCode) {
		/* begin pop:thenPushInteger: */
		longAtput((sp = stackPointer - ((1 - 1) * (BYTES_PER_WORD))), ((((((usqInt) (longAt(thisReceiver))) >> 17) & 4095) << 1) | 1));
		stackPointer = sp;
	}
}

sqInt primitiveAt(void) {
	commonAt(0);
	return null;
}

sqInt primitiveAtPut(void) {
	commonAtPut(0);
	return null;
}


/*	Set the cursor to the given shape. The Mac only supports 16x16 pixel cursors. Cursor offsets are handled by Smalltalk. */

sqInt primitiveBeCursor(void) {
    sqInt bitsObj;
    sqInt cursorBitsIndex;
    sqInt cursorObj;
    sqInt depth;
    sqInt extentX;
    sqInt extentY;
    sqInt i;
    sqInt maskBitsIndex;
    sqInt maskObj;
    sqInt offsetObj;
    sqInt offsetX;
    sqInt offsetY;
    sqInt ourCursor;
    sqInt successBoolean;
    sqInt successBoolean1;
    sqInt successBoolean2;
    sqInt successBoolean3;
    sqInt successBoolean4;
    sqInt successBoolean5;
    sqInt successBoolean6;
    sqInt successBoolean7;
    sqInt successBoolean8;
    sqInt successBoolean9;
    sqInt successBoolean10;
    sqInt successBoolean11;
    sqInt successBoolean12;

	if (argumentCount == 0) {
		cursorObj = longAt(stackPointer);
		maskBitsIndex = null;
	}
	if (argumentCount == 1) {
		cursorObj = longAt(stackPointer - (1 * (BYTES_PER_WORD)));
		maskObj = longAt(stackPointer);
	}
	/* begin success: */
	if (!(argumentCount < 2)) {
		if (!primFailCode) {
			primFailCode = 1;
		}
	}
	/* begin success: */
	successBoolean11 = (((cursorObj & 1) == 0) && (((((usqInt) (longAt(cursorObj))) >> 8) & 15) <= 4)) && ((lengthOf(cursorObj)) >= 5);
	if (!(successBoolean11)) {
		if (!primFailCode) {
			primFailCode = 1;
		}
	}
	if (!primFailCode) {
		bitsObj = longAt((cursorObj + (BASE_HEADER_SIZE)) + (0 << (SHIFT_FOR_WORD)));
		extentX = fetchIntegerofObject(1, cursorObj);
		extentY = fetchIntegerofObject(2, cursorObj);
		depth = fetchIntegerofObject(3, cursorObj);
		offsetObj = longAt((cursorObj + (BASE_HEADER_SIZE)) + (4 << (SHIFT_FOR_WORD)));
	}
	/* begin success: */
	successBoolean12 = (((offsetObj & 1) == 0) && (((((usqInt) (longAt(offsetObj))) >> 8) & 15) <= 4)) && ((lengthOf(offsetObj)) >= 2);
	if (!(successBoolean12)) {
		if (!primFailCode) {
			primFailCode = 1;
		}
	}
	if (!primFailCode) {
		offsetX = fetchIntegerofObject(0, offsetObj);
		offsetY = fetchIntegerofObject(1, offsetObj);
		if ((argumentCount == 0) && (depth == 32)) {

			/* Support arbitrary-sized 32 bit ARGB forms --bf 3/1/2007 23:51 */

			/* begin success: */
			successBoolean = (extentX > 0) && (extentY > 0);
			if (!(successBoolean)) {
				if (!primFailCode) {
					primFailCode = 1;
				}
			}
			/* begin success: */
			successBoolean1 = (offsetX >= (extentX * -1)) && (offsetX <= 0);
			if (!(successBoolean1)) {
				if (!primFailCode) {
					primFailCode = 1;
				}
			}
			/* begin success: */
			successBoolean2 = (offsetY >= (extentY * -1)) && (offsetY <= 0);
			if (!(successBoolean2)) {
				if (!primFailCode) {
					primFailCode = 1;
				}
			}
			cursorBitsIndex = bitsObj + (BASE_HEADER_SIZE);
			/* begin success: */
			successBoolean3 = (((bitsObj & 1) == 0) && (((((usqInt) (longAt(bitsObj))) >> 8) & 15) == 6)) && ((lengthOf(bitsObj)) == (extentX * extentY));
			if (!(successBoolean3)) {
				if (!primFailCode) {
					primFailCode = 1;
				}
			}
			;
		} else {
			/* begin success: */
			successBoolean4 = (extentX == 16) && ((extentY == 16) && (depth == 1));
			if (!(successBoolean4)) {
				if (!primFailCode) {
					primFailCode = 1;
				}
			}
			/* begin success: */
			successBoolean5 = (offsetX >= -16) && (offsetX <= 0);
			if (!(successBoolean5)) {
				if (!primFailCode) {
					primFailCode = 1;
				}
			}
			/* begin success: */
			successBoolean6 = (offsetY >= -16) && (offsetY <= 0);
			if (!(successBoolean6)) {
				if (!primFailCode) {
					primFailCode = 1;
				}
			}
			/* begin success: */
			successBoolean7 = (((bitsObj & 1) == 0) && (((((usqInt) (longAt(bitsObj))) >> 8) & 15) == 6)) && ((lengthOf(bitsObj)) == 16);
			if (!(successBoolean7)) {
				if (!primFailCode) {
					primFailCode = 1;
				}
			}
			cursorBitsIndex = bitsObj + (BASE_HEADER_SIZE);
			;
		}
	}
	if (argumentCount == 1) {
		/* begin success: */
		successBoolean10 = (((maskObj & 1) == 0) && (((((usqInt) (longAt(maskObj))) >> 8) & 15) <= 4)) && ((lengthOf(maskObj)) >= 5);
		if (!(successBoolean10)) {
			if (!primFailCode) {
				primFailCode = 1;
			}
		}
		if (!primFailCode) {
			bitsObj = longAt((maskObj + (BASE_HEADER_SIZE)) + (0 << (SHIFT_FOR_WORD)));
			extentX = fetchIntegerofObject(1, maskObj);
			extentY = fetchIntegerofObject(2, maskObj);
			depth = fetchIntegerofObject(3, maskObj);
		}
		if (!primFailCode) {
			/* begin success: */
			successBoolean8 = (extentX == 16) && ((extentY == 16) && (depth == 1));
			if (!(successBoolean8)) {
				if (!primFailCode) {
					primFailCode = 1;
				}
			}
			/* begin success: */
			successBoolean9 = (((bitsObj & 1) == 0) && (((((usqInt) (longAt(bitsObj))) >> 8) & 15) == 6)) && ((lengthOf(bitsObj)) == 16);
			if (!(successBoolean9)) {
				if (!primFailCode) {
					primFailCode = 1;
				}
			}
			maskBitsIndex = bitsObj + (BASE_HEADER_SIZE);
		}
	}
	if (!primFailCode) {
		if (argumentCount == 0) {
			if (depth == 32) {
				if (!(ioSetCursorARGB(cursorBitsIndex, extentX, extentY, offsetX, offsetY))) {
					/* begin success: */
					if (!(0)) {
						if (!primFailCode) {
							primFailCode = 1;
						}
					}
					return null;
				}
			} else {
				ioSetCursor(cursorBitsIndex, offsetX, offsetY);
			}
		} else {
			ioSetCursorWithMask(cursorBitsIndex, maskBitsIndex, offsetX, offsetY);
		}
		/* begin pop: */
		stackPointer -= argumentCount * (BYTES_PER_WORD);
	}
	return null;
}


/*	Record the system Display object in the specialObjectsTable. */

sqInt primitiveBeDisplay(void) {
    sqInt rcvr;
    sqInt successBoolean;

	rcvr = longAt(stackPointer);
	/* begin success: */
	successBoolean = (((rcvr & 1) == 0) && (((((usqInt) (longAt(rcvr))) >> 8) & 15) <= 4)) && ((lengthOf(rcvr)) >= 4);
	if (!(successBoolean)) {
		if (!primFailCode) {
			primFailCode = 1;
		}
	}
	if (!primFailCode) {
		/* begin storePointer:ofObject:withValue: */
		if ((((usqInt) specialObjectsOop)) < (((usqInt) youngStart))) {
			possibleRootStoreIntovalue(specialObjectsOop, rcvr);
		}
		longAtput((specialObjectsOop + (BASE_HEADER_SIZE)) + (TheDisplay << (SHIFT_FOR_WORD)), rcvr);
	}
	return null;
}


/*	make the basic beep noise */

sqInt primitiveBeep(void) {
	ioBeep();
	return null;
}

sqInt primitiveBehaviorHash(void) {
    sqInt hashOrError;
    sqInt sp;

	assert(!(((stackTop()) & 1)));
	hashOrError = (((usqInt) (longAt(longAt(stackPointer)))) >> 17) & 4095;
	if (hashOrError >= 0) {
		/* begin pop:thenPushInteger: */
		longAtput((sp = stackPointer - ((1 - 1) * (BYTES_PER_WORD))), ((hashOrError << 1) | 1));
		stackPointer = sp;
	} else {
		primFailCode = -hashOrError;
	}
	return null;
}

sqInt primitiveBitAnd(void) {
    sqInt integerArgument;
    sqInt integerReceiver;
    sqInt object;
    sqInt sp;
    sqInt top;
    sqInt top1;
    sqInt top2;
    sqInt top11;

	/* begin popPos32BitInteger */
	/* begin popStack */
	top1 = longAt(stackPointer);
	stackPointer -= BYTES_PER_WORD;
	top = top1;
	integerArgument = positive32BitValueOf(top);
	/* begin popPos32BitInteger */
	/* begin popStack */
	top11 = longAt(stackPointer);
	stackPointer -= BYTES_PER_WORD;
	top2 = top11;
	integerReceiver = positive32BitValueOf(top2);
	if (!primFailCode) {
		/* begin push: */
		object = positive32BitIntegerFor(integerReceiver & integerArgument);
		longAtput((sp = stackPointer + (BYTES_PER_WORD)), object);
		stackPointer = sp;
	} else {
		/* begin unPop: */
		stackPointer += 2 * (BYTES_PER_WORD);
	}
	return null;
}


/*	Primitive logical operations for large integers in 64 bit range */

EXPORT(sqInt) primitiveBitAndLargeIntegers(void) {
    sqLong integerArg;
    sqLong integerRcvr;
    sqInt oopResult;
    sqInt sp;

	integerArg = positive64BitValueOf(longAt(stackPointer - (0 * (BYTES_PER_WORD))));
	integerRcvr = positive64BitValueOf(longAt(stackPointer - (1 * (BYTES_PER_WORD))));
	if (!(!primFailCode)) {
		return null;
	}
	oopResult = positive64BitIntegerFor(integerRcvr & integerArg);
	if (!primFailCode) {
		/* begin pop:thenPush: */
		longAtput((sp = stackPointer - ((2 - 1) * (BYTES_PER_WORD))), oopResult);
		stackPointer = sp;
	}
	return null;
}

sqInt primitiveBitOr(void) {
    sqInt integerArgument;
    sqInt integerReceiver;
    sqInt object;
    sqInt sp;
    sqInt top;
    sqInt top1;
    sqInt top2;
    sqInt top11;

	/* begin popPos32BitInteger */
	/* begin popStack */
	top1 = longAt(stackPointer);
	stackPointer -= BYTES_PER_WORD;
	top = top1;
	integerArgument = positive32BitValueOf(top);
	/* begin popPos32BitInteger */
	/* begin popStack */
	top11 = longAt(stackPointer);
	stackPointer -= BYTES_PER_WORD;
	top2 = top11;
	integerReceiver = positive32BitValueOf(top2);
	if (!primFailCode) {
		/* begin push: */
		object = positive32BitIntegerFor(integerReceiver | integerArgument);
		longAtput((sp = stackPointer + (BYTES_PER_WORD)), object);
		stackPointer = sp;
	} else {
		/* begin unPop: */
		stackPointer += 2 * (BYTES_PER_WORD);
	}
	return null;
}


/*	Primitive logical operations for large integers in 64 bit range */

EXPORT(sqInt) primitiveBitOrLargeIntegers(void) {
    sqLong integerArg;
    sqLong integerRcvr;
    sqInt oopResult;
    sqInt sp;

	integerArg = positive64BitValueOf(longAt(stackPointer - (0 * (BYTES_PER_WORD))));
	integerRcvr = positive64BitValueOf(longAt(stackPointer - (1 * (BYTES_PER_WORD))));
	if (!(!primFailCode)) {
		return null;
	}
	oopResult = positive64BitIntegerFor(integerRcvr | integerArg);
	if (!primFailCode) {
		/* begin pop:thenPush: */
		longAtput((sp = stackPointer - ((2 - 1) * (BYTES_PER_WORD))), oopResult);
		stackPointer = sp;
	}
	return null;
}

sqInt primitiveBitShift(void) {
    sqInt integerArgument;
    sqInt integerReceiver;
    unsigned shifted;
    sqInt object;
    sqInt sp;
    sqInt top;
    sqInt top1;
    sqInt integerPointer;
    sqInt top2;

	/* begin popInteger */
	/* begin popStack */
	top2 = longAt(stackPointer);
	stackPointer -= BYTES_PER_WORD;
	integerPointer = top2;
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		integerArgument = (integerPointer >> 1);
		goto l1;
	} else {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		integerArgument = 0;
		goto l1;
	}
	integerArgument = null;
l1:	/* end popInteger */;
	/* begin popPos32BitInteger */
	/* begin popStack */
	top1 = longAt(stackPointer);
	stackPointer -= BYTES_PER_WORD;
	top = top1;
	integerReceiver = positive32BitValueOf(top);
	if (!primFailCode) {
		if (integerArgument >= 0) {

			/* Left shift -- must fail if we lose bits beyond 32 */

			/* begin success: */
			if (!(integerArgument <= 31)) {
				if (!primFailCode) {
					primFailCode = 1;
				}
			}
			shifted = integerReceiver << integerArgument;
			/* begin success: */
			if (!((((usqInt) shifted) >> integerArgument) == integerReceiver)) {
				if (!primFailCode) {
					primFailCode = 1;
				}
			}
		} else {

			/* Right shift -- OK to lose bits */

			/* begin success: */
			if (!(integerArgument >= -31)) {
				if (!primFailCode) {
					primFailCode = 1;
				}
			}
			shifted = ((usqInt) integerReceiver) >> (0 - integerArgument);
		}
	}
	if (!primFailCode) {
		/* begin push: */
		object = positive32BitIntegerFor(shifted);
		longAtput((sp = stackPointer + (BYTES_PER_WORD)), object);
		stackPointer = sp;
	} else {
		/* begin unPop: */
		stackPointer += 2 * (BYTES_PER_WORD);
	}
	return null;
}


/*	Primitive arithmetic operations for large integers in 64 bit range */

EXPORT(sqInt) primitiveBitShiftLargeIntegers(void) {
    usqLong a;
    sqInt aIsNegative;
    sqInt oopRcvr;
    sqInt oopResult;
    usqLong result;
    sqInt shift;
    sqInt sp;
    sqInt integerPointer;

	/* begin stackIntegerValue: */
	integerPointer = longAt(stackPointer - (0 * (BYTES_PER_WORD)));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		shift = (integerPointer >> 1);
		goto l1;
	} else {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		shift = 0;
		goto l1;
	}
	shift = null;
l1:	/* end stackIntegerValue: */;
	oopRcvr = longAt(stackPointer - (1 * (BYTES_PER_WORD)));
	aIsNegative = isNegativeIntegerValueOf(oopRcvr);
	a = magnitude64BitValueOf(oopRcvr);
	if (!(!primFailCode)) {
		return null;
	}
	if (shift >= 0) {

		/* Protect against overflow */


		/* This is to avoid undue (usqInt) cast */

		result = 18446744073709551615U;
		if ((shift >= 64) || (a > (((usqInt) result) >> shift))) {
			/* begin primitiveFail */
			if (primFailCode == 0) {
				primFailCode = 1;
			}
			return null;
		}
		result = a << shift;
	} else {
		shift = 0 - shift;
		if (shift >= 64) {
			result = 0;
		} else {
			result = ((usqInt) a) >> shift;
		}
		if (aIsNegative && ((result << shift) != a)) {
			result += 1;
		}
	}
	oopResult = magnitude64BitIntegerForneg(result, aIsNegative);
	if (!primFailCode) {
		/* begin pop:thenPush: */
		longAtput((sp = stackPointer - ((2 - 1) * (BYTES_PER_WORD))), oopResult);
		stackPointer = sp;
	}
	return null;
}

sqInt primitiveBitXor(void) {
    sqInt integerArgument;
    sqInt integerReceiver;
    sqInt object;
    sqInt sp;
    sqInt top;
    sqInt top1;
    sqInt top2;
    sqInt top11;

	/* begin popPos32BitInteger */
	/* begin popStack */
	top1 = longAt(stackPointer);
	stackPointer -= BYTES_PER_WORD;
	top = top1;
	integerArgument = positive32BitValueOf(top);
	/* begin popPos32BitInteger */
	/* begin popStack */
	top11 = longAt(stackPointer);
	stackPointer -= BYTES_PER_WORD;
	top2 = top11;
	integerReceiver = positive32BitValueOf(top2);
	if (!primFailCode) {
		/* begin push: */
		object = positive32BitIntegerFor(integerReceiver ^ integerArgument);
		longAtput((sp = stackPointer + (BYTES_PER_WORD)), object);
		stackPointer = sp;
	} else {
		/* begin unPop: */
		stackPointer += 2 * (BYTES_PER_WORD);
	}
	return null;
}


/*	Primitive logical operations for large integers in 64 bit range */

EXPORT(sqInt) primitiveBitXorLargeIntegers(void) {
    sqLong integerArg;
    sqLong integerRcvr;
    sqInt oopResult;
    sqInt sp;

	integerArg = positive64BitValueOf(longAt(stackPointer - (0 * (BYTES_PER_WORD))));
	integerRcvr = positive64BitValueOf(longAt(stackPointer - (1 * (BYTES_PER_WORD))));
	if (!(!primFailCode)) {
		return null;
	}
	oopResult = positive64BitIntegerFor(integerRcvr ^ integerArg);
	if (!primFailCode) {
		/* begin pop:thenPush: */
		longAtput((sp = stackPointer - ((2 - 1) * (BYTES_PER_WORD))), oopResult);
		stackPointer = sp;
	}
	return null;
}

void primitiveBlockCopy(void) {
    sqInt context;
    sqInt contextSize;
    sqInt initialIP;
    sqInt methodContext;
    sqInt newContext;
    sqInt header;
    sqInt oop;
    sqInt sp;

	context = longAt(stackPointer - (1 * (BYTES_PER_WORD)));
	if (((longAt((context + (BASE_HEADER_SIZE)) + (MethodIndex << (SHIFT_FOR_WORD)))) & 1)) {

		/* context is a block; get the context of its enclosing method */

		methodContext = longAt((context + (BASE_HEADER_SIZE)) + (HomeIndex << (SHIFT_FOR_WORD)));
	} else {
		methodContext = context;
	}
	/* begin sizeBitsOf: */
	header = longAt(methodContext);
	if ((header & TypeMask) == HeaderTypeSizeAndClass) {
		contextSize = (longAt(methodContext - ((BYTES_PER_WORD) * 2))) & (LONG_SIZE_MASK);
		goto l1;
	} else {
		contextSize = header & (SIZE_MASK);
		goto l1;
	}
l1:	/* end sizeBitsOf: */;

	/* context is no longer needed and is not preserved across allocation */
	/* remap methodContext in case GC happens during allocation */

	context = null;
	/* begin pushRemappableOop: */
	remapBuffer[(remapBufferCount += 1)] = methodContext;
	newContext = instantiateContextsizeInBytes(longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassBlockContext << (SHIFT_FOR_WORD))), contextSize);
	/* begin popRemappableOop */
	oop = remapBuffer[remapBufferCount];
	remapBufferCount -= 1;
	methodContext = oop;

	/* Was instructionPointer + 3, but now it's greater by 1 due to preIncrement */
	/* Assume: have just allocated a new context; it must be young.
	 Thus, can use uncheck stores. See the comment in fetchContextRegisters. */

	initialIP = (((((instructionPointer + 1) + 3) - (method + (BASE_HEADER_SIZE))) << 1) | 1);
	longAtput((newContext + (BASE_HEADER_SIZE)) + (InitialIPIndex << (SHIFT_FOR_WORD)), initialIP);
	longAtput((newContext + (BASE_HEADER_SIZE)) + (InstructionPointerIndex << (SHIFT_FOR_WORD)), initialIP);
	/* begin storeStackPointerValue:inContext: */
	longAtput((newContext + (BASE_HEADER_SIZE)) + (StackPointerIndex << (SHIFT_FOR_WORD)), ((0 << 1) | 1));
	longAtput((newContext + (BASE_HEADER_SIZE)) + (BlockArgumentCountIndex << (SHIFT_FOR_WORD)), longAt(stackPointer - (0 * (BYTES_PER_WORD))));
	longAtput((newContext + (BASE_HEADER_SIZE)) + (HomeIndex << (SHIFT_FOR_WORD)), methodContext);
	longAtput((newContext + (BASE_HEADER_SIZE)) + (SenderIndex << (SHIFT_FOR_WORD)), nilObj);
	/* begin pop:thenPush: */
	longAtput((sp = stackPointer - ((2 - 1) * (BYTES_PER_WORD))), newContext);
	stackPointer = sp;
}


/*	Reports bytes available at this moment. For more meaningful 
	results, calls to this primitive should be preceeded by a full 
	or incremental garbage collection. */

sqInt primitiveBytesLeft(void) {
    sqInt aBool;
    sqInt oop;
    sqInt sp;
    sqInt oop1;
    sqInt sp1;

	if (argumentCount == 0) {

		/* old behavior - just return the size of the free block */

		/* begin pop:thenPush: */
		oop = positive64BitIntegerFor((longAt(freeBlock)) & (ALL_BUT_TYPE_MASK));
		longAtput((sp = stackPointer - ((1 - 1) * (BYTES_PER_WORD))), oop);
		stackPointer = sp;
		return null;
	}
	if (argumentCount == 1) {

		/* new behaviour -including or excluding swap space depending on aBool */

		/* begin booleanValueOf: */
		if ((longAt(stackPointer)) == trueObj) {
			aBool = 1;
			goto l1;
		}
		if ((longAt(stackPointer)) == falseObj) {
			aBool = 0;
			goto l1;
		}
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		aBool = null;
	l1:	/* end booleanValueOf: */;
		if (!(!primFailCode)) {
			return null;
		}
		/* begin pop:thenPush: */
		oop1 = positive64BitIntegerFor(((longAt(freeBlock)) & (ALL_BUT_TYPE_MASK)) + (sqMemoryExtraBytesLeft(aBool)));
		longAtput((sp1 = stackPointer - ((2 - 1) * (BYTES_PER_WORD))), oop1);
		stackPointer = sp1;
		return null;
	}
	/* begin primitiveFail */
	if (primFailCode == 0) {
		primFailCode = 1;
	}
	return null;
}


/*	Perform a function call to a foreign function.
	Only invoked from method containing explicit external call spec.
	Due to this we use the pluggable prim mechanism explicitly here
	(the first literal of any FFI spec'ed method is an ExternalFunction
	and not an array as used in the pluggable primitive mechanism). */

sqInt primitiveCalloutToFFI(void) {
    static void *function = 0;
    static char *functionName = "primitiveCallout";
    static char *moduleName = "SqueakFFIPrims";

	if (function == 0) {
		function = ioLoadExternalFunctionOfLengthFromModuleOfLength(oopForPointer(functionName), 16, oopForPointer(moduleName), 14);
		if (function == 0) {
			/* begin primitiveFail */
			if (primFailCode == 0) {
				primFailCode = 1;
			}
			return null;
		}
	}
	return ((sqInt (*)(void))function)();
}


/*	Primitive. Change the class of the receiver into the class of the argument given that the format of the receiver matches the format of the argument's class. Fail if receiver or argument are SmallIntegers, or the receiver is an instance of a compact class and the argument isn't, or when the argument's class is compact and the receiver isn't, or when the format of the receiver is different from the format of the argument's class, or when the arguments class is fixed and the receiver's size differs from the size that an instance of the argument's class should have. */

sqInt primitiveChangeClass(void) {
    sqInt arg;
    sqInt argClass;
    sqInt rcvr;
    sqInt i;
    sqInt oop;
    sqInt oop1;
    sqInt ccIndex;
    sqInt oop11;

	if (!(argumentCount == 1)) {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		return null;
	}
	/* begin stackObjectValue: */
	oop = longAt(stackPointer - (0 * (BYTES_PER_WORD)));
	if ((oop & 1)) {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		arg = null;
		goto l1;
	}
	arg = oop;
l1:	/* end stackObjectValue: */;
	/* begin stackObjectValue: */
	oop1 = longAt(stackPointer - (1 * (BYTES_PER_WORD)));
	if ((oop1 & 1)) {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		rcvr = null;
		goto l2;
	}
	rcvr = oop1;
l2:	/* end stackObjectValue: */;
	/* begin fetchClassOf: */
	if ((arg & 1)) {
		argClass = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassInteger << (SHIFT_FOR_WORD)));
		goto l3;
	}
	ccIndex = (((usqInt) (longAt(arg))) >> 12) & 31;
	if (ccIndex == 0) {
		argClass = (longAt(arg - (BASE_HEADER_SIZE))) & (ALL_BUT_TYPE_MASK);
		goto l3;
	} else {
		/* begin fetchPointer:ofObject: */
		oop11 = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (CompactClasses << (SHIFT_FOR_WORD)));
		argClass = longAt((oop11 + (BASE_HEADER_SIZE)) + ((ccIndex - 1) << (SHIFT_FOR_WORD)));
		goto l3;
	}
l3:	/* end fetchClassOf: */;
	changeClassOfto(rcvr, argClass);
	if (!primFailCode) {
		/* begin flushAtCache */
		for (i = 1; i <= AtCacheTotalSize; i += 1) {
			atCache[i] = 0;
		}
		/* begin pop: */
		stackPointer -= 1 * (BYTES_PER_WORD);
	}
	return null;
}


/*	Primitive. Change the class of the receiver into the class of the argument given that the format of the receiver matches the format of the argument's class. Fail if receiver or argument are SmallIntegers, or the receiver is an instance of a compact class and the argument isn't, or when the argument's class is compact and the receiver isn't, or when the format of the receiver is different from the format of the argument's class, or when the arguments class is fixed and the receiver's size differs from the size that an instance of the argument's class should have. */

EXPORT(sqInt) primitiveChangeClassWithClass(void) {
    sqInt argClass;
    sqInt rcvr;
    sqInt i;
    sqInt oop;
    sqInt oop1;

	if (!(argumentCount == 1)) {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		return null;
	}
	/* begin stackObjectValue: */
	oop = longAt(stackPointer - (0 * (BYTES_PER_WORD)));
	if ((oop & 1)) {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		argClass = null;
		goto l1;
	}
	argClass = oop;
l1:	/* end stackObjectValue: */;
	/* begin stackObjectValue: */
	oop1 = longAt(stackPointer - (1 * (BYTES_PER_WORD)));
	if ((oop1 & 1)) {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		rcvr = null;
		goto l2;
	}
	rcvr = oop1;
l2:	/* end stackObjectValue: */;
	changeClassOfto(rcvr, argClass);
	if (!primFailCode) {
		/* begin flushAtCache */
		for (i = 1; i <= AtCacheTotalSize; i += 1) {
			atCache[i] = 0;
		}
		/* begin pop: */
		stackPointer -= 1 * (BYTES_PER_WORD);
	}
	return null;
}

sqInt primitiveClass(void) {
    sqInt instance;
    sqInt oop;
    sqInt sp;
    sqInt ccIndex;
    sqInt oop1;

	instance = longAt(stackPointer);
	/* begin pop:thenPush: */
	/* begin fetchClassOf: */
	if ((instance & 1)) {
		oop = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassInteger << (SHIFT_FOR_WORD)));
		goto l1;
	}
	ccIndex = (((usqInt) (longAt(instance))) >> 12) & 31;
	if (ccIndex == 0) {
		oop = (longAt(instance - (BASE_HEADER_SIZE))) & (ALL_BUT_TYPE_MASK);
		goto l1;
	} else {
		/* begin fetchPointer:ofObject: */
		oop1 = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (CompactClasses << (SHIFT_FOR_WORD)));
		oop = longAt((oop1 + (BASE_HEADER_SIZE)) + ((ccIndex - 1) << (SHIFT_FOR_WORD)));
		goto l1;
	}
l1:	/* end fetchClassOf: */;
	longAtput((sp = stackPointer - (((argumentCount + 1) - 1) * (BYTES_PER_WORD))), oop);
	stackPointer = sp;
	return null;
}


/*	When called with a single string argument, post the string to 
	the clipboard. When called with zero arguments, return a 
	string containing the current clipboard contents. */

sqInt primitiveClipboardText(void) {
    sqInt s;
    sqInt sz;
    sqInt sp;

	if (argumentCount == 1) {
		s = longAt(stackPointer);
		if (!(((s & 1) == 0) && (((((usqInt) (longAt(s))) >> 8) & 15) >= 8))) {
			/* begin primitiveFail */
			if (primFailCode == 0) {
				primFailCode = 1;
			}
			return null;
		}
		if (!primFailCode) {
			sz = stSizeOf(s);
			clipboardWriteFromAt(sz, s + (BASE_HEADER_SIZE), 0);
			/* begin pop: */
			stackPointer -= 1 * (BYTES_PER_WORD);
		}
	} else {
		sz = clipboardSize();
		if (!(sufficientSpaceToAllocate(sz))) {
			/* begin primitiveFail */
			if (primFailCode == 0) {
				primFailCode = 1;
			}
			return null;
		}
		s = instantiateClassindexableSize(longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassString << (SHIFT_FOR_WORD))), sz);
		clipboardReadIntoAt(sz, s + (BASE_HEADER_SIZE), 0);
		/* begin pop:thenPush: */
		longAtput((sp = stackPointer - ((1 - 1) * (BYTES_PER_WORD))), s);
		stackPointer = sp;
	}
	return null;
}


/*	Return a shallow copy of the receiver. */

void primitiveClone(void) {
    sqInt newCopy;
    sqInt sp;

	newCopy = clone(longAt(stackPointer));
	if (newCopy == 0) {

		/* not enough memory most likely */

		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		return;
	}
	/* begin pop:thenPush: */
	longAtput((sp = stackPointer - ((1 - 1) * (BYTES_PER_WORD))), newCopy);
	stackPointer = sp;
}

void primitiveClosureCopyWithCopiedValues(void) {
    sqInt copiedValues;
    sqInt i;
    sqInt newClosure;
    sqInt numArgs;
    sqInt numCopiedValues;
    sqInt valuePointer;
    sqInt successBoolean;
    sqInt sz;
    sqInt header;
    sqInt initialIP;
    sqInt newClosure1;
    sqInt sp;
    sqInt integerPointer;

	/* begin stackIntegerValue: */
	integerPointer = longAt(stackPointer - (1 * (BYTES_PER_WORD)));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		numArgs = (integerPointer >> 1);
		goto l2;
	} else {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		numArgs = 0;
		goto l2;
	}
	numArgs = null;
l2:	/* end stackIntegerValue: */;
	copiedValues = longAt(stackPointer);
	/* begin success: */
	successBoolean = (fetchClassOf(copiedValues)) == (longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassArray << (SHIFT_FOR_WORD))));
	if (!(successBoolean)) {
		if (!primFailCode) {
			primFailCode = 1;
		}
	}
	if (!(!primFailCode)) {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		return;
	}
	/* begin fetchWordLengthOf: */
	/* begin sizeBitsOf: */
	header = longAt(copiedValues);
	if ((header & TypeMask) == HeaderTypeSizeAndClass) {
		sz = (longAt(copiedValues - ((BYTES_PER_WORD) * 2))) & (LONG_SIZE_MASK);
		goto l1;
	} else {
		sz = header & (SIZE_MASK);
		goto l1;
	}
l1:	/* end sizeBitsOf: */;
	numCopiedValues = ((usqInt) (sz - (BASE_HEADER_SIZE))) >> (SHIFT_FOR_WORD);
	/* begin closureNumArgs:instructionPointer:numCopiedValues: */
	initialIP = (instructionPointer + 2) - (method + (BASE_HEADER_SIZE));
	newClosure1 = instantiateSmallClasssizeInBytes(longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassBlockClosure << (SHIFT_FOR_WORD))), ((BYTES_PER_WORD) * (ClosureFirstCopiedValueIndex + numCopiedValues)) + (BASE_HEADER_SIZE));
	longAtput((newClosure1 + (BASE_HEADER_SIZE)) + (ClosureStartPCIndex << (SHIFT_FOR_WORD)), ((initialIP << 1) | 1));
	longAtput((newClosure1 + (BASE_HEADER_SIZE)) + (ClosureNumArgsIndex << (SHIFT_FOR_WORD)), ((numArgs << 1) | 1));
	newClosure = newClosure1;
	longAtput((newClosure + (BASE_HEADER_SIZE)) + (ClosureOuterContextIndex << (SHIFT_FOR_WORD)), longAt(stackPointer - (2 * (BYTES_PER_WORD))));
	if (numCopiedValues > 0) {

		/* Allocation may have done a GC and copiedValues may have moved. */

		copiedValues = longAt(stackPointer);
		for (i = 0; i <= (numCopiedValues - 1); i += 1) {

			/* Assume: have just allocated a new BlockClosure; it must be young.
			 Thus, can use unchecked stores. */

			/* begin storePointerUnchecked:ofObject:withValue: */
			valuePointer = longAt((copiedValues + (BASE_HEADER_SIZE)) + (i << (SHIFT_FOR_WORD)));
			longAtput((newClosure + (BASE_HEADER_SIZE)) + ((i + ClosureFirstCopiedValueIndex) << (SHIFT_FOR_WORD)), valuePointer);
		}
	}
	/* begin pop:thenPush: */
	longAtput((sp = stackPointer - ((3 - 1) * (BYTES_PER_WORD))), newClosure);
	stackPointer = sp;
}

void primitiveClosureValue(void) {
    sqInt blockArgumentCount;
    sqInt blockClosure;
    sqInt closureMethod;
    sqInt outerContext;

	blockClosure = longAt(stackPointer - (argumentCount * (BYTES_PER_WORD)));
	blockArgumentCount = ((longAt((blockClosure + (BASE_HEADER_SIZE)) + (ClosureNumArgsIndex << (SHIFT_FOR_WORD)))) >> 1);
	if (!(argumentCount == blockArgumentCount)) {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		return;
	}
	outerContext = longAt((blockClosure + (BASE_HEADER_SIZE)) + (ClosureOuterContextIndex << (SHIFT_FOR_WORD)));
	if (!(((outerContext & 1) == 0) && ((((((usqInt) (longAt(outerContext))) >> 12) & 31) == 13) || ((((((usqInt) (longAt(outerContext))) >> 12) & 31) == 14) || (((((usqInt) (longAt(outerContext))) >> 12) & 31) == 4))))) {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		return;
	}

	/* Check if the closure's method is actually a CompiledMethod. */

	closureMethod = longAt((outerContext + (BASE_HEADER_SIZE)) + (MethodIndex << (SHIFT_FOR_WORD)));
	if (!(((closureMethod & 1) == 0) && (((((usqInt) (longAt(closureMethod))) >> 8) & 15) >= 12))) {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		return;
	}
	activateNewClosureMethod(blockClosure);
	/* begin quickCheckForInterrupts */
	if (((interruptCheckCounter -= 1)) <= 0) {
		checkForInterrupts();
	}
}


/*	An exact clone of primitiveClosureValue except that this version will not
	 check for interrupts on stack overflow. */

void primitiveClosureValueNoContextSwitch(void) {
    sqInt blockArgumentCount;
    sqInt blockClosure;
    sqInt closureMethod;
    sqInt outerContext;

	blockClosure = longAt(stackPointer - (argumentCount * (BYTES_PER_WORD)));
	blockArgumentCount = ((longAt((blockClosure + (BASE_HEADER_SIZE)) + (ClosureNumArgsIndex << (SHIFT_FOR_WORD)))) >> 1);
	if (!(argumentCount == blockArgumentCount)) {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		return;
	}
	outerContext = longAt((blockClosure + (BASE_HEADER_SIZE)) + (ClosureOuterContextIndex << (SHIFT_FOR_WORD)));
	if (!(((outerContext & 1) == 0) && ((((((usqInt) (longAt(outerContext))) >> 12) & 31) == 13) || ((((((usqInt) (longAt(outerContext))) >> 12) & 31) == 14) || (((((usqInt) (longAt(outerContext))) >> 12) & 31) == 4))))) {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		return;
	}

	/* Check if the closure's method is actually a CompiledMethod. */

	closureMethod = longAt((outerContext + (BASE_HEADER_SIZE)) + (MethodIndex << (SHIFT_FOR_WORD)));
	if (!(((closureMethod & 1) == 0) && (((((usqInt) (longAt(closureMethod))) >> 8) & 15) >= 12))) {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		return;
	}
	activateNewClosureMethod(blockClosure);
}

void primitiveClosureValueWithArgs(void) {
    sqInt argumentArray;
    sqInt arraySize;
    sqInt blockArgumentCount;
    sqInt blockClosure;
    sqInt closureMethod;
    sqInt cntxSize;
    sqInt index;
    sqInt outerContext;
    sqInt object;
    sqInt sp;
    sqInt sz;
    sqInt header;
    sqInt sz1;
    sqInt header1;
    sqInt top;

	argumentArray = longAt(stackPointer);
	if (!(((argumentArray & 1) == 0) && (((((usqInt) (longAt(argumentArray))) >> 8) & 15) == 2))) {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		return;
	}
	/* begin fetchWordLengthOf: */
	/* begin sizeBitsOf: */
	header = longAt(argumentArray);
	if ((header & TypeMask) == HeaderTypeSizeAndClass) {
		sz = (longAt(argumentArray - ((BYTES_PER_WORD) * 2))) & (LONG_SIZE_MASK);
		goto l1;
	} else {
		sz = header & (SIZE_MASK);
		goto l1;
	}
l1:	/* end sizeBitsOf: */;
	arraySize = ((usqInt) (sz - (BASE_HEADER_SIZE))) >> (SHIFT_FOR_WORD);
	/* begin fetchWordLengthOf: */
	/* begin sizeBitsOf: */
	header1 = longAt(activeContext);
	if ((header1 & TypeMask) == HeaderTypeSizeAndClass) {
		sz1 = (longAt(activeContext - ((BYTES_PER_WORD) * 2))) & (LONG_SIZE_MASK);
		goto l2;
	} else {
		sz1 = header1 & (SIZE_MASK);
		goto l2;
	}
l2:	/* end sizeBitsOf: */;
	cntxSize = ((usqInt) (sz1 - (BASE_HEADER_SIZE))) >> (SHIFT_FOR_WORD);
	if (!(((((usqInt) ((stackPointer - activeContext) - (BASE_HEADER_SIZE))) >> (SHIFT_FOR_WORD)) + arraySize) < cntxSize)) {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		return;
	}
	blockClosure = longAt(stackPointer - (argumentCount * (BYTES_PER_WORD)));
	blockArgumentCount = ((longAt((blockClosure + (BASE_HEADER_SIZE)) + (ClosureNumArgsIndex << (SHIFT_FOR_WORD)))) >> 1);
	if (!(arraySize == blockArgumentCount)) {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		return;
	}
	outerContext = longAt((blockClosure + (BASE_HEADER_SIZE)) + (ClosureOuterContextIndex << (SHIFT_FOR_WORD)));
	if (!(((outerContext & 1) == 0) && ((((((usqInt) (longAt(outerContext))) >> 12) & 31) == 13) || ((((((usqInt) (longAt(outerContext))) >> 12) & 31) == 14) || (((((usqInt) (longAt(outerContext))) >> 12) & 31) == 4))))) {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		return;
	}

	/* Check if the closure's method is actually a CompiledMethod. */

	closureMethod = longAt((outerContext + (BASE_HEADER_SIZE)) + (MethodIndex << (SHIFT_FOR_WORD)));
	if (!(((closureMethod & 1) == 0) && (((((usqInt) (longAt(closureMethod))) >> 8) & 15) >= 12))) {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		return;
	}
	/* begin popStack */
	top = longAt(stackPointer);
	stackPointer -= BYTES_PER_WORD;
	index = 1;
	while (index <= arraySize) {
		/* begin push: */
		object = longAt((argumentArray + (BASE_HEADER_SIZE)) + ((index - 1) << (SHIFT_FOR_WORD)));
		longAtput((sp = stackPointer + (BYTES_PER_WORD)), object);
		stackPointer = sp;
		index += 1;
	}
	argumentCount = arraySize;
	activateNewClosureMethod(blockClosure);
	/* begin quickCheckForInterrupts */
	if (((interruptCheckCounter -= 1)) <= 0) {
		checkForInterrupts();
	}
}


/*	Fill the receiver, which must be an indexable bytes or words 
	objects, with the given integer value. */

sqInt primitiveConstantFill(void) {
    usqInt end;
    sqInt fillValue;
    usqInt i;
    sqInt rcvr;
    sqInt rcvrIsBytes;
    sqInt successBoolean;
    sqInt successBoolean1;

	fillValue = positive32BitValueOf(longAt(stackPointer));
	rcvr = longAt(stackPointer - (1 * (BYTES_PER_WORD)));
	/* begin success: */
	successBoolean1 = ((rcvr & 1) == 0) && (isWordsOrBytesNonInt(rcvr));
	if (!(successBoolean1)) {
		if (!primFailCode) {
			primFailCode = 1;
		}
	}
	rcvrIsBytes = ((rcvr & 1) == 0) && (((((usqInt) (longAt(rcvr))) >> 8) & 15) >= 8);
	if (rcvrIsBytes) {
		/* begin success: */
		successBoolean = (fillValue >= 0) && (fillValue <= 255);
		if (!(successBoolean)) {
			if (!primFailCode) {
				primFailCode = 1;
			}
		}
	}
	if (!primFailCode) {
		end = rcvr + (sizeBitsOf(rcvr));
		i = rcvr + (BASE_HEADER_SIZE);
		if (rcvrIsBytes) {
			while (i < end) {
				byteAtput(i, fillValue);
				i += 1;
			}
		} else {
			while (i < end) {
				long32Atput(i, fillValue);
				i += 4;
			}
		}
		/* begin pop: */
		stackPointer -= 1 * (BYTES_PER_WORD);
	}
	return null;
}


/*	Primitive. Copy the state of the receiver from the argument. 
		Fail if receiver and argument are of a different class. 
		Fail if the receiver or argument are non-pointer objects.
		Fail if receiver and argument have different lengths (for indexable objects).
	 */

void primitiveCopyObject(void) {
    sqInt arg;
    sqInt i;
    sqInt length;
    sqInt rcvr;
    sqInt header;
    sqInt valuePointer;
    sqInt oop;
    sqInt oop1;
    sqInt sz;

	if (!(argumentCount == 1)) {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		return;
	}
	/* begin stackObjectValue: */
	oop = longAt(stackPointer - (0 * (BYTES_PER_WORD)));
	if ((oop & 1)) {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		arg = null;
		goto l1;
	}
	arg = oop;
l1:	/* end stackObjectValue: */;
	/* begin stackObjectValue: */
	oop1 = longAt(stackPointer - (1 * (BYTES_PER_WORD)));
	if ((oop1 & 1)) {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		rcvr = null;
		goto l2;
	}
	rcvr = oop1;
l2:	/* end stackObjectValue: */;
	if (primFailCode) {
		return;
	}
	if (!(((rcvr & 1) == 0) && (((((usqInt) (longAt(rcvr))) >> 8) & 15) <= 4))) {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		return;
	}
	if (!((fetchClassOf(rcvr)) == (fetchClassOf(arg)))) {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		return;
	}
	/* begin lengthOf: */
	header = longAt(rcvr);
	/* begin lengthOf:baseHeader:format: */
	if ((header & TypeMask) == HeaderTypeSizeAndClass) {
		sz = (longAt(rcvr - ((BYTES_PER_WORD) * 2))) & (LONG_SIZE_MASK);
	} else {
		sz = header & (SIZE_MASK);
	}
	sz -= header & (SIZE_4_BIT);
	if (((((usqInt) header) >> 8) & 15) <= 4) {
		length = ((usqInt) (sz - (BASE_HEADER_SIZE))) >> (SHIFT_FOR_WORD);
		goto l3;
	}
	if (((((usqInt) header) >> 8) & 15) < 8) {
		length = ((usqInt) (sz - (BASE_HEADER_SIZE))) >> 2;
		goto l3;
	} else {
		length = (sz - (BASE_HEADER_SIZE)) - (((((usqInt) header) >> 8) & 15) & 3);
		goto l3;
	}
l3:	/* end lengthOf:baseHeader:format: */;
	if (!(length == (lengthOf(arg)))) {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		return;
	}
	for (i = 0; i <= (length - 1); i += 1) {
		/* begin storePointer:ofObject:withValue: */
		valuePointer = longAt((arg + (BASE_HEADER_SIZE)) + (i << (SHIFT_FOR_WORD)));
		if ((((usqInt) rcvr)) < (((usqInt) youngStart))) {
			possibleRootStoreIntovalue(rcvr, valuePointer);
		}
		longAtput((rcvr + (BASE_HEADER_SIZE)) + (i << (SHIFT_FOR_WORD)), valuePointer);
	}
	/* begin pop: */
	stackPointer -= 1 * (BYTES_PER_WORD);
}


/*	Set or clear the flag that controls whether modifications of 
	the Display object are propagated to the underlying 
	platform's screen. */

void primitiveDeferDisplayUpdates(void) {
    sqInt flag;

	flag = longAt(stackPointer);
	if (flag == trueObj) {
		deferDisplayUpdates = 1;
	} else {
		if (flag == falseObj) {
			deferDisplayUpdates = 0;
		} else {
			/* begin primitiveFail */
			if (primFailCode == 0) {
				primFailCode = 1;
			}
		}
	}
	if (!primFailCode) {
		/* begin pop: */
		stackPointer -= 1 * (BYTES_PER_WORD);
	}
}


/*	Pass in a non-negative value to disable the architectures powermanager if any, zero to enable. This is a named (not numbered) primitive in the null module (ie the VM) */

EXPORT(sqInt) primitiveDisablePowerManager(void) {
    sqInt integer;
    sqInt integerPointer;

	/* begin stackIntegerValue: */
	integerPointer = longAt(stackPointer - (0 * (BYTES_PER_WORD)));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		integer = (integerPointer >> 1);
		goto l1;
	} else {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		integer = 0;
		goto l1;
	}
	integer = null;
l1:	/* end stackIntegerValue: */;
	if (!primFailCode) {
		ioDisablePowerManager(integer);
		/* begin pop: */
		stackPointer -= 1 * (BYTES_PER_WORD);
	}
	return null;
}

sqInt primitiveDiv(void) {
    sqInt quotient;
    sqInt sp;

	quotient = doPrimitiveDivby(longAt(stackPointer - (1 * (BYTES_PER_WORD))), longAt(stackPointer));
	/* begin pop2AndPushIntegerIfOK: */
	if (!primFailCode) {
		if (
# ifdef SQ_HOST32  // cast to int for 64 bit image on 32 bit host
			(((((int) quotient)) ^ ((((int) quotient)) << 1)) >= 0)
# else
			((quotient >= -1073741824) && (quotient <= 1073741823))
# endif  // SQ_HOST32
		) {
			/* begin pop:thenPush: */
			longAtput((sp = stackPointer - ((2 - 1) * (BYTES_PER_WORD))), ((quotient << 1) | 1));
			stackPointer = sp;
		} else {
			/* begin primitiveFail */
			if (primFailCode == 0) {
				primFailCode = 1;
			}
		}
	}
	return null;
}


/*	Primitive arithmetic operations for large integers in 64 bit range */

EXPORT(sqInt) primitiveDivLargeIntegers(void) {
    usqLong a;
    sqInt aIsNegative;
    usqLong b;
    sqInt bIsNegative;
    sqInt oopArg;
    sqInt oopRcvr;
    sqInt oopResult;
    usqLong rem;
    usqLong result;
    sqInt sp;

	oopArg = longAt(stackPointer - (0 * (BYTES_PER_WORD)));
	oopRcvr = longAt(stackPointer - (1 * (BYTES_PER_WORD)));
	aIsNegative = isNegativeIntegerValueOf(oopRcvr);
	bIsNegative = isNegativeIntegerValueOf(oopArg);
	a = magnitude64BitValueOf(oopRcvr);
	b = magnitude64BitValueOf(oopArg);
	if (b == 0) {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
	}
	if (!(!primFailCode)) {
		return null;
	}
	result = a / b;
	if (!(a == 0)) {
		if (!(bIsNegative == aIsNegative)) {

			/* Round toward negative infinity */

			rem = a % b;
			if (!(rem == 0)) {

				/* This can not overflow, because b > 1, otherwise rem = 0 */

				result += 1;
			}
		}
	}
	oopResult = magnitude64BitIntegerForneg(result, bIsNegative != aIsNegative);
	if (!primFailCode) {
		/* begin pop:thenPush: */
		longAtput((sp = stackPointer - ((2 - 1) * (BYTES_PER_WORD))), oopResult);
		stackPointer = sp;
	}
	return null;
}

sqInt primitiveDivide(void) {
    sqInt integerArgument;
    sqInt integerReceiver;
    sqInt sp;
    sqInt integerPointer;
    sqInt integerPointer1;

	/* begin stackIntegerValue: */
	integerPointer = longAt(stackPointer - (1 * (BYTES_PER_WORD)));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		integerReceiver = (integerPointer >> 1);
		goto l1;
	} else {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		integerReceiver = 0;
		goto l1;
	}
	integerReceiver = null;
l1:	/* end stackIntegerValue: */;
	/* begin stackIntegerValue: */
	integerPointer1 = longAt(stackPointer - (0 * (BYTES_PER_WORD)));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer1 & 1)) {
		integerArgument = (integerPointer1 >> 1);
		goto l2;
	} else {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		integerArgument = 0;
		goto l2;
	}
	integerArgument = null;
l2:	/* end stackIntegerValue: */;
	if ((integerArgument != 0) && ((integerReceiver % integerArgument) == 0)) {
		/* begin pop2AndPushIntegerIfOK: */
		if (!primFailCode) {
			if (
# ifdef SQ_HOST32  // cast to int for 64 bit image on 32 bit host
				(((((int) (integerReceiver / integerArgument))) ^ ((((int) (integerReceiver / integerArgument))) << 1)) >= 0)
# else
				(((integerReceiver / integerArgument) >= -1073741824) && ((integerReceiver / integerArgument) <= 1073741823))
# endif  // SQ_HOST32
			) {
				/* begin pop:thenPush: */
				longAtput((sp = stackPointer - ((2 - 1) * (BYTES_PER_WORD))), (((integerReceiver / integerArgument) << 1) | 1));
				stackPointer = sp;
			} else {
				/* begin primitiveFail */
				if (primFailCode == 0) {
					primFailCode = 1;
				}
			}
		}
	} else {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
	}
	return null;
}


/*	Primitive arithmetic operations for large integers in 64 bit range */

EXPORT(sqInt) primitiveDivideLargeIntegers(void) {
    usqLong a;
    sqInt aIsNegative;
    usqLong b;
    sqInt bIsNegative;
    sqInt oopArg;
    sqInt oopRcvr;
    sqInt oopResult;
    usqLong result;
    sqInt sp;

	oopArg = longAt(stackPointer - (0 * (BYTES_PER_WORD)));
	oopRcvr = longAt(stackPointer - (1 * (BYTES_PER_WORD)));
	aIsNegative = isNegativeIntegerValueOf(oopRcvr);
	bIsNegative = isNegativeIntegerValueOf(oopArg);
	a = magnitude64BitValueOf(oopRcvr);
	b = magnitude64BitValueOf(oopArg);
	if (!(!primFailCode)) {
		return null;
	}
	if (!((b != 0) && ((a % b) == 0))) {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		return null;
	}
	result = a / b;
	oopResult = magnitude64BitIntegerForneg(result, aIsNegative != bIsNegative);
	if (!primFailCode) {
		/* begin pop:thenPush: */
		longAtput((sp = stackPointer - ((2 - 1) * (BYTES_PER_WORD))), oopResult);
		stackPointer = sp;
	}
	return null;
}

void primitiveDoPrimitiveWithArgs(void) {
    sqInt argumentArray;
    sqInt arraySize;
    sqInt cntxSize;
    sqInt index;
    sqInt primIdx;
    sqInt object;
    sqInt sp;
    sqInt sp1;
    sqInt sp2;
    sqInt sz;
    sqInt header;
    sqInt sz1;
    sqInt header1;
    sqInt successBoolean;
    sqInt oop;
    sqInt integerPointer;

	argumentArray = longAt(stackPointer);
	/* begin fetchWordLengthOf: */
	/* begin sizeBitsOf: */
	header = longAt(argumentArray);
	if ((header & TypeMask) == HeaderTypeSizeAndClass) {
		sz = (longAt(argumentArray - ((BYTES_PER_WORD) * 2))) & (LONG_SIZE_MASK);
		goto l1;
	} else {
		sz = header & (SIZE_MASK);
		goto l1;
	}
l1:	/* end sizeBitsOf: */;
	arraySize = ((usqInt) (sz - (BASE_HEADER_SIZE))) >> (SHIFT_FOR_WORD);
	/* begin fetchWordLengthOf: */
	/* begin sizeBitsOf: */
	header1 = longAt(activeContext);
	if ((header1 & TypeMask) == HeaderTypeSizeAndClass) {
		sz1 = (longAt(activeContext - ((BYTES_PER_WORD) * 2))) & (LONG_SIZE_MASK);
		goto l2;
	} else {
		sz1 = header1 & (SIZE_MASK);
		goto l2;
	}
l2:	/* end sizeBitsOf: */;
	cntxSize = ((usqInt) (sz1 - (BASE_HEADER_SIZE))) >> (SHIFT_FOR_WORD);
	/* begin success: */
	successBoolean = ((((usqInt) ((stackPointer - activeContext) - (BASE_HEADER_SIZE))) >> (SHIFT_FOR_WORD)) + arraySize) < cntxSize;
	if (!(successBoolean)) {
		if (!primFailCode) {
			primFailCode = 1;
		}
	}
	if (!(((argumentArray & 1) == 0) && (((((usqInt) (longAt(argumentArray))) >> 8) & 15) == 2))) {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		return;
	}
	/* begin stackIntegerValue: */
	integerPointer = longAt(stackPointer - (1 * (BYTES_PER_WORD)));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		primIdx = (integerPointer >> 1);
		goto l3;
	} else {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		primIdx = 0;
		goto l3;
	}
	primIdx = null;
l3:	/* end stackIntegerValue: */;
	if (!(!primFailCode)) {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		return;
	}
	/* begin pop: */
	stackPointer -= 2 * (BYTES_PER_WORD);
	primitiveIndex = primIdx;
	argumentCount = arraySize;
	index = 1;
	while (index <= argumentCount) {
		/* begin push: */
		object = longAt((argumentArray + (BASE_HEADER_SIZE)) + ((index - 1) << (SHIFT_FOR_WORD)));
		longAtput((sp = stackPointer + (BYTES_PER_WORD)), object);
		stackPointer = sp;
		index += 1;
	}
	/* begin pushRemappableOop: */
	remapBuffer[(remapBufferCount += 1)] = argumentArray;
	lkupClass = nilObj;
	primitiveResponse();
	/* begin popRemappableOop */
	oop = remapBuffer[remapBufferCount];
	remapBufferCount -= 1;
	argumentArray = oop;
	if (!(!primFailCode)) {

		/* If primitive failed, then restore state for failure code */

		/* begin pop: */
		stackPointer -= arraySize * (BYTES_PER_WORD);
		/* begin pushInteger: */
		/* begin push: */
		longAtput((sp1 = stackPointer + (BYTES_PER_WORD)), ((primIdx << 1) | 1));
		stackPointer = sp1;
		/* begin push: */
		longAtput((sp2 = stackPointer + (BYTES_PER_WORD)), argumentArray);
		stackPointer = sp2;
		argumentCount = 2;
	}
}

sqInt primitiveEqual(void) {
    sqInt integerArgument;
    sqInt integerReceiver;
    sqInt result;
    sqInt top;
    sqInt top1;
    sqInt sp;
    sqInt sp1;

	/* begin popStack */
	top = longAt(stackPointer);
	stackPointer -= BYTES_PER_WORD;
	integerArgument = top;
	/* begin popStack */
	top1 = longAt(stackPointer);
	stackPointer -= BYTES_PER_WORD;
	integerReceiver = top1;
	/* begin compare31or32Bits:equal: */
	if (((integerReceiver & 1)) && ((integerArgument & 1))) {
		result = integerReceiver == integerArgument;
		goto l1;
	}
	result = (positive32BitValueOf(integerReceiver)) == (positive32BitValueOf(integerArgument));
l1:	/* end compare31or32Bits:equal: */;
	/* begin checkBooleanResult: */
	if (!primFailCode) {
		/* begin pushBool: */
		if (result) {
			/* begin push: */
			longAtput((sp = stackPointer + (BYTES_PER_WORD)), trueObj);
			stackPointer = sp;
		} else {
			/* begin push: */
			longAtput((sp1 = stackPointer + (BYTES_PER_WORD)), falseObj);
			stackPointer = sp1;
		}
	} else {
		/* begin unPop: */
		stackPointer += 2 * (BYTES_PER_WORD);
	}
	return null;
}


/*	Primitive comparison operations for large integers in 64 bit range */

EXPORT(sqInt) primitiveEqualLargeIntegers(void) {
    sqLong integerArg;
    sqLong integerRcvr;
    sqInt sp;

	integerArg = signed64BitValueOf(longAt(stackPointer - (0 * (BYTES_PER_WORD))));
	integerRcvr = signed64BitValueOf(longAt(stackPointer - (1 * (BYTES_PER_WORD))));
	if (!primFailCode) {
		/* begin pop:thenPushBool: */
		longAtput((sp = stackPointer - ((2 - 1) * (BYTES_PER_WORD))), (integerRcvr == integerArg
			? trueObj
			: falseObj));
		stackPointer = sp;
	}
	return null;
}

sqInt primitiveErrorTable(void) {
	return longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (PrimErrTableIndex << (SHIFT_FOR_WORD)));
}


/*	receiver, args, then method are on top of stack. Execute method against receiver and args */

void primitiveExecuteMethod(void) {
    sqInt top;
    sqInt primBits;
    sqInt successBoolean;

	/* begin popStack */
	top = longAt(stackPointer);
	stackPointer -= BYTES_PER_WORD;
	newMethod = top;
	/* begin primitiveIndexOf: */
	primBits = (((usqInt) (longAt((newMethod + (BASE_HEADER_SIZE)) + (HeaderIndex << (SHIFT_FOR_WORD))))) >> 1) & 268435967;
	primitiveIndex = (primBits & 511) + (((usqInt) primBits) >> 19);
	/* begin success: */
	successBoolean = (argumentCount - 1) == ((((usqInt) (longAt((newMethod + (BASE_HEADER_SIZE)) + (HeaderIndex << (SHIFT_FOR_WORD))))) >> 25) & 15);
	if (!(successBoolean)) {
		if (!primFailCode) {
			primFailCode = 1;
		}
	}
	if (!primFailCode) {
		argumentCount -= 1;
		/* begin executeNewMethod */
		if (primitiveIndex > 0) {
			primitiveResponse();
			if (!primFailCode) {
				goto l1;
			}
		}
		activateNewMethod();
		/* begin quickCheckForInterrupts */
		if (((interruptCheckCounter -= 1)) <= 0) {
			checkForInterrupts();
		}
	l1:	/* end executeNewMethod */;
	} else {
		/* begin unPop: */
		stackPointer += 1 * (BYTES_PER_WORD);
	}
}


/*	receiver, argsArray, then method are on top of stack.  Execute method against
	 receiver and args.  Allow for up to two extra arguments (e.g. for mirror primitives).
	 Set primitiveFunctionPointer because no cache lookup has been done for the
	 method, and hence primitiveFunctionPointer is stale. */

void primitiveExecuteMethodArgsArray(void) {
    sqInt argCnt;
    sqInt argumentArray;
    sqInt i;
    sqInt methodArgument;
    sqInt object;
    sqInt sp;
    sqInt primBits;

	methodArgument = longAt(stackPointer);
	argumentArray = longAt(stackPointer - (1 * (BYTES_PER_WORD)));
	if (!((((methodArgument & 1) == 0) && (((((usqInt) (longAt(methodArgument))) >> 8) & 15) >= 12)) && (((argumentArray & 1) == 0) && (((((usqInt) (longAt(argumentArray))) >> 8) & 15) == 2)))) {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		return;
	}
	argCnt = (((usqInt) (longAt((methodArgument + (BASE_HEADER_SIZE)) + (HeaderIndex << (SHIFT_FOR_WORD))))) >> 25) & 15;
	if (!(argCnt == (fetchWordLengthOf(argumentArray)))) {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		return;
	}
	if (argumentCount > 2) {

		/* CompiledMethod class>>receiver:withArguments:executeMethod:
								SqueakObjectPrimitives class >> receiver:withArguments:apply:
								VMMirror>>ifFail:object:with:executeMethod: et al */

		if (argumentCount > 4) {
			/* begin primitiveFail */
			if (primFailCode == 0) {
				primFailCode = 1;
			}
			return;
		}
		longAtput(stackPointer - (argumentCount * (BYTES_PER_WORD)), longAt(stackPointer - (2 * (BYTES_PER_WORD))));
	}
	/* begin pop: */
	stackPointer -= argumentCount * (BYTES_PER_WORD);
	for (i = 0; i <= (argCnt - 1); i += 1) {
		/* begin push: */
		object = longAt((argumentArray + (BASE_HEADER_SIZE)) + (i << (SHIFT_FOR_WORD)));
		longAtput((sp = stackPointer + (BYTES_PER_WORD)), object);
		stackPointer = sp;
	}
	newMethod = methodArgument;
	/* begin primitiveIndexOf: */
	primBits = (((usqInt) (longAt((newMethod + (BASE_HEADER_SIZE)) + (HeaderIndex << (SHIFT_FOR_WORD))))) >> 1) & 268435967;
	primitiveIndex = (primBits & 511) + (((usqInt) primBits) >> 19);
	primitiveFunctionPointer = primitiveTable[primitiveIndex];

	/* We set the messageSelector for executeMethod below since things
	 like the at cache read messageSelector and so it cannot be left stale. */

	argumentCount = argCnt;
	messageSelector = nilObj;
	/* begin executeNewMethod */
	if (primitiveIndex > 0) {
		primitiveResponse();
		if (!primFailCode) {
			goto l1;
		}
	}
	activateNewMethod();
	/* begin quickCheckForInterrupts */
	if (((interruptCheckCounter -= 1)) <= 0) {
		checkForInterrupts();
	}
l1:	/* end executeNewMethod */;
	/* begin initPrimCall */
	primFailCode = 0;
}

sqInt primitiveExitToDebugger(void) {
	error("Exit to debugger at user request");
	return null;
}


/*	Computes E raised to the receiver power. */

sqInt primitiveExp(void) {
    double rcvr;

	rcvr = popFloat();
	if (!primFailCode) {
		pushFloat(exp(rcvr));
	} else {
		/* begin unPop: */
		stackPointer += 1 * (BYTES_PER_WORD);
	}
	return null;
}


/*	Exponent part of this float. */

sqInt primitiveExponent(void) {
    double frac;
    int pwr;
    double rcvr;
    sqInt sp;

	rcvr = popFloat();
	if (!primFailCode) {

		/* rcvr = frac * 2^pwr, where frac is in [0.5..1.0) */

		frac = frexp(rcvr, &pwr);
		/* begin pushInteger: */
		/* begin push: */
		longAtput((sp = stackPointer + (BYTES_PER_WORD)), (((pwr - 1) << 1) | 1));
		stackPointer = sp;
	} else {
		/* begin unPop: */
		stackPointer += 1 * (BYTES_PER_WORD);
	}
	return null;
}


/*	Call an external primitive. The external primitive methods 
	contain as first literal an array consisting of: 
	* The module name (String | Symbol) 
	* The function name (String | Symbol) 
	* The session ID (SmallInteger) [OBSOLETE] 
	* The function index (Integer) in the externalPrimitiveTable 
	For fast failures the primitive index of any method where the 
	external prim is not found is rewritten in the method cache 
	with zero. This allows for ultra fast responses as long as the 
	method stays in the cache. 
	The fast failure response relies on lkupClass being properly 
	set. This is done in 
	#addToMethodCacheSel:class:method:primIndex: to 
	compensate for execution of methods that are looked up in a 
	superclass (such as in primitivePerformAt). 
	With the latest modifications (e.g., actually flushing the 
	function addresses from the VM), the session ID is obsolete. 
	But for backward compatibility it is still kept around. Also, a 
	failed lookup is reported specially. If a method has been 
	looked up and not been found, the function address is stored 
	as -1 (e.g., the SmallInteger -1 to distinguish from 
	16rFFFFFFFF which may be returned from the lookup). 
	It is absolutely okay to remove the rewrite if we run into any 
	problems later on. It has an approximate speed difference of 
	30% per failed primitive call which may be noticable but if, 
	for any reasons, we run into problems (like with J3) we can 
	always remove the rewrite. 
	 */

void primitiveExternalCall(void) {
    void (*extFnAddr)(void);
    sqInt functionLength;
    sqInt functionName;
    sqInt index;
    sqInt lit;
    sqInt moduleLength;
    sqInt moduleName;
    sqInt successBoolean;
    sqInt header;
    sqInt successBoolean1;
    sqInt successBoolean2;
    sqInt successBoolean3;
    sqInt header1;
    sqInt sz;
    sqInt sz1;


	/* Fetch the first literal of the method */

	/* begin success: */
	successBoolean1 = (literalCountOfHeader(longAt((newMethod + (BASE_HEADER_SIZE)) + (HeaderIndex << (SHIFT_FOR_WORD))))) > 0;
	if (!(successBoolean1)) {
		if (!primFailCode) {
			primFailCode = 1;
		}
	}
	if (!(!primFailCode)) {
		return;
	}

	/* Check if it's an array of length 4 */

	lit = longAt((newMethod + (BASE_HEADER_SIZE)) + ((0 + LiteralStart) << (SHIFT_FOR_WORD)));
	/* begin success: */
	successBoolean2 = (((lit & 1) == 0) && (((((usqInt) (longAt(lit))) >> 8) & 15) == 2)) && ((lengthOf(lit)) == 4);
	if (!(successBoolean2)) {
		if (!primFailCode) {
			primFailCode = 1;
		}
	}
	if (!(!primFailCode)) {
		return;
	}
	index = longAt((lit + (BASE_HEADER_SIZE)) + (3 << (SHIFT_FOR_WORD)));
	/* begin checkedIntegerValueOf: */
	if ((index & 1)) {
		index = (index >> 1);
		goto l1;
	} else {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		index = 0;
		goto l1;
	}
l1:	/* end checkedIntegerValueOf: */;
	if (!(!primFailCode)) {
		return;
	}
	if (index < 0) {

		/* Function address was not found in this session, 
			Rewrite the mcache entry with a zero primitive index. */

		rewriteMethodCacheSelclassprimIndex(messageSelector, lkupClass, 0);
		/* begin success: */
		if (!(0)) {
			if (!primFailCode) {
				primFailCode = 1;
			}
		}
		return;
	}
	if ((index > 0) && (index <= MaxExternalPrimitiveTableSize)) {
		extFnAddr = externalPrimitiveTable[index - 1];
		if (extFnAddr != 0) {
			rewriteMethodCacheSelclassprimIndexprimFunction(messageSelector, lkupClass, 1000 + index, extFnAddr);
			callExternalPrimitive(extFnAddr);
			return;
		}
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		return;
	}
	longAtput((lit + (BASE_HEADER_SIZE)) + (2 << (SHIFT_FOR_WORD)), ConstZero);
	longAtput((lit + (BASE_HEADER_SIZE)) + (3 << (SHIFT_FOR_WORD)), ConstZero);
	moduleName = longAt((lit + (BASE_HEADER_SIZE)) + (0 << (SHIFT_FOR_WORD)));
	if (moduleName == nilObj) {
		moduleLength = 0;
	} else {
		/* begin success: */
		successBoolean = ((moduleName & 1) == 0) && (((((usqInt) (longAt(moduleName))) >> 8) & 15) >= 8);
		if (!(successBoolean)) {
			if (!primFailCode) {
				primFailCode = 1;
			}
		}
		/* begin lengthOf: */
		header = longAt(moduleName);
		/* begin lengthOf:baseHeader:format: */
		if ((header & TypeMask) == HeaderTypeSizeAndClass) {
			sz = (longAt(moduleName - ((BYTES_PER_WORD) * 2))) & (LONG_SIZE_MASK);
		} else {
			sz = header & (SIZE_MASK);
		}
		sz -= header & (SIZE_4_BIT);
		if (((((usqInt) header) >> 8) & 15) <= 4) {
			moduleLength = ((usqInt) (sz - (BASE_HEADER_SIZE))) >> (SHIFT_FOR_WORD);
			goto l2;
		}
		if (((((usqInt) header) >> 8) & 15) < 8) {
			moduleLength = ((usqInt) (sz - (BASE_HEADER_SIZE))) >> 2;
			goto l2;
		} else {
			moduleLength = (sz - (BASE_HEADER_SIZE)) - (((((usqInt) header) >> 8) & 15) & 3);
			goto l2;
		}
	l2:	/* end lengthOf:baseHeader:format: */;
		;
	}
	functionName = longAt((lit + (BASE_HEADER_SIZE)) + (1 << (SHIFT_FOR_WORD)));
	/* begin success: */
	successBoolean3 = ((functionName & 1) == 0) && (((((usqInt) (longAt(functionName))) >> 8) & 15) >= 8);
	if (!(successBoolean3)) {
		if (!primFailCode) {
			primFailCode = 1;
		}
	}
	/* begin lengthOf: */
	header1 = longAt(functionName);
	/* begin lengthOf:baseHeader:format: */
	if ((header1 & TypeMask) == HeaderTypeSizeAndClass) {
		sz1 = (longAt(functionName - ((BYTES_PER_WORD) * 2))) & (LONG_SIZE_MASK);
	} else {
		sz1 = header1 & (SIZE_MASK);
	}
	sz1 -= header1 & (SIZE_4_BIT);
	if (((((usqInt) header1) >> 8) & 15) <= 4) {
		functionLength = ((usqInt) (sz1 - (BASE_HEADER_SIZE))) >> (SHIFT_FOR_WORD);
		goto l3;
	}
	if (((((usqInt) header1) >> 8) & 15) < 8) {
		functionLength = ((usqInt) (sz1 - (BASE_HEADER_SIZE))) >> 2;
		goto l3;
	} else {
		functionLength = (sz1 - (BASE_HEADER_SIZE)) - (((((usqInt) header1) >> 8) & 15) & 3);
		goto l3;
	}
l3:	/* end lengthOf:baseHeader:format: */;
	if (!(!primFailCode)) {
		return;
	}
	extFnAddr = ((void (*)(void)) (ioLoadExternalFunctionOfLengthFromModuleOfLength(functionName + (BASE_HEADER_SIZE), functionLength, moduleName + (BASE_HEADER_SIZE), moduleLength)));
	if (extFnAddr == 0) {
		index = -1;
	} else {

		/* add the function to the external primitive table */

		index = addToExternalPrimitiveTable(extFnAddr);
	}
	/* begin success: */
	if (!(index >= 0)) {
		if (!primFailCode) {
			primFailCode = 1;
		}
	}
	longAtput((lit + (BASE_HEADER_SIZE)) + (3 << (SHIFT_FOR_WORD)), ((index << 1) | 1));
	if ((!primFailCode) && (extFnAddr != 0)) {
		rewriteMethodCacheSelclassprimIndexprimFunction(messageSelector, lkupClass, 1000 + index, extFnAddr);
		callExternalPrimitive(extFnAddr);
	} else {

		/* Otherwise rewrite the primitive index */

		rewriteMethodCacheSelclassprimIndex(messageSelector, lkupClass, 0);
	}
}


/*	Set general (unspecified) primitive failure.  Don't overwrite an error code that has already been set. */
/*	Use returnTypeC: #sqInt because that's the way it is defined in sq.h.
	 Use no explicit return so that Slang doesn't fail an inlining type-check when
	 a primitive with return type void uses ^self primitiveFail to exit. */

sqInt primitiveFail(void) {
	if (primFailCode == 0) {
		primFailCode = 1;
	}
	return null;
}


/*	Set specific primitive failure.
	 N.B. primitiveFailFor: PrimNoErr is expected to clear the primFailCode. */

sqInt primitiveFailFor(sqInt reasonCode) {
	return (primFailCode = reasonCode);
}

sqInt primitiveFailureCode(void) {
	return primFailCode;
}


/*	Primitive. Search up the context stack for the next method context marked for exception handling starting at the receiver. Return nil if none found */

sqInt primitiveFindHandlerContext(void) {
    sqInt nilOop;
    sqInt thisCntx;
    sqInt sp;
    sqInt top;
    sqInt sp1;

	/* begin popStack */
	top = longAt(stackPointer);
	stackPointer -= BYTES_PER_WORD;
	thisCntx = top;
	nilOop = nilObj;
	do {
		if (isHandlerMarked(thisCntx)) {
			/* begin push: */
			longAtput((sp = stackPointer + (BYTES_PER_WORD)), thisCntx);
			stackPointer = sp;
			return null;
		}
		thisCntx = longAt((thisCntx + (BASE_HEADER_SIZE)) + (SenderIndex << (SHIFT_FOR_WORD)));
	} while(!(thisCntx == nilOop));
	/* begin push: */
	longAtput((sp1 = stackPointer + (BYTES_PER_WORD)), nilObj);
	stackPointer = sp1;
	return null;
}


/*	Primitive. Search up the context stack for the next method context marked for unwind handling from the receiver up to but not including the argument. Return nil if none found. */

sqInt primitiveFindNextUnwindContext(void) {
    sqInt aContext;
    sqInt nilOop;
    sqInt thisCntx;
    sqInt unwindMarked;
    sqInt sp;
    sqInt header;
    sqInt meth;
    sqInt pIndex;
    sqInt top;
    sqInt oop;
    sqInt sp1;
    sqInt primBits;
    sqInt top1;

	/* begin popStack */
	top = longAt(stackPointer);
	stackPointer -= BYTES_PER_WORD;
	aContext = top;
	/* begin fetchPointer:ofObject: */
	/* begin popStack */
	top1 = longAt(stackPointer);
	stackPointer -= BYTES_PER_WORD;
	oop = top1;
	thisCntx = longAt((oop + (BASE_HEADER_SIZE)) + (SenderIndex << (SHIFT_FOR_WORD)));
	nilOop = nilObj;
	while (!((thisCntx == aContext) || (thisCntx == nilOop))) {
		/* begin isUnwindMarked: */
		header = longAt(thisCntx);
		if (!(((((usqInt) header) >> 12) & 31) == 14)) {
			unwindMarked = 0;
			goto l1;
		}
		meth = longAt((thisCntx + (BASE_HEADER_SIZE)) + (MethodIndex << (SHIFT_FOR_WORD)));
		/* begin primitiveIndexOf: */
		primBits = (((usqInt) (longAt((meth + (BASE_HEADER_SIZE)) + (HeaderIndex << (SHIFT_FOR_WORD))))) >> 1) & 268435967;
		pIndex = (primBits & 511) + (((usqInt) primBits) >> 19);
		unwindMarked = pIndex == 198;
	l1:	/* end isUnwindMarked: */;
		if (unwindMarked) {
			/* begin push: */
			longAtput((sp = stackPointer + (BYTES_PER_WORD)), thisCntx);
			stackPointer = sp;
			return null;
		}
		thisCntx = longAt((thisCntx + (BASE_HEADER_SIZE)) + (SenderIndex << (SHIFT_FOR_WORD)));
	}
	/* begin push: */
	longAtput((sp1 = stackPointer + (BYTES_PER_WORD)), nilOop);
	stackPointer = sp1;
	return null;
}

sqInt primitiveFloatAdd(void) {
	return primitiveFloatAddtoArg(longAt(stackPointer - (1 * (BYTES_PER_WORD))), longAt(stackPointer));
}

sqInt primitiveFloatAddtoArg(sqInt rcvrOop, sqInt argOop) {
    double arg;
    double rcvr;

	/* begin loadFloatOrIntFrom: */
	if ((rcvrOop & 1)) {
		rcvr = ((double) ((rcvrOop >> 1)) );
		goto l1;
	}
	if ((fetchClassOfNonInt(rcvrOop)) == (longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassFloat << (SHIFT_FOR_WORD))))) {
		rcvr = floatValueOf(rcvrOop);
		goto l1;
	}
	/* begin primitiveFail */
	if (primFailCode == 0) {
		primFailCode = 1;
	}
l1:	/* end loadFloatOrIntFrom: */;
	/* begin loadFloatOrIntFrom: */
	if ((argOop & 1)) {
		arg = ((double) ((argOop >> 1)) );
		goto l2;
	}
	if ((fetchClassOfNonInt(argOop)) == (longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassFloat << (SHIFT_FOR_WORD))))) {
		arg = floatValueOf(argOop);
		goto l2;
	}
	/* begin primitiveFail */
	if (primFailCode == 0) {
		primFailCode = 1;
	}
l2:	/* end loadFloatOrIntFrom: */;
	if (!primFailCode) {
		/* begin pop: */
		stackPointer -= 2 * (BYTES_PER_WORD);
		pushFloat(rcvr + arg);
	}
	return null;
}


/*	Provide platform-independent access to 32-bit words comprising
	 a Float.  Map index 1 onto the most significant word and index 2
	 onto the least significant word. */

void primitiveFloatAt(void) {
    sqInt index;
    sqInt rcvr;
    usqInt result;
    sqInt sp;
    sqInt sp1;
    sqInt reasonCode;

	/* begin initPrimCall */
	primFailCode = 0;
	rcvr = longAt(stackPointer - (1 * (BYTES_PER_WORD)));
	index = longAt(stackPointer);
	if (index == ConstOne) {
		result = positive32BitIntegerFor(long32At((rcvr + (BASE_HEADER_SIZE)) + (0 << 2)));
		/* begin pop:thenPush: */
		longAtput((sp = stackPointer - ((2 - 1) * (BYTES_PER_WORD))), result);
		stackPointer = sp;
		return;
	}
	if (index == ConstTwo) {
		result = positive32BitIntegerFor(long32At((rcvr + (BASE_HEADER_SIZE)) + (1 << 2)));
		/* begin pop:thenPush: */
		longAtput((sp1 = stackPointer - ((2 - 1) * (BYTES_PER_WORD))), result);
		stackPointer = sp1;
		return;
	}
	/* begin primitiveFailFor: */
	reasonCode = ((index & 1)
		? PrimErrBadIndex
		: PrimErrBadArgument);
	primFailCode = reasonCode;
}


/*	Provide platform-independent access to 32-bit words comprising
	 a Float.  Map index 1 onto the most significant word and index 2
	 onto the least significant word. */

void primitiveFloatAtPut(void) {
    sqInt index;
    sqInt oopToStore;
    sqInt rcvr;
    sqInt valueToStore;
    sqInt sp;
    sqInt sp1;
    sqInt reasonCode;

	/* begin initPrimCall */
	primFailCode = 0;
	oopToStore = longAt(stackPointer);
	valueToStore = positive32BitValueOf(oopToStore);
	if (!(!primFailCode)) {
		(primFailCode = PrimErrBadArgument); return;
	}
	rcvr = longAt(stackPointer - (2 * (BYTES_PER_WORD)));
	index = longAt(stackPointer - (1 * (BYTES_PER_WORD)));
	if (index == ConstOne) {
		long32Atput((rcvr + (BASE_HEADER_SIZE)) + (0 << 2), valueToStore);
		/* begin pop:thenPush: */
		longAtput((sp = stackPointer - ((3 - 1) * (BYTES_PER_WORD))), oopToStore);
		stackPointer = sp;
		return;
	}
	if (index == ConstTwo) {
		long32Atput((rcvr + (BASE_HEADER_SIZE)) + (1 << 2), valueToStore);
		/* begin pop:thenPush: */
		longAtput((sp1 = stackPointer - ((3 - 1) * (BYTES_PER_WORD))), oopToStore);
		stackPointer = sp1;
		return;
	}
	/* begin primitiveFailFor: */
	reasonCode = ((index & 1)
		? PrimErrBadIndex
		: PrimErrBadArgument);
	primFailCode = reasonCode;
}

sqInt primitiveFloatDivide(void) {
	primitiveFloatDividebyArg(longAt(stackPointer - (1 * (BYTES_PER_WORD))), longAt(stackPointer));
	return null;
}

sqInt primitiveFloatDividebyArg(sqInt rcvrOop, sqInt argOop) {
    double arg;
    double rcvr;

	/* begin loadFloatOrIntFrom: */
	if ((rcvrOop & 1)) {
		rcvr = ((double) ((rcvrOop >> 1)) );
		goto l1;
	}
	if ((fetchClassOfNonInt(rcvrOop)) == (longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassFloat << (SHIFT_FOR_WORD))))) {
		rcvr = floatValueOf(rcvrOop);
		goto l1;
	}
	/* begin primitiveFail */
	if (primFailCode == 0) {
		primFailCode = 1;
	}
l1:	/* end loadFloatOrIntFrom: */;
	/* begin loadFloatOrIntFrom: */
	if ((argOop & 1)) {
		arg = ((double) ((argOop >> 1)) );
		goto l2;
	}
	if ((fetchClassOfNonInt(argOop)) == (longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassFloat << (SHIFT_FOR_WORD))))) {
		arg = floatValueOf(argOop);
		goto l2;
	}
	/* begin primitiveFail */
	if (primFailCode == 0) {
		primFailCode = 1;
	}
l2:	/* end loadFloatOrIntFrom: */;
	if (!primFailCode) {
		/* begin success: */
		if (!(arg != 0.0)) {
			if (!primFailCode) {
				primFailCode = 1;
			}
		}
		if (!primFailCode) {
			/* begin pop: */
			stackPointer -= 2 * (BYTES_PER_WORD);
			pushFloat(rcvr / arg);
		}
	}
	return null;
}

sqInt primitiveFloatEqual(void) {
    sqInt aBool;
    sqInt sp;

	aBool = primitiveFloatEqualtoArg(longAt(stackPointer - (1 * (BYTES_PER_WORD))), longAt(stackPointer));
	if (!primFailCode) {
		/* begin pop:thenPushBool: */
		longAtput((sp = stackPointer - ((2 - 1) * (BYTES_PER_WORD))), (aBool
			? trueObj
			: falseObj));
		stackPointer = sp;
	}
	return null;
}

sqInt primitiveFloatEqualtoArg(sqInt rcvrOop, sqInt argOop) {
    double arg;
    double rcvr;

	/* begin loadFloatOrIntFrom: */
	if ((rcvrOop & 1)) {
		rcvr = ((double) ((rcvrOop >> 1)) );
		goto l1;
	}
	if ((fetchClassOfNonInt(rcvrOop)) == (longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassFloat << (SHIFT_FOR_WORD))))) {
		rcvr = floatValueOf(rcvrOop);
		goto l1;
	}
	/* begin primitiveFail */
	if (primFailCode == 0) {
		primFailCode = 1;
	}
l1:	/* end loadFloatOrIntFrom: */;
	/* begin loadFloatOrIntFrom: */
	if ((argOop & 1)) {
		arg = ((double) ((argOop >> 1)) );
		goto l2;
	}
	if ((fetchClassOfNonInt(argOop)) == (longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassFloat << (SHIFT_FOR_WORD))))) {
		arg = floatValueOf(argOop);
		goto l2;
	}
	/* begin primitiveFail */
	if (primFailCode == 0) {
		primFailCode = 1;
	}
l2:	/* end loadFloatOrIntFrom: */;
	if (!primFailCode) {
		return rcvr == arg;
	}
	return null;
}

sqInt primitiveFloatGreaterthanArg(sqInt rcvrOop, sqInt argOop) {
    double arg;
    double rcvr;

	/* begin loadFloatOrIntFrom: */
	if ((rcvrOop & 1)) {
		rcvr = ((double) ((rcvrOop >> 1)) );
		goto l1;
	}
	if ((fetchClassOfNonInt(rcvrOop)) == (longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassFloat << (SHIFT_FOR_WORD))))) {
		rcvr = floatValueOf(rcvrOop);
		goto l1;
	}
	/* begin primitiveFail */
	if (primFailCode == 0) {
		primFailCode = 1;
	}
l1:	/* end loadFloatOrIntFrom: */;
	/* begin loadFloatOrIntFrom: */
	if ((argOop & 1)) {
		arg = ((double) ((argOop >> 1)) );
		goto l2;
	}
	if ((fetchClassOfNonInt(argOop)) == (longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassFloat << (SHIFT_FOR_WORD))))) {
		arg = floatValueOf(argOop);
		goto l2;
	}
	/* begin primitiveFail */
	if (primFailCode == 0) {
		primFailCode = 1;
	}
l2:	/* end loadFloatOrIntFrom: */;
	if (!primFailCode) {
		return rcvr > arg;
	}
	return null;
}

sqInt primitiveFloatGreaterOrEqual(void) {
    sqInt aBool;
    sqInt sp;

	aBool = primitiveFloatGreaterOrEqualtoArg(longAt(stackPointer - (1 * (BYTES_PER_WORD))), longAt(stackPointer));
	if (!primFailCode) {
		/* begin pop:thenPushBool: */
		longAtput((sp = stackPointer - ((2 - 1) * (BYTES_PER_WORD))), (aBool
			? trueObj
			: falseObj));
		stackPointer = sp;
	}
	return null;
}

sqInt primitiveFloatGreaterOrEqualtoArg(sqInt rcvrOop, sqInt argOop) {
    double arg;
    double rcvr;

	/* begin loadFloatOrIntFrom: */
	if ((rcvrOop & 1)) {
		rcvr = ((double) ((rcvrOop >> 1)) );
		goto l1;
	}
	if ((fetchClassOfNonInt(rcvrOop)) == (longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassFloat << (SHIFT_FOR_WORD))))) {
		rcvr = floatValueOf(rcvrOop);
		goto l1;
	}
	/* begin primitiveFail */
	if (primFailCode == 0) {
		primFailCode = 1;
	}
l1:	/* end loadFloatOrIntFrom: */;
	/* begin loadFloatOrIntFrom: */
	if ((argOop & 1)) {
		arg = ((double) ((argOop >> 1)) );
		goto l2;
	}
	if ((fetchClassOfNonInt(argOop)) == (longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassFloat << (SHIFT_FOR_WORD))))) {
		arg = floatValueOf(argOop);
		goto l2;
	}
	/* begin primitiveFail */
	if (primFailCode == 0) {
		primFailCode = 1;
	}
l2:	/* end loadFloatOrIntFrom: */;
	if (!primFailCode) {
		return rcvr >= arg;
	}
	return null;
}

sqInt primitiveFloatGreaterThan(void) {
    sqInt aBool;
    sqInt sp;

	aBool = primitiveFloatGreaterthanArg(longAt(stackPointer - (1 * (BYTES_PER_WORD))), longAt(stackPointer));
	if (!primFailCode) {
		/* begin pop:thenPushBool: */
		longAtput((sp = stackPointer - ((2 - 1) * (BYTES_PER_WORD))), (aBool
			? trueObj
			: falseObj));
		stackPointer = sp;
	}
	return null;
}

sqInt primitiveFloatLessthanArg(sqInt rcvrOop, sqInt argOop) {
    double arg;
    double rcvr;

	/* begin loadFloatOrIntFrom: */
	if ((rcvrOop & 1)) {
		rcvr = ((double) ((rcvrOop >> 1)) );
		goto l1;
	}
	if ((fetchClassOfNonInt(rcvrOop)) == (longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassFloat << (SHIFT_FOR_WORD))))) {
		rcvr = floatValueOf(rcvrOop);
		goto l1;
	}
	/* begin primitiveFail */
	if (primFailCode == 0) {
		primFailCode = 1;
	}
l1:	/* end loadFloatOrIntFrom: */;
	/* begin loadFloatOrIntFrom: */
	if ((argOop & 1)) {
		arg = ((double) ((argOop >> 1)) );
		goto l2;
	}
	if ((fetchClassOfNonInt(argOop)) == (longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassFloat << (SHIFT_FOR_WORD))))) {
		arg = floatValueOf(argOop);
		goto l2;
	}
	/* begin primitiveFail */
	if (primFailCode == 0) {
		primFailCode = 1;
	}
l2:	/* end loadFloatOrIntFrom: */;
	if (!primFailCode) {
		return rcvr < arg;
	}
	return null;
}

sqInt primitiveFloatLessOrEqual(void) {
    sqInt aBool;
    sqInt sp;

	aBool = primitiveFloatLessOrEqualtoArg(longAt(stackPointer - (1 * (BYTES_PER_WORD))), longAt(stackPointer));
	if (!primFailCode) {
		/* begin pop:thenPushBool: */
		longAtput((sp = stackPointer - ((2 - 1) * (BYTES_PER_WORD))), (aBool
			? trueObj
			: falseObj));
		stackPointer = sp;
	}
	return null;
}

sqInt primitiveFloatLessOrEqualtoArg(sqInt rcvrOop, sqInt argOop) {
    double arg;
    double rcvr;

	/* begin loadFloatOrIntFrom: */
	if ((rcvrOop & 1)) {
		rcvr = ((double) ((rcvrOop >> 1)) );
		goto l1;
	}
	if ((fetchClassOfNonInt(rcvrOop)) == (longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassFloat << (SHIFT_FOR_WORD))))) {
		rcvr = floatValueOf(rcvrOop);
		goto l1;
	}
	/* begin primitiveFail */
	if (primFailCode == 0) {
		primFailCode = 1;
	}
l1:	/* end loadFloatOrIntFrom: */;
	/* begin loadFloatOrIntFrom: */
	if ((argOop & 1)) {
		arg = ((double) ((argOop >> 1)) );
		goto l2;
	}
	if ((fetchClassOfNonInt(argOop)) == (longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassFloat << (SHIFT_FOR_WORD))))) {
		arg = floatValueOf(argOop);
		goto l2;
	}
	/* begin primitiveFail */
	if (primFailCode == 0) {
		primFailCode = 1;
	}
l2:	/* end loadFloatOrIntFrom: */;
	if (!primFailCode) {
		return rcvr <= arg;
	}
	return null;
}

sqInt primitiveFloatLessThan(void) {
    sqInt aBool;
    sqInt sp;

	aBool = primitiveFloatLessthanArg(longAt(stackPointer - (1 * (BYTES_PER_WORD))), longAt(stackPointer));
	if (!primFailCode) {
		/* begin pop:thenPushBool: */
		longAtput((sp = stackPointer - ((2 - 1) * (BYTES_PER_WORD))), (aBool
			? trueObj
			: falseObj));
		stackPointer = sp;
	}
	return null;
}

sqInt primitiveFloatMultiply(void) {
	primitiveFloatMultiplybyArg(longAt(stackPointer - (1 * (BYTES_PER_WORD))), longAt(stackPointer));
	return null;
}

sqInt primitiveFloatMultiplybyArg(sqInt rcvrOop, sqInt argOop) {
    double arg;
    double rcvr;

	/* begin loadFloatOrIntFrom: */
	if ((rcvrOop & 1)) {
		rcvr = ((double) ((rcvrOop >> 1)) );
		goto l1;
	}
	if ((fetchClassOfNonInt(rcvrOop)) == (longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassFloat << (SHIFT_FOR_WORD))))) {
		rcvr = floatValueOf(rcvrOop);
		goto l1;
	}
	/* begin primitiveFail */
	if (primFailCode == 0) {
		primFailCode = 1;
	}
l1:	/* end loadFloatOrIntFrom: */;
	/* begin loadFloatOrIntFrom: */
	if ((argOop & 1)) {
		arg = ((double) ((argOop >> 1)) );
		goto l2;
	}
	if ((fetchClassOfNonInt(argOop)) == (longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassFloat << (SHIFT_FOR_WORD))))) {
		arg = floatValueOf(argOop);
		goto l2;
	}
	/* begin primitiveFail */
	if (primFailCode == 0) {
		primFailCode = 1;
	}
l2:	/* end loadFloatOrIntFrom: */;
	if (!primFailCode) {
		/* begin pop: */
		stackPointer -= 2 * (BYTES_PER_WORD);
		pushFloat(rcvr * arg);
	}
	return null;
}

sqInt primitiveFloatNotEqual(void) {
    sqInt aBool;
    sqInt sp;

	aBool = primitiveFloatEqualtoArg(longAt(stackPointer - (1 * (BYTES_PER_WORD))), longAt(stackPointer));
	if (!primFailCode) {
		/* begin pop:thenPushBool: */
		longAtput((sp = stackPointer - ((2 - 1) * (BYTES_PER_WORD))), (!aBool
			? trueObj
			: falseObj));
		stackPointer = sp;
	}
	return null;
}

sqInt primitiveFloatSubtract(void) {
	return primitiveFloatSubtractfromArg(longAt(stackPointer - (1 * (BYTES_PER_WORD))), longAt(stackPointer));
}

sqInt primitiveFloatSubtractfromArg(sqInt rcvrOop, sqInt argOop) {
    double arg;
    double rcvr;

	/* begin loadFloatOrIntFrom: */
	if ((rcvrOop & 1)) {
		rcvr = ((double) ((rcvrOop >> 1)) );
		goto l1;
	}
	if ((fetchClassOfNonInt(rcvrOop)) == (longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassFloat << (SHIFT_FOR_WORD))))) {
		rcvr = floatValueOf(rcvrOop);
		goto l1;
	}
	/* begin primitiveFail */
	if (primFailCode == 0) {
		primFailCode = 1;
	}
l1:	/* end loadFloatOrIntFrom: */;
	/* begin loadFloatOrIntFrom: */
	if ((argOop & 1)) {
		arg = ((double) ((argOop >> 1)) );
		goto l2;
	}
	if ((fetchClassOfNonInt(argOop)) == (longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassFloat << (SHIFT_FOR_WORD))))) {
		arg = floatValueOf(argOop);
		goto l2;
	}
	/* begin primitiveFail */
	if (primFailCode == 0) {
		primFailCode = 1;
	}
l2:	/* end loadFloatOrIntFrom: */;
	if (!primFailCode) {
		/* begin pop: */
		stackPointer -= 2 * (BYTES_PER_WORD);
		pushFloat(rcvr - arg);
	}
	return null;
}


/*	Clear the method lookup cache. This must be done after every programming change. */

sqInt primitiveFlushCache(void) {
    sqInt i;
    sqInt i1;

	/* begin flushMethodCache */
	for (i = 1; i <= MethodCacheSize; i += 1) {
		methodCache[i] = 0;
	}
	/* begin flushAtCache */
	for (i1 = 1; i1 <= AtCacheTotalSize; i1 += 1) {
		atCache[i1] = 0;
	}
	/* begin compilerFlushCacheHook: */
	if (compilerInitialized) {
		compilerFlushCache(null);
	}
	return null;
}


/*	The receiver is a compiledMethod.  Clear all entries in the method lookup cache that refer to this method, presumably because it has been redefined, overridden or removed. */

void primitiveFlushCacheByMethod(void) {
    sqInt i;
    sqInt oldMethod;
    sqInt probe;
    sqInt i1;

	oldMethod = longAt(stackPointer);
	probe = 0;
	for (i = 1; i <= MethodCacheEntries; i += 1) {
		if ((methodCache[probe + MethodCacheMethod]) == oldMethod) {
			methodCache[probe + MethodCacheSelector] = 0;
		}
		probe += MethodCacheEntrySize;
	}
	/* begin flushAtCache */
	for (i1 = 1; i1 <= AtCacheTotalSize; i1 += 1) {
		atCache[i1] = 0;
	}
	/* begin compilerFlushCacheHook: */
	if (compilerInitialized) {
		compilerFlushCache(oldMethod);
	}
}


/*	The receiver is a message selector.  Clear all entries in the method lookup cache with this selector, presumably because an associated method has been redefined. */

void primitiveFlushCacheBySelector(void) {
    sqInt i;
    sqInt probe;
    sqInt selector;
    sqInt i1;

	selector = longAt(stackPointer);
	probe = 0;
	for (i = 1; i <= MethodCacheEntries; i += 1) {
		if ((methodCache[probe + MethodCacheSelector]) == selector) {
			methodCache[probe + MethodCacheSelector] = 0;
		}
		probe += MethodCacheEntrySize;
	}
	if ((selector == (fetchPointerofObject(16 * 2, longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (SpecialSelectors << (SHIFT_FOR_WORD)))))) || (selector == (fetchPointerofObject(17 * 2, longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (SpecialSelectors << (SHIFT_FOR_WORD))))))) {
		/* begin flushAtCache */
		for (i1 = 1; i1 <= AtCacheTotalSize; i1 += 1) {
			atCache[i1] = 0;
		}
	}
}


/*	Primitive. Flush all the existing external primitives in the image thus forcing a reload on next invokation. */

sqInt primitiveFlushExternalPrimitives(void) {
	flushExternalPrimitives();
	return null;
}


/*	On some platforms, this primitive forces enqueued display updates to be processed immediately. On others, it does nothing. */

sqInt primitiveForceDisplayUpdate(void) {
	ioForceDisplayUpdate();
	return null;
}


/*	Set force tenure flag to true, this forces a tenure operation on the next incremental GC */

EXPORT(sqInt) primitiveForceTenure(void) {
	/* begin setForceTenureFlag: */
	forceTenureFlag = 1;
	return null;
}


/*	On platforms that support it, this primitive prints the receiver, assumed to be a Form, to the default printer. */

sqInt primitiveFormPrint(void) {
    sqInt bitsArray;
    sqInt bitsArraySize;
    sqInt depth;
    sqInt h;
    double  hScale;
    sqInt landscapeFlag;
    sqInt ok;
    sqInt pixelsPerWord;
    sqInt rcvr;
    double  vScale;
    sqInt w;
    sqInt wordsPerLine;
    sqInt fmt;
    sqInt header;
    sqInt sz;

	/* begin booleanValueOf: */
	if ((longAt(stackPointer)) == trueObj) {
		landscapeFlag = 1;
		goto l2;
	}
	if ((longAt(stackPointer)) == falseObj) {
		landscapeFlag = 0;
		goto l2;
	}
	/* begin primitiveFail */
	if (primFailCode == 0) {
		primFailCode = 1;
	}
	landscapeFlag = null;
l2:	/* end booleanValueOf: */;
	vScale = floatValueOf(longAt(stackPointer - (1 * (BYTES_PER_WORD))));
	hScale = floatValueOf(longAt(stackPointer - (2 * (BYTES_PER_WORD))));
	rcvr = longAt(stackPointer - (3 * (BYTES_PER_WORD)));
	if ((rcvr & 1)) {
		/* begin success: */
		if (!(0)) {
			if (!primFailCode) {
				primFailCode = 1;
			}
		}
	}
	if (!primFailCode) {
		if (!((((rcvr & 1) == 0) && (((((usqInt) (longAt(rcvr))) >> 8) & 15) <= 4)) && ((lengthOf(rcvr)) >= 4))) {
			/* begin success: */
			if (!(0)) {
				if (!primFailCode) {
					primFailCode = 1;
				}
			}
		}
	}
	if (!primFailCode) {
		bitsArray = longAt((rcvr + (BASE_HEADER_SIZE)) + (0 << (SHIFT_FOR_WORD)));
		w = fetchIntegerofObject(1, rcvr);
		h = fetchIntegerofObject(2, rcvr);
		depth = fetchIntegerofObject(3, rcvr);
		if (!((w > 0) && (h > 0))) {
			/* begin success: */
			if (!(0)) {
				if (!primFailCode) {
					primFailCode = 1;
				}
			}
		}
		pixelsPerWord = 32 / depth;
		wordsPerLine = (w + (pixelsPerWord - 1)) / pixelsPerWord;
		if ((!((rcvr & 1))) && (((bitsArray & 1) == 0) && (isWordsOrBytesNonInt(bitsArray)))) {
			/* begin byteLengthOf: */
			header = longAt(bitsArray);
			if ((header & TypeMask) == HeaderTypeSizeAndClass) {
				sz = (longAt(bitsArray - ((BYTES_PER_WORD) * 2))) & (ALL_BUT_TYPE_MASK);
			} else {
				sz = header & (SIZE_MASK);
			}
			fmt = (((usqInt) header) >> 8) & 15;
			if (fmt < 8) {
				bitsArraySize = sz - (BASE_HEADER_SIZE);
				goto l1;
			} else {
				bitsArraySize = (sz - (BASE_HEADER_SIZE)) - (fmt & 3);
				goto l1;
			}
		l1:	/* end byteLengthOf: */;
			/* begin success: */
			if (!(bitsArraySize == ((wordsPerLine * h) * 4))) {
				if (!primFailCode) {
					primFailCode = 1;
				}
			}
		} else {
			/* begin success: */
			if (!(0)) {
				if (!primFailCode) {
					primFailCode = 1;
				}
			}
		}
	}
	if (!primFailCode) {
		if ((BYTES_PER_WORD) == 8) {
			ok = ioFormPrint(bitsArray + 8, w, h, depth, hScale, vScale, landscapeFlag);
		} else {
			ok = ioFormPrint(bitsArray + 4, w, h, depth, hScale, vScale, landscapeFlag);
		}
		/* begin success: */
		if (!(ok)) {
			if (!primFailCode) {
				primFailCode = 1;
			}
		}
	}
	if (!primFailCode) {
		/* begin pop: */
		stackPointer -= 3 * (BYTES_PER_WORD);
	}
	return null;
}

sqInt primitiveFractionalPart(void) {
    double frac;
    double rcvr;
    double trunc;

	rcvr = popFloat();
	if (!primFailCode) {
		frac = modf(rcvr, &trunc);
		pushFloat(frac);
	} else {
		/* begin unPop: */
		stackPointer += 1 * (BYTES_PER_WORD);
	}
	return null;
}


/*	Do a full garbage collection and return the number of bytes available (including swap space if dynamic memory management is supported). */

sqInt primitiveFullGC(void) {
    sqInt object;
    sqInt sp;

	/* begin pop: */
	stackPointer -= 1 * (BYTES_PER_WORD);
	incrementalGC();
	fullGC();
	/* begin push: */
	object = positive64BitIntegerFor(((longAt(freeBlock)) & (ALL_BUT_TYPE_MASK)) + (sqMemoryExtraBytesLeft(1)));
	longAtput((sp = stackPointer + (BYTES_PER_WORD)), object);
	stackPointer = sp;
	return null;
}


/*	Fetch the system attribute with the given integer ID. The 
	result is a string, which will be empty if the attribute is not 
	defined. */

sqInt primitiveGetAttribute(void) {
    sqInt attr;
    sqInt s;
    sqInt sz;
    sqInt sp;
    sqInt integerPointer;

	/* begin stackIntegerValue: */
	integerPointer = longAt(stackPointer - (0 * (BYTES_PER_WORD)));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		attr = (integerPointer >> 1);
		goto l1;
	} else {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		attr = 0;
		goto l1;
	}
	attr = null;
l1:	/* end stackIntegerValue: */;
	if (!primFailCode) {
		sz = attributeSize(attr);
	}
	if (!primFailCode) {
		s = instantiateClassindexableSize(longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassString << (SHIFT_FOR_WORD))), sz);
		getAttributeIntoLength(attr, s + (BASE_HEADER_SIZE), sz);
		/* begin pop:thenPush: */
		longAtput((sp = stackPointer - ((2 - 1) * (BYTES_PER_WORD))), s);
		stackPointer = sp;
	}
	return null;
}


/*	Primitive. Return the next input event from the VM event queue. */

sqInt primitiveGetNextEvent(void) {
    sqInt arg;
    sqInt eventTypeIs;
    int evtBuf[8] = { 0, 0, 0, 0, 0, 0, 0, 0 };
    sqInt i;
    sqInt value;
    sqInt oop;

	;
	arg = longAt(stackPointer);
	if (!((((arg & 1) == 0) && (((((usqInt) (longAt(arg))) >> 8) & 15) == 2)) && ((slotSizeOf(arg)) == 8))) {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		return null;
	}
	ioGetNextEvent(((sqInputEvent*) evtBuf));
	if (!(!primFailCode)) {
		return null;
	}
	eventTypeIs = evtBuf[0];
	/* begin storeInteger:ofObject:withValue: */
	if (
# ifdef SQ_HOST32  // cast to int for 64 bit image on 32 bit host
		(((((int) (evtBuf[0]))) ^ ((((int) (evtBuf[0]))) << 1)) >= 0)
# else
		(((evtBuf[0]) >= -1073741824) && ((evtBuf[0]) <= 1073741823))
# endif  // SQ_HOST32
	) {
		longAtput((arg + (BASE_HEADER_SIZE)) + (0 << (SHIFT_FOR_WORD)), (((evtBuf[0]) << 1) | 1));
	} else {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
	}
	if (!(!primFailCode)) {
		return null;
	}
	if (eventTypeIs == 6) {
		for (i = 1; i <= 7; i += 1) {
			value = evtBuf[i];
			/* begin storePointer:ofObject:withValue: */
			if ((((usqInt) arg)) < (((usqInt) youngStart))) {
				possibleRootStoreIntovalue(arg, value);
			}
			longAtput((arg + (BASE_HEADER_SIZE)) + (i << (SHIFT_FOR_WORD)), value);
		}
	} else {

		/* Event time stamp */

		/* begin storeInteger:ofObject:withValue: */
		if (
# ifdef SQ_HOST32  // cast to int for 64 bit image on 32 bit host
			(((((int) ((evtBuf[1]) & MillisecondClockMask))) ^ ((((int) ((evtBuf[1]) & MillisecondClockMask))) << 1)) >= 0)
# else
			((((evtBuf[1]) & MillisecondClockMask) >= -1073741824) && (((evtBuf[1]) & MillisecondClockMask) <= 1073741823))
# endif  // SQ_HOST32
		) {
			longAtput((arg + (BASE_HEADER_SIZE)) + (1 << (SHIFT_FOR_WORD)), ((((evtBuf[1]) & MillisecondClockMask) << 1) | 1));
		} else {
			/* begin primitiveFail */
			if (primFailCode == 0) {
				primFailCode = 1;
			}
		}
		if (!(!primFailCode)) {
			return null;
		}
		for (i = 2; i <= 7; i += 1) {
			value = evtBuf[i];
			if (
# ifdef SQ_HOST32  // cast to int for 64 bit image on 32 bit host
				(((((int) value)) ^ ((((int) value)) << 1)) >= 0)
# else
				((value >= -1073741824) && (value <= 1073741823))
# endif  // SQ_HOST32
			) {
				/* begin storeInteger:ofObject:withValue: */
				if (
# ifdef SQ_HOST32  // cast to int for 64 bit image on 32 bit host
					(((((int) value)) ^ ((((int) value)) << 1)) >= 0)
# else
					((value >= -1073741824) && (value <= 1073741823))
# endif  // SQ_HOST32
				) {
					longAtput((arg + (BASE_HEADER_SIZE)) + (i << (SHIFT_FOR_WORD)), ((value << 1) | 1));
				} else {
					/* begin primitiveFail */
					if (primFailCode == 0) {
						primFailCode = 1;
					}
				}
			} else {

				/* Need to remap because allocation may cause GC */

				/* begin pushRemappableOop: */
				remapBuffer[(remapBufferCount += 1)] = arg;
				value = positive32BitIntegerFor(value);
				/* begin popRemappableOop */
				oop = remapBuffer[remapBufferCount];
				remapBufferCount -= 1;
				arg = oop;
				/* begin storePointer:ofObject:withValue: */
				if ((((usqInt) arg)) < (((usqInt) youngStart))) {
					possibleRootStoreIntovalue(arg, value);
				}
				longAtput((arg + (BASE_HEADER_SIZE)) + (i << (SHIFT_FOR_WORD)), value);
			}
		}
	}
	if (!(!primFailCode)) {
		return null;
	}
	/* begin pop: */
	stackPointer -= 1 * (BYTES_PER_WORD);
	return null;
}

sqInt primitiveGreaterOrEqual(void) {
    sqInt integerArgument;
    sqInt integerReceiver;
    sqInt integerPointer;
    sqInt top;
    sqInt integerPointer1;
    sqInt top1;
    sqInt sp;
    sqInt sp1;

	/* begin popInteger */
	/* begin popStack */
	top = longAt(stackPointer);
	stackPointer -= BYTES_PER_WORD;
	integerPointer = top;
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		integerArgument = (integerPointer >> 1);
		goto l1;
	} else {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		integerArgument = 0;
		goto l1;
	}
	integerArgument = null;
l1:	/* end popInteger */;
	/* begin popInteger */
	/* begin popStack */
	top1 = longAt(stackPointer);
	stackPointer -= BYTES_PER_WORD;
	integerPointer1 = top1;
	/* begin checkedIntegerValueOf: */
	if ((integerPointer1 & 1)) {
		integerReceiver = (integerPointer1 >> 1);
		goto l2;
	} else {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		integerReceiver = 0;
		goto l2;
	}
	integerReceiver = null;
l2:	/* end popInteger */;
	/* begin checkBooleanResult: */
	if (!primFailCode) {
		/* begin pushBool: */
		if (integerReceiver >= integerArgument) {
			/* begin push: */
			longAtput((sp = stackPointer + (BYTES_PER_WORD)), trueObj);
			stackPointer = sp;
		} else {
			/* begin push: */
			longAtput((sp1 = stackPointer + (BYTES_PER_WORD)), falseObj);
			stackPointer = sp1;
		}
	} else {
		/* begin unPop: */
		stackPointer += 2 * (BYTES_PER_WORD);
	}
	return null;
}


/*	Primitive comparison operations for large integers in 64 bit range */

EXPORT(sqInt) primitiveGreaterOrEqualLargeIntegers(void) {
    sqLong integerArg;
    sqLong integerRcvr;
    sqInt sp;

	integerArg = signed64BitValueOf(longAt(stackPointer - (0 * (BYTES_PER_WORD))));
	integerRcvr = signed64BitValueOf(longAt(stackPointer - (1 * (BYTES_PER_WORD))));
	if (!primFailCode) {
		/* begin pop:thenPushBool: */
		longAtput((sp = stackPointer - ((2 - 1) * (BYTES_PER_WORD))), (integerRcvr >= integerArg
			? trueObj
			: falseObj));
		stackPointer = sp;
	}
	return null;
}

sqInt primitiveGreaterThan(void) {
    sqInt integerArgument;
    sqInt integerReceiver;
    sqInt integerPointer;
    sqInt top;
    sqInt integerPointer1;
    sqInt top1;
    sqInt sp;
    sqInt sp1;

	/* begin popInteger */
	/* begin popStack */
	top = longAt(stackPointer);
	stackPointer -= BYTES_PER_WORD;
	integerPointer = top;
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		integerArgument = (integerPointer >> 1);
		goto l1;
	} else {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		integerArgument = 0;
		goto l1;
	}
	integerArgument = null;
l1:	/* end popInteger */;
	/* begin popInteger */
	/* begin popStack */
	top1 = longAt(stackPointer);
	stackPointer -= BYTES_PER_WORD;
	integerPointer1 = top1;
	/* begin checkedIntegerValueOf: */
	if ((integerPointer1 & 1)) {
		integerReceiver = (integerPointer1 >> 1);
		goto l2;
	} else {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		integerReceiver = 0;
		goto l2;
	}
	integerReceiver = null;
l2:	/* end popInteger */;
	/* begin checkBooleanResult: */
	if (!primFailCode) {
		/* begin pushBool: */
		if (integerReceiver > integerArgument) {
			/* begin push: */
			longAtput((sp = stackPointer + (BYTES_PER_WORD)), trueObj);
			stackPointer = sp;
		} else {
			/* begin push: */
			longAtput((sp1 = stackPointer + (BYTES_PER_WORD)), falseObj);
			stackPointer = sp1;
		}
	} else {
		/* begin unPop: */
		stackPointer += 2 * (BYTES_PER_WORD);
	}
	return null;
}


/*	Primitive comparison operations for large integers in 64 bit range */

EXPORT(sqInt) primitiveGreaterThanLargeIntegers(void) {
    sqLong integerArg;
    sqLong integerRcvr;
    sqInt sp;

	integerArg = signed64BitValueOf(longAt(stackPointer - (0 * (BYTES_PER_WORD))));
	integerRcvr = signed64BitValueOf(longAt(stackPointer - (1 * (BYTES_PER_WORD))));
	if (!primFailCode) {
		/* begin pop:thenPushBool: */
		longAtput((sp = stackPointer - ((2 - 1) * (BYTES_PER_WORD))), (integerRcvr > integerArg
			? trueObj
			: falseObj));
		stackPointer = sp;
	}
	return null;
}


/*	is the receiver/first argument the same object as the (last) argument?.
	 pop argumentCount because this can be used as a mirror primitive. */

sqInt primitiveIdentical(void) {
    sqInt otherObject;
    sqInt thisObject;
    sqInt sp;

	otherObject = longAt(stackPointer - (1 * (BYTES_PER_WORD)));
	thisObject = longAt(stackPointer);
	/* begin pop:thenPushBool: */
	longAtput((sp = stackPointer - (((argumentCount + 1) - 1) * (BYTES_PER_WORD))), (thisObject == otherObject
		? trueObj
		: falseObj));
	stackPointer = sp;
	return null;
}


/*	Answer an integer identifying the type of image. The image version number may
	identify the format of the image (e.g. 32 or 64-bit word size) or specific requirements
	of the image (e.g. block closure support required).
	
	This is a named (not numbered) primitive in the null module (ie the VM) */

EXPORT(sqInt) primitiveImageFormatVersion(void) {
    sqInt oop;
    sqInt sp;

	/* begin pop:thenPush: */
	oop = positive32BitIntegerFor(imageFormatVersionNumber);
	longAtput((sp = stackPointer - ((1 - 1) * (BYTES_PER_WORD))), oop);
	stackPointer = sp;
	return null;
}


/*	When called with a single string argument, record the string as the current image file name. When called with zero arguments, return a string containing the current image file name. */

sqInt primitiveImageName(void) {
    sqInt okToRename;
    sqInt s;
    void *sCRIfn;
    sqInt sz;
    sqInt sp;
    sqInt classOop;
    sqInt ccIndex;
    sqInt cl;
    sqInt oop1;

	if (argumentCount == 1) {

		/* If the security plugin can be loaded, use it to check for rename permission.
		If not, assume it's ok */

		sCRIfn = ioLoadFunctionFrom("secCanRenameImage", "SecurityPlugin");
		if (sCRIfn != 0) {
			okToRename =  ((sqInt (*)(void))sCRIfn)();
			if (!(okToRename)) {
				/* begin primitiveFail */
				if (primFailCode == 0) {
					primFailCode = 1;
				}
				return null;
			}
		}
		s = longAt(stackPointer);
		/* begin assertClassOf:is: */
		classOop = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassString << (SHIFT_FOR_WORD)));
		if ((s & 1)) {
			/* begin primitiveFail */
			if (primFailCode == 0) {
				primFailCode = 1;
			}
			goto l1;
		}
		ccIndex = (((usqInt) (longAt(s))) >> 12) & 31;
		if (ccIndex == 0) {
			cl = (longAt(s - (BASE_HEADER_SIZE))) & (ALL_BUT_TYPE_MASK);
		} else {
			/* begin fetchPointer:ofObject: */
			oop1 = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (CompactClasses << (SHIFT_FOR_WORD)));
			cl = longAt((oop1 + (BASE_HEADER_SIZE)) + ((ccIndex - 1) << (SHIFT_FOR_WORD)));
		}
		/* begin success: */
		if (!(cl == classOop)) {
			if (!primFailCode) {
				primFailCode = 1;
			}
		}
	l1:	/* end assertClassOf:is: */;
		if (!primFailCode) {
			sz = stSizeOf(s);
			imageNamePutLength(s + (BASE_HEADER_SIZE), sz);
			/* begin pop: */
			stackPointer -= 1 * (BYTES_PER_WORD);
		}
	} else {
		sz = imageNameSize();
		s = instantiateClassindexableSize(longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassString << (SHIFT_FOR_WORD))), sz);
		imageNameGetLength(s + (BASE_HEADER_SIZE), sz);
		/* begin pop: */
		stackPointer -= 1 * (BYTES_PER_WORD);
		/* begin push: */
		longAtput((sp = stackPointer + (BYTES_PER_WORD)), s);
		stackPointer = sp;
	}
	return null;
}


/*	Do a quick, incremental garbage collection and return the number of bytes immediately available. (Note: more space may be made available by doing a full garbage collection. */

sqInt primitiveIncrementalGC(void) {
    sqInt object;
    sqInt sp;

	/* begin pop: */
	stackPointer -= 1 * (BYTES_PER_WORD);
	incrementalGC();
	/* begin push: */
	object = positive64BitIntegerFor(((longAt(freeBlock)) & (ALL_BUT_TYPE_MASK)) + (sqMemoryExtraBytesLeft(0)));
	longAtput((sp = stackPointer + (BYTES_PER_WORD)), object);
	stackPointer = sp;
	return null;
}


/*	Note: We now have 10 bits of primitive index, but they are in two places
	for temporary backward compatibility.  The time to unpack is negligible,
	since the reconstituted full index is stored in the method cache. */

sqInt primitiveIndexOf(sqInt methodPointer) {
    sqInt primBits;

	primBits = (((usqInt) (longAt((methodPointer + (BASE_HEADER_SIZE)) + (HeaderIndex << (SHIFT_FOR_WORD))))) >> 1) & 268435967;
	return (primBits & 511) + (((usqInt) primBits) >> 19);
}


/*	Register the input semaphore. The argument is an index into the ExternalObjectsArray part of the specialObjectsArray and must have been allocated via 'Smalltalk registerExternalObject: the Semaphore'  */

sqInt primitiveInputSemaphore(void) {
    sqInt arg;

	arg = longAt(stackPointer);
	if ((arg & 1)) {

		/* If arg is integer, then condsider it as an index  into the external objects array and install it  as the new event semaphore */

		ioSetInputSemaphore((arg >> 1));
		if (!primFailCode) {
			/* begin pop: */
			stackPointer -= 1 * (BYTES_PER_WORD);
		}
		return null;
	}
	return null;
}


/*	Return an integer indicating the reason for the most recent input interrupt. */

sqInt primitiveInputWord(void) {
    sqInt sp;

	/* begin pop:thenPushInteger: */
	longAtput((sp = stackPointer - ((1 - 1) * (BYTES_PER_WORD))), ((0 << 1) | 1));
	stackPointer = sp;
	return null;
}

sqInt primitiveInstVarAt(void) {
    sqInt fixedFields;
    sqInt fmt;
    sqInt hdr;
    sqInt index;
    sqInt rcvr;
    sqInt totalLength;
    sqInt value;
    sqInt sp;
    sqInt sz;
    sqInt class;
    sqInt classFormat;
    sqInt ccIndex;
    sqInt oop1;
    sqInt integerPointer;

	/* begin stackIntegerValue: */
	integerPointer = longAt(stackPointer - (0 * (BYTES_PER_WORD)));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		index = (integerPointer >> 1);
		goto l5;
	} else {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		index = 0;
		goto l5;
	}
	index = null;
l5:	/* end stackIntegerValue: */;
	rcvr = longAt(stackPointer - (1 * (BYTES_PER_WORD)));
	if (!primFailCode) {
		hdr = longAt(rcvr);
		fmt = (((usqInt) hdr) >> 8) & 15;
		/* begin lengthOf:baseHeader:format: */
		if ((hdr & TypeMask) == HeaderTypeSizeAndClass) {
			sz = (longAt(rcvr - ((BYTES_PER_WORD) * 2))) & (LONG_SIZE_MASK);
		} else {
			sz = hdr & (SIZE_MASK);
		}
		sz -= hdr & (SIZE_4_BIT);
		if (fmt <= 4) {
			totalLength = ((usqInt) (sz - (BASE_HEADER_SIZE))) >> (SHIFT_FOR_WORD);
			goto l1;
		}
		if (fmt < 8) {
			totalLength = ((usqInt) (sz - (BASE_HEADER_SIZE))) >> 2;
			goto l1;
		} else {
			totalLength = (sz - (BASE_HEADER_SIZE)) - (fmt & 3);
			goto l1;
		}
	l1:	/* end lengthOf:baseHeader:format: */;
		/* begin fixedFieldsOf:format:length: */
		if ((fmt > 4) || (fmt == 2)) {
			fixedFields = 0;
			goto l2;
		}
		if (fmt < 2) {
			fixedFields = totalLength;
			goto l2;
		}
		/* begin fetchClassOf: */
		if ((rcvr & 1)) {
			class = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassInteger << (SHIFT_FOR_WORD)));
			goto l4;
		}
		ccIndex = (((usqInt) (longAt(rcvr))) >> 12) & 31;
		if (ccIndex == 0) {
			class = (longAt(rcvr - (BASE_HEADER_SIZE))) & (ALL_BUT_TYPE_MASK);
			goto l4;
		} else {
			/* begin fetchPointer:ofObject: */
			oop1 = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (CompactClasses << (SHIFT_FOR_WORD)));
			class = longAt((oop1 + (BASE_HEADER_SIZE)) + ((ccIndex - 1) << (SHIFT_FOR_WORD)));
			goto l4;
		}
	l4:	/* end fetchClassOf: */;
		classFormat = (longAt((class + (BASE_HEADER_SIZE)) + (InstanceSpecificationIndex << (SHIFT_FOR_WORD)))) - 1;
		fixedFields = (((((usqInt) classFormat) >> 11) & 192) + ((((usqInt) classFormat) >> 2) & 63)) - 1;
	l2:	/* end fixedFieldsOf:format:length: */;
		if (!((index >= 1) && (index <= fixedFields))) {
			/* begin primitiveFail */
			if (primFailCode == 0) {
				primFailCode = 1;
			}
		}
	}
	if (!primFailCode) {
		/* begin subscript:with:format: */
		if (fmt <= 4) {
			value = longAt((rcvr + (BASE_HEADER_SIZE)) + ((index - 1) << (SHIFT_FOR_WORD)));
			goto l3;
		}
		if (fmt < 8) {
			value = positive32BitIntegerFor(long32At((rcvr + (BASE_HEADER_SIZE)) + ((index - 1) << 2)));
			goto l3;
		} else {
			value = (((byteAt((rcvr + (BASE_HEADER_SIZE)) + (index - 1))) << 1) | 1);
			goto l3;
		}
	l3:	/* end subscript:with:format: */;
	}
	if (!primFailCode) {
		/* begin pop:thenPush: */
		longAtput((sp = stackPointer - (((argumentCount + 1) - 1) * (BYTES_PER_WORD))), value);
		stackPointer = sp;
	}
	return null;
}

sqInt primitiveInstVarAtPut(void) {
    sqInt fixedFields;
    sqInt fmt;
    sqInt hdr;
    sqInt index;
    sqInt newValue;
    sqInt rcvr;
    sqInt totalLength;
    sqInt sp;
    sqInt sz;
    sqInt class;
    sqInt classFormat;
    sqInt ccIndex;
    sqInt oop1;
    sqInt valueToStore;
    sqInt integerPointer;

	newValue = longAt(stackPointer);
	/* begin stackIntegerValue: */
	integerPointer = longAt(stackPointer - (1 * (BYTES_PER_WORD)));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		index = (integerPointer >> 1);
		goto l4;
	} else {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		index = 0;
		goto l4;
	}
	index = null;
l4:	/* end stackIntegerValue: */;
	rcvr = longAt(stackPointer - (2 * (BYTES_PER_WORD)));
	if (!primFailCode) {
		hdr = longAt(rcvr);
		fmt = (((usqInt) hdr) >> 8) & 15;
		/* begin lengthOf:baseHeader:format: */
		if ((hdr & TypeMask) == HeaderTypeSizeAndClass) {
			sz = (longAt(rcvr - ((BYTES_PER_WORD) * 2))) & (LONG_SIZE_MASK);
		} else {
			sz = hdr & (SIZE_MASK);
		}
		sz -= hdr & (SIZE_4_BIT);
		if (fmt <= 4) {
			totalLength = ((usqInt) (sz - (BASE_HEADER_SIZE))) >> (SHIFT_FOR_WORD);
			goto l1;
		}
		if (fmt < 8) {
			totalLength = ((usqInt) (sz - (BASE_HEADER_SIZE))) >> 2;
			goto l1;
		} else {
			totalLength = (sz - (BASE_HEADER_SIZE)) - (fmt & 3);
			goto l1;
		}
	l1:	/* end lengthOf:baseHeader:format: */;
		/* begin fixedFieldsOf:format:length: */
		if ((fmt > 4) || (fmt == 2)) {
			fixedFields = 0;
			goto l2;
		}
		if (fmt < 2) {
			fixedFields = totalLength;
			goto l2;
		}
		/* begin fetchClassOf: */
		if ((rcvr & 1)) {
			class = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassInteger << (SHIFT_FOR_WORD)));
			goto l3;
		}
		ccIndex = (((usqInt) (longAt(rcvr))) >> 12) & 31;
		if (ccIndex == 0) {
			class = (longAt(rcvr - (BASE_HEADER_SIZE))) & (ALL_BUT_TYPE_MASK);
			goto l3;
		} else {
			/* begin fetchPointer:ofObject: */
			oop1 = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (CompactClasses << (SHIFT_FOR_WORD)));
			class = longAt((oop1 + (BASE_HEADER_SIZE)) + ((ccIndex - 1) << (SHIFT_FOR_WORD)));
			goto l3;
		}
	l3:	/* end fetchClassOf: */;
		classFormat = (longAt((class + (BASE_HEADER_SIZE)) + (InstanceSpecificationIndex << (SHIFT_FOR_WORD)))) - 1;
		fixedFields = (((((usqInt) classFormat) >> 11) & 192) + ((((usqInt) classFormat) >> 2) & 63)) - 1;
	l2:	/* end fixedFieldsOf:format:length: */;
		if (!((index >= 1) && (index <= fixedFields))) {
			/* begin primitiveFail */
			if (primFailCode == 0) {
				primFailCode = 1;
			}
		}
	}
	if (!primFailCode) {
		/* begin subscript:with:storing:format: */
		if (fmt <= 4) {
			/* begin storePointer:ofObject:withValue: */
			if ((((usqInt) rcvr)) < (((usqInt) youngStart))) {
				possibleRootStoreIntovalue(rcvr, newValue);
			}
			longAtput((rcvr + (BASE_HEADER_SIZE)) + ((index - 1) << (SHIFT_FOR_WORD)), newValue);
		} else {
			if (fmt < 8) {
				valueToStore = positive32BitValueOf(newValue);
				if (!primFailCode) {
					long32Atput((rcvr + (BASE_HEADER_SIZE)) + ((index - 1) << 2), valueToStore);
				}
			} else {
				if (!((newValue & 1))) {
					/* begin primitiveFail */
					if (primFailCode == 0) {
						primFailCode = 1;
					}
				}
				valueToStore = (newValue >> 1);
				if (!((valueToStore >= 0) && (valueToStore <= 255))) {
					/* begin primitiveFail */
					if (primFailCode == 0) {
						primFailCode = 1;
					}
				}
				if (!primFailCode) {
					byteAtput((rcvr + (BASE_HEADER_SIZE)) + (index - 1), valueToStore);
				}
			}
		}
	}
	if (!primFailCode) {
		/* begin pop:thenPush: */
		longAtput((sp = stackPointer - (((argumentCount + 1) - 1) * (BYTES_PER_WORD))), newValue);
		stackPointer = sp;
	}
	return null;
}


/*	Return the 32bit signed integer contents of a words receiver */

sqInt primitiveIntegerAt(void) {
    sqInt addr;
    sqInt index;
    int intValue;
    sqInt rcvr;
    sqInt sz;
    sqInt value;
    sqInt object;
    sqInt sp;
    sqInt header;
    sqInt sp1;
    sqInt sz1;
    sqInt successBoolean;
    sqInt integerPointer;

	/* begin stackIntegerValue: */
	integerPointer = longAt(stackPointer - (0 * (BYTES_PER_WORD)));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		index = (integerPointer >> 1);
		goto l2;
	} else {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		index = 0;
		goto l2;
	}
	index = null;
l2:	/* end stackIntegerValue: */;
	rcvr = longAt(stackPointer - (1 * (BYTES_PER_WORD)));
	if ((rcvr & 1)) {
		/* begin success: */
		if (!(0)) {
			if (!primFailCode) {
				primFailCode = 1;
			}
		}
		return null;
	}
	if (!(((rcvr & 1) == 0) && (((((usqInt) (longAt(rcvr))) >> 8) & 15) == 6))) {
		/* begin success: */
		if (!(0)) {
			if (!primFailCode) {
				primFailCode = 1;
			}
		}
		return null;
	}
	/* begin lengthOf: */
	header = longAt(rcvr);
	/* begin lengthOf:baseHeader:format: */
	if ((header & TypeMask) == HeaderTypeSizeAndClass) {
		sz1 = (longAt(rcvr - ((BYTES_PER_WORD) * 2))) & (LONG_SIZE_MASK);
	} else {
		sz1 = header & (SIZE_MASK);
	}
	sz1 -= header & (SIZE_4_BIT);
	if (((((usqInt) header) >> 8) & 15) <= 4) {
		sz = ((usqInt) (sz1 - (BASE_HEADER_SIZE))) >> (SHIFT_FOR_WORD);
		goto l1;
	}
	if (((((usqInt) header) >> 8) & 15) < 8) {
		sz = ((usqInt) (sz1 - (BASE_HEADER_SIZE))) >> 2;
		goto l1;
	} else {
		sz = (sz1 - (BASE_HEADER_SIZE)) - (((((usqInt) header) >> 8) & 15) & 3);
		goto l1;
	}
l1:	/* end lengthOf:baseHeader:format: */;
	/* begin success: */
	successBoolean = (index >= 1) && (index <= sz);
	if (!(successBoolean)) {
		if (!primFailCode) {
			primFailCode = 1;
		}
	}
	if (!primFailCode) {

		/* for zero indexing */

		addr = ((rcvr + (BASE_HEADER_SIZE)) - 4) + (index * 4);
		value = intAt(addr);
		/* begin pop: */
		stackPointer -= 2 * (BYTES_PER_WORD);
		if (
# ifdef SQ_HOST32  // cast to int for 64 bit image on 32 bit host
			(((((int) value)) ^ ((((int) value)) << 1)) >= 0)
# else
			((value >= -1073741824) && (value <= 1073741823))
# endif  // SQ_HOST32
		) {
			/* begin pushInteger: */
			/* begin push: */
			longAtput((sp1 = stackPointer + (BYTES_PER_WORD)), ((value << 1) | 1));
			stackPointer = sp1;
		} else {

			/* 32 bit int may have been stored in 32 or 64 bit sqInt */

			intValue = value;
			/* begin push: */
			object = signed32BitIntegerFor(intValue);
			longAtput((sp = stackPointer + (BYTES_PER_WORD)), object);
			stackPointer = sp;
		}
	}
	return null;
}


/*	Return the 32bit signed integer contents of a words receiver */

sqInt primitiveIntegerAtPut(void) {
    sqInt addr;
    sqInt index;
    sqInt rcvr;
    sqInt sz;
    sqInt value;
    sqInt valueOop;
    sqInt sp;
    sqInt header;
    sqInt sz1;
    sqInt integerPointer;

	valueOop = longAt(stackPointer - (0 * (BYTES_PER_WORD)));
	/* begin stackIntegerValue: */
	integerPointer = longAt(stackPointer - (1 * (BYTES_PER_WORD)));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		index = (integerPointer >> 1);
		goto l2;
	} else {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		index = 0;
		goto l2;
	}
	index = null;
l2:	/* end stackIntegerValue: */;
	rcvr = longAt(stackPointer - (2 * (BYTES_PER_WORD)));
	if ((rcvr & 1)) {
		/* begin success: */
		if (!(0)) {
			if (!primFailCode) {
				primFailCode = 1;
			}
		}
		return null;
	}
	if (!(((rcvr & 1) == 0) && (((((usqInt) (longAt(rcvr))) >> 8) & 15) == 6))) {
		/* begin success: */
		if (!(0)) {
			if (!primFailCode) {
				primFailCode = 1;
			}
		}
		return null;
	}
	/* begin lengthOf: */
	header = longAt(rcvr);
	/* begin lengthOf:baseHeader:format: */
	if ((header & TypeMask) == HeaderTypeSizeAndClass) {
		sz1 = (longAt(rcvr - ((BYTES_PER_WORD) * 2))) & (LONG_SIZE_MASK);
	} else {
		sz1 = header & (SIZE_MASK);
	}
	sz1 -= header & (SIZE_4_BIT);
	if (((((usqInt) header) >> 8) & 15) <= 4) {
		sz = ((usqInt) (sz1 - (BASE_HEADER_SIZE))) >> (SHIFT_FOR_WORD);
		goto l1;
	}
	if (((((usqInt) header) >> 8) & 15) < 8) {
		sz = ((usqInt) (sz1 - (BASE_HEADER_SIZE))) >> 2;
		goto l1;
	} else {
		sz = (sz1 - (BASE_HEADER_SIZE)) - (((((usqInt) header) >> 8) & 15) & 3);
		goto l1;
	}
l1:	/* end lengthOf:baseHeader:format: */;
	if (!((index >= 1) && (index <= sz))) {
		/* begin success: */
		if (!(0)) {
			if (!primFailCode) {
				primFailCode = 1;
			}
		}
		return null;
	}
	if ((valueOop & 1)) {
		value = (valueOop >> 1);
	} else {
		value = signed32BitValueOf(valueOop);
	}
	if (!primFailCode) {

		/* for zero indexing */

		addr = ((rcvr + (BASE_HEADER_SIZE)) - 4) + (index * 4);
		value = intAtput(addr, value);
		/* begin pop:thenPush: */
		longAtput((sp = stackPointer - ((3 - 1) * (BYTES_PER_WORD))), valueOop);
		stackPointer = sp;
	}
	return null;
}


/*	Answer a string corresponding to the version of the interpreter source. This
	represents the version level of the Smalltalk source code (interpreter and various
	plugins) that is translated to C by a CCodeGenerator, as distinct from the external
	platform source code, typically written in C and managed separately for each platform.
	This is a named (not numbered) primitive in the null module (ie the VM) */

EXPORT(sqInt) primitiveInterpreterSourceVersion(void) {
    char *cString;
    sqInt len;
    void * p;
    sqInt versionString;
    sqInt sp;

	cString = InterpreterSourceVersion;
	len = strlen(cString);
	versionString = instantiateClassindexableSize(longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassString << (SHIFT_FOR_WORD))), len);
	/* begin arrayValueOf: */
	if ((!((versionString & 1))) && (((versionString & 1) == 0) && (isWordsOrBytesNonInt(versionString)))) {
		p = pointerForOop(versionString + (BASE_HEADER_SIZE));
		goto l1;
	}
	/* begin primitiveFail */
	if (primFailCode == 0) {
		primFailCode = 1;
	}
l1:	/* end arrayValueOf: */;
	strncpy(p, cString, len);
	/* begin pop:thenPush: */
	longAtput((sp = stackPointer - ((1 - 1) * (BYTES_PER_WORD))), versionString);
	stackPointer = sp;
	return null;
}


/*	Register the user interrupt semaphore. If the argument is 
	not a Semaphore, unregister the current interrupt 
	semaphore.  */

sqInt primitiveInterruptSemaphore(void) {
    sqInt arg;
    sqInt top;

	/* begin popStack */
	top = longAt(stackPointer);
	stackPointer -= BYTES_PER_WORD;
	arg = top;
	if ((fetchClassOf(arg)) == (longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassSemaphore << (SHIFT_FOR_WORD))))) {
		/* begin storePointer:ofObject:withValue: */
		if ((((usqInt) specialObjectsOop)) < (((usqInt) youngStart))) {
			possibleRootStoreIntovalue(specialObjectsOop, arg);
		}
		longAtput((specialObjectsOop + (BASE_HEADER_SIZE)) + (TheInterruptSemaphore << (SHIFT_FOR_WORD)), arg);
	} else {
		/* begin storePointer:ofObject:withValue: */
		if ((((usqInt) specialObjectsOop)) < (((usqInt) youngStart))) {
			possibleRootStoreIntovalue(specialObjectsOop, nilObj);
		}
		longAtput((specialObjectsOop + (BASE_HEADER_SIZE)) + (TheInterruptSemaphore << (SHIFT_FOR_WORD)), nilObj);
	}
	return null;
}


/*	Primitive. 'Invoke' an object like a function, sending the special message 
		run: originalSelector with: arguments in: aReceiver.
	 */

void primitiveInvokeObjectAsMethod(void) {
    sqInt lookupClass;
    sqInt newReceiver;
    sqInt runArgs;
    sqInt runReceiver;
    sqInt runSelector;
    sqInt in;
    sqInt lastIn;
    sqInt out;
    sqInt sp;
    sqInt sp1;
    sqInt sp2;
    sqInt sp3;
    sqInt ccIndex;
    sqInt oop1;

	runArgs = instantiateClassindexableSize(longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassArray << (SHIFT_FOR_WORD))), argumentCount);
	beRootIfOld(runArgs);
	/* begin transfer:from:to: */
	flag("Dan");
	in = (stackPointer - ((argumentCount - 1) * (BYTES_PER_WORD))) - (BYTES_PER_WORD);
	lastIn = in + (argumentCount * (BYTES_PER_WORD));
	out = (runArgs + (BASE_HEADER_SIZE)) - (BYTES_PER_WORD);
	while ((((usqInt) in)) < (((usqInt) lastIn))) {
		longAtput((out += BYTES_PER_WORD), longAt((in += BYTES_PER_WORD)));
	}
	runSelector = messageSelector;
	runReceiver = longAt(stackPointer - (argumentCount * (BYTES_PER_WORD)));
	/* begin pop: */
	stackPointer -= (argumentCount + 1) * (BYTES_PER_WORD);
	newReceiver = newMethod;
	messageSelector = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (SelectorRunWithIn << (SHIFT_FOR_WORD)));
	argumentCount = 3;
	/* begin push: */
	longAtput((sp = stackPointer + (BYTES_PER_WORD)), newReceiver);
	stackPointer = sp;
	/* begin push: */
	longAtput((sp1 = stackPointer + (BYTES_PER_WORD)), runSelector);
	stackPointer = sp1;
	/* begin push: */
	longAtput((sp2 = stackPointer + (BYTES_PER_WORD)), runArgs);
	stackPointer = sp2;
	/* begin push: */
	longAtput((sp3 = stackPointer + (BYTES_PER_WORD)), runReceiver);
	stackPointer = sp3;
	/* begin fetchClassOf: */
	if ((newReceiver & 1)) {
		lookupClass = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassInteger << (SHIFT_FOR_WORD)));
		goto l1;
	}
	ccIndex = (((usqInt) (longAt(newReceiver))) >> 12) & 31;
	if (ccIndex == 0) {
		lookupClass = (longAt(newReceiver - (BASE_HEADER_SIZE))) & (ALL_BUT_TYPE_MASK);
		goto l1;
	} else {
		/* begin fetchPointer:ofObject: */
		oop1 = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (CompactClasses << (SHIFT_FOR_WORD)));
		lookupClass = longAt((oop1 + (BASE_HEADER_SIZE)) + ((ccIndex - 1) << (SHIFT_FOR_WORD)));
		goto l1;
	}
l1:	/* end fetchClassOf: */;
	findNewMethodInClass(lookupClass);
	executeNewMethodFromCache();
	/* begin initPrimCall */
	primFailCode = 0;
}


/*	Primitive. Answer whether the argument to the primitive is a root for young space */

EXPORT(sqInt) primitiveIsRoot(void) {
    sqInt oop;
    sqInt oop1;
    sqInt trueOrFalse;
    sqInt sp;
    sqInt sp1;

	/* begin stackObjectValue: */
	oop1 = longAt(stackPointer - (0 * (BYTES_PER_WORD)));
	if ((oop1 & 1)) {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		oop = null;
		goto l1;
	}
	oop = oop1;
l1:	/* end stackObjectValue: */;
	if (!primFailCode) {
		/* begin pop: */
		stackPointer -= (argumentCount + 1) * (BYTES_PER_WORD);
		/* begin pushBool: */
		trueOrFalse = (longAt(oop)) & (ROOT_BIT);
		if (trueOrFalse) {
			/* begin push: */
			longAtput((sp = stackPointer + (BYTES_PER_WORD)), trueObj);
			stackPointer = sp;
		} else {
			/* begin push: */
			longAtput((sp1 = stackPointer + (BYTES_PER_WORD)), falseObj);
			stackPointer = sp1;
		}
	}
	return null;
}


/*	Primitive. Answer whether the argument to the primitive resides in young space. */

EXPORT(sqInt) primitiveIsYoung(void) {
    sqInt oop;
    sqInt oop1;
    sqInt sp;
    sqInt sp1;

	/* begin stackObjectValue: */
	oop1 = longAt(stackPointer - (0 * (BYTES_PER_WORD)));
	if ((oop1 & 1)) {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		oop = null;
		goto l1;
	}
	oop = oop1;
l1:	/* end stackObjectValue: */;
	if (!primFailCode) {
		/* begin pop: */
		stackPointer -= (argumentCount + 1) * (BYTES_PER_WORD);
		/* begin pushBool: */
		if ((((usqInt) oop)) >= (((usqInt) youngStart))) {
			/* begin push: */
			longAtput((sp = stackPointer + (BYTES_PER_WORD)), trueObj);
			stackPointer = sp;
		} else {
			/* begin push: */
			longAtput((sp1 = stackPointer + (BYTES_PER_WORD)), falseObj);
			stackPointer = sp1;
		}
	}
	return null;
}


/*	Obsolete on virtually all platforms; old style input polling code.
	Return the next keycode and remove it from the input buffer. The low byte is the 8-bit ISO character. The next four bits are the Smalltalk modifier bits <cmd><option><ctrl><shift>. */

sqInt primitiveKbdNext(void) {
    sqInt keystrokeWord;
    sqInt sp;
    sqInt sp1;

	/* begin pop: */
	stackPointer -= 1 * (BYTES_PER_WORD);
	keystrokeWord = ioGetKeystroke();
	if (keystrokeWord >= 0) {
		/* begin pushInteger: */
		/* begin push: */
		longAtput((sp1 = stackPointer + (BYTES_PER_WORD)), ((keystrokeWord << 1) | 1));
		stackPointer = sp1;
	} else {
		/* begin push: */
		longAtput((sp = stackPointer + (BYTES_PER_WORD)), nilObj);
		stackPointer = sp;
	}
	return null;
}


/*	Obsolete on virtually all platforms; old style input polling code.
	Return the next keycode and without removing it from the input buffer. The low byte is the 8-bit ISO character. The next four bits are the Smalltalk modifier bits <cmd><option><ctrl><shift>. */

sqInt primitiveKbdPeek(void) {
    sqInt keystrokeWord;
    sqInt sp;
    sqInt sp1;

	/* begin pop: */
	stackPointer -= 1 * (BYTES_PER_WORD);
	keystrokeWord = ioPeekKeystroke();
	if (keystrokeWord >= 0) {
		/* begin pushInteger: */
		/* begin push: */
		longAtput((sp1 = stackPointer + (BYTES_PER_WORD)), ((keystrokeWord << 1) | 1));
		stackPointer = sp1;
	} else {
		/* begin push: */
		longAtput((sp = stackPointer + (BYTES_PER_WORD)), nilObj);
		stackPointer = sp;
	}
	return null;
}

sqInt primitiveLessOrEqual(void) {
    sqInt integerArgument;
    sqInt integerReceiver;
    sqInt integerPointer;
    sqInt top;
    sqInt integerPointer1;
    sqInt top1;
    sqInt sp;
    sqInt sp1;

	/* begin popInteger */
	/* begin popStack */
	top = longAt(stackPointer);
	stackPointer -= BYTES_PER_WORD;
	integerPointer = top;
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		integerArgument = (integerPointer >> 1);
		goto l1;
	} else {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		integerArgument = 0;
		goto l1;
	}
	integerArgument = null;
l1:	/* end popInteger */;
	/* begin popInteger */
	/* begin popStack */
	top1 = longAt(stackPointer);
	stackPointer -= BYTES_PER_WORD;
	integerPointer1 = top1;
	/* begin checkedIntegerValueOf: */
	if ((integerPointer1 & 1)) {
		integerReceiver = (integerPointer1 >> 1);
		goto l2;
	} else {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		integerReceiver = 0;
		goto l2;
	}
	integerReceiver = null;
l2:	/* end popInteger */;
	/* begin checkBooleanResult: */
	if (!primFailCode) {
		/* begin pushBool: */
		if (integerReceiver <= integerArgument) {
			/* begin push: */
			longAtput((sp = stackPointer + (BYTES_PER_WORD)), trueObj);
			stackPointer = sp;
		} else {
			/* begin push: */
			longAtput((sp1 = stackPointer + (BYTES_PER_WORD)), falseObj);
			stackPointer = sp1;
		}
	} else {
		/* begin unPop: */
		stackPointer += 2 * (BYTES_PER_WORD);
	}
	return null;
}


/*	Primitive comparison operations for large integers in 64 bit range */

EXPORT(sqInt) primitiveLessOrEqualLargeIntegers(void) {
    sqLong integerArg;
    sqLong integerRcvr;
    sqInt sp;

	integerArg = signed64BitValueOf(longAt(stackPointer - (0 * (BYTES_PER_WORD))));
	integerRcvr = signed64BitValueOf(longAt(stackPointer - (1 * (BYTES_PER_WORD))));
	if (!primFailCode) {
		/* begin pop:thenPushBool: */
		longAtput((sp = stackPointer - ((2 - 1) * (BYTES_PER_WORD))), (integerRcvr <= integerArg
			? trueObj
			: falseObj));
		stackPointer = sp;
	}
	return null;
}

sqInt primitiveLessThan(void) {
    sqInt integerArgument;
    sqInt integerReceiver;
    sqInt integerPointer;
    sqInt top;
    sqInt integerPointer1;
    sqInt top1;
    sqInt sp;
    sqInt sp1;

	/* begin popInteger */
	/* begin popStack */
	top = longAt(stackPointer);
	stackPointer -= BYTES_PER_WORD;
	integerPointer = top;
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		integerArgument = (integerPointer >> 1);
		goto l1;
	} else {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		integerArgument = 0;
		goto l1;
	}
	integerArgument = null;
l1:	/* end popInteger */;
	/* begin popInteger */
	/* begin popStack */
	top1 = longAt(stackPointer);
	stackPointer -= BYTES_PER_WORD;
	integerPointer1 = top1;
	/* begin checkedIntegerValueOf: */
	if ((integerPointer1 & 1)) {
		integerReceiver = (integerPointer1 >> 1);
		goto l2;
	} else {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		integerReceiver = 0;
		goto l2;
	}
	integerReceiver = null;
l2:	/* end popInteger */;
	/* begin checkBooleanResult: */
	if (!primFailCode) {
		/* begin pushBool: */
		if (integerReceiver < integerArgument) {
			/* begin push: */
			longAtput((sp = stackPointer + (BYTES_PER_WORD)), trueObj);
			stackPointer = sp;
		} else {
			/* begin push: */
			longAtput((sp1 = stackPointer + (BYTES_PER_WORD)), falseObj);
			stackPointer = sp1;
		}
	} else {
		/* begin unPop: */
		stackPointer += 2 * (BYTES_PER_WORD);
	}
	return null;
}


/*	Primitive comparison operations for large integers in 64 bit range */

EXPORT(sqInt) primitiveLessThanLargeIntegers(void) {
    sqLong integerArg;
    sqLong integerRcvr;
    sqInt sp;

	integerArg = signed64BitValueOf(longAt(stackPointer - (0 * (BYTES_PER_WORD))));
	integerRcvr = signed64BitValueOf(longAt(stackPointer - (1 * (BYTES_PER_WORD))));
	if (!primFailCode) {
		/* begin pop:thenPushBool: */
		longAtput((sp = stackPointer - ((2 - 1) * (BYTES_PER_WORD))), (integerRcvr < integerArg
			? trueObj
			: falseObj));
		stackPointer = sp;
	}
	return null;
}


/*	Primitive. Return the n-th builtin module name. */

sqInt primitiveListBuiltinModule(void) {
    sqInt i;
    sqInt index;
    sqInt length;
    char *moduleName;
    sqInt nameOop;
    sqInt sp;
    sqInt sp1;
    sqInt integerPointer;

	if (!(argumentCount == 1)) {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		return null;
	}
	/* begin stackIntegerValue: */
	integerPointer = longAt(stackPointer - (0 * (BYTES_PER_WORD)));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		index = (integerPointer >> 1);
		goto l1;
	} else {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		index = 0;
		goto l1;
	}
	index = null;
l1:	/* end stackIntegerValue: */;
	if (index <= 0) {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		return null;
	}
	moduleName = ioListBuiltinModule(index);
	if (moduleName == null) {
		/* begin pop: */
		stackPointer -= 2 * (BYTES_PER_WORD);
		/* begin push: */
		longAtput((sp = stackPointer + (BYTES_PER_WORD)), nilObj);
		stackPointer = sp;
		return null;
	}
	length = strlen(moduleName);
	nameOop = instantiateClassindexableSize(longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassString << (SHIFT_FOR_WORD))), length);
	for (i = 0; i <= (length - 1); i += 1) {
		byteAtput((nameOop + (BASE_HEADER_SIZE)) + i, moduleName[i]);
	}
	/* begin forceInterruptCheck */
	interruptCheckCounter = -1000;
	nextPollTick = 0;
	/* begin pop:thenPush: */
	longAtput((sp1 = stackPointer - ((2 - 1) * (BYTES_PER_WORD))), nameOop);
	stackPointer = sp1;
	return null;
}


/*	Primitive. Return the n-th loaded external module name. */

sqInt primitiveListExternalModule(void) {
    sqInt i;
    sqInt index;
    sqInt length;
    char *moduleName;
    sqInt nameOop;
    sqInt sp;
    sqInt sp1;
    sqInt integerPointer;

	if (!(argumentCount == 1)) {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		return null;
	}
	/* begin stackIntegerValue: */
	integerPointer = longAt(stackPointer - (0 * (BYTES_PER_WORD)));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		index = (integerPointer >> 1);
		goto l1;
	} else {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		index = 0;
		goto l1;
	}
	index = null;
l1:	/* end stackIntegerValue: */;
	if (index <= 0) {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		return null;
	}
	moduleName = ioListLoadedModule(index);
	if (moduleName == null) {
		/* begin pop: */
		stackPointer -= 2 * (BYTES_PER_WORD);
		/* begin push: */
		longAtput((sp = stackPointer + (BYTES_PER_WORD)), nilObj);
		stackPointer = sp;
		return null;
	}
	length = strlen(moduleName);
	nameOop = instantiateClassindexableSize(longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassString << (SHIFT_FOR_WORD))), length);
	for (i = 0; i <= (length - 1); i += 1) {
		byteAtput((nameOop + (BASE_HEADER_SIZE)) + i, moduleName[i]);
	}
	/* begin forceInterruptCheck */
	interruptCheckCounter = -1000;
	nextPollTick = 0;
	/* begin pop:thenPush: */
	longAtput((sp1 = stackPointer - ((2 - 1) * (BYTES_PER_WORD))), nameOop);
	stackPointer = sp1;
	return null;
}


/*	This primitive is called from Squeak as...
		<imageSegment> loadSegmentFrom: aWordArray outPointers: anArray. */
/*	This primitive will load a binary image segment created by primitiveStoreImageSegment.  It expects the outPointer array to be of the proper size, and the wordArray to be well formed.  It will return as its value the original array of roots, and the erstwhile segmentWordArray will have been truncated to a size of zero.  If this primitive should fail, the segmentWordArray will, sadly, have been reduced to an unrecognizable and unusable jumble.  But what more could you have done with it anyway? */

sqInt primitiveLoadImageSegment(void) {
    sqInt data;
    sqInt doingClass;
    usqInt endSeg;
    sqInt extraSize;
    sqInt fieldOop;
    usqInt fieldPtr;
    sqInt hdrTypeBits;
    sqInt header;
    usqInt lastOut;
    usqInt lastPtr;
    sqInt mapOop;
    sqInt outPointerArray;
    usqInt outPtr;
    usqInt segOop;
    sqInt segmentWordArray;
    sqInt sp;
    sqInt addr;
    sqInt addr1;
    sqInt sz;
    sqInt header1;
    sqInt sz1;
    sqInt header2;

	if (DoAssertionChecks) {
		verifyCleanHeaders();
	}
	outPointerArray = longAt(stackPointer);
	lastOut = outPointerArray + (lastPointerOf(outPointerArray));
	segmentWordArray = longAt(stackPointer - (1 * (BYTES_PER_WORD)));

	/* Essential type checks */

	endSeg = (segmentWordArray + (sizeBitsOf(segmentWordArray))) - (BASE_HEADER_SIZE);
	if (!((((((usqInt) (longAt(outPointerArray))) >> 8) & 15) == 2) && (((((usqInt) (longAt(segmentWordArray))) >> 8) & 15) == 6))) {

		/* Must be indexable words */

		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		return null;
	}
	data = longAt(segmentWordArray + (BASE_HEADER_SIZE));
	if (!(readableFormat(data & 65535))) {

		/* low 2 bytes */
		/* Not readable -- try again with reversed bytes... */

		/* begin reverseBytesFrom:to: */
		flag("Dan");
		addr1 = segmentWordArray + (BASE_HEADER_SIZE);
		while ((((usqInt) addr1)) < (((usqInt) (endSeg + (BYTES_PER_WORD))))) {
			longAtput(addr1, byteSwapped(longAt(addr1)));
			addr1 += BYTES_PER_WORD;
		}
		data = longAt(segmentWordArray + (BASE_HEADER_SIZE));
		if (!(readableFormat(data & 65535))) {

			/* low 2 bytes */
			/* Still NG -- put things back and fail */

			/* begin reverseBytesFrom:to: */
			flag("Dan");
			addr = segmentWordArray + (BASE_HEADER_SIZE);
			while ((((usqInt) addr)) < (((usqInt) (endSeg + (BYTES_PER_WORD))))) {
				longAtput(addr, byteSwapped(longAt(addr)));
				addr += BYTES_PER_WORD;
			}
			if (DoAssertionChecks) {
				verifyCleanHeaders();
			}
			/* begin primitiveFail */
			if (primFailCode == 0) {
				primFailCode = 1;
			}
			return null;
		}
	}
	if (!((((usqInt) data) >> 16) == (((usqInt) (imageSegmentVersion())) >> 16))) {

		/* Reverse the byte-type objects once */


		/* Oop of first embedded object */

		segOop = ((segmentWordArray + (BASE_HEADER_SIZE)) + (BYTES_PER_WORD)) + (headerTypeBytes[(longAt((segmentWordArray + (BASE_HEADER_SIZE)) + (BYTES_PER_WORD))) & TypeMask]);
		byteSwapByteObjectsFromto(segOop, endSeg + (BYTES_PER_WORD));
	}
	segOop = ((segmentWordArray + (BASE_HEADER_SIZE)) + (BYTES_PER_WORD)) + (headerTypeBytes[(longAt((segmentWordArray + (BASE_HEADER_SIZE)) + (BYTES_PER_WORD))) & TypeMask]);
	while (segOop <= endSeg) {
		if (((longAt(segOop)) & TypeMask) <= 1) {

			/* This object has a class field (type = 0 or 1) -- start with that. */

			fieldPtr = segOop - (BYTES_PER_WORD);
			doingClass = 1;
		} else {

			/* No class field -- start with first data field */

			fieldPtr = segOop + (BASE_HEADER_SIZE);
			doingClass = 0;
		}

		/* last field */

		lastPtr = segOop + (lastPointerOf(segOop));
		if (lastPtr > endSeg) {
			if (DoAssertionChecks) {
				verifyCleanHeaders();
			}
			/* begin primitiveFail */
			if (primFailCode == 0) {
				primFailCode = 1;
			}
			return null;
		}
		while (!(fieldPtr > lastPtr)) {

			/* Examine each pointer field */

			fieldOop = longAt(fieldPtr);
			if (doingClass) {
				hdrTypeBits = (longAt(fieldPtr)) & TypeMask;
				fieldOop -= hdrTypeBits;
			}
			if ((fieldOop & 1)) {

				/* Integer -- nothing to do */

				fieldPtr += BYTES_PER_WORD;
			} else {
				if (!((fieldOop & 3) == 0)) {
					/* begin primitiveFail */
					if (primFailCode == 0) {
						primFailCode = 1;
					}
					return null;
				}
				if ((fieldOop & 2147483648U) == 0) {

					/* Internal pointer -- add segment offset */

					mapOop = fieldOop + segmentWordArray;
				} else {

					/* External pointer -- look it up in outPointers */

					outPtr = outPointerArray + (fieldOop & 2147483647U);
					if (outPtr > lastOut) {
						/* begin primitiveFail */
						if (primFailCode == 0) {
							primFailCode = 1;
						}
						return null;
					}
					mapOop = longAt(outPtr);
				}
				if (doingClass) {
					longAtput(fieldPtr, mapOop + hdrTypeBits);
					fieldPtr += 8;
					doingClass = 0;
				} else {
					longAtput(fieldPtr, mapOop);
					fieldPtr += BYTES_PER_WORD;
				}
				if (segOop < youngStart) {
					possibleRootStoreIntovalue(segOop, mapOop);
				}
			}
		}
		/* begin objectAfter: */
		if (DoAssertionChecks) {
			if ((((usqInt) segOop)) >= (((usqInt) endOfMemory))) {
				error("no objects after the end of memory");
			}
		}
		if (((longAt(segOop)) & TypeMask) == HeaderTypeFree) {
			sz = (longAt(segOop)) & (ALL_BUT_TYPE_MASK);
		} else {
			/* begin sizeBitsOf: */
			header1 = longAt(segOop);
			if ((header1 & TypeMask) == HeaderTypeSizeAndClass) {
				sz = (longAt(segOop - ((BYTES_PER_WORD) * 2))) & (LONG_SIZE_MASK);
				goto l1;
			} else {
				sz = header1 & (SIZE_MASK);
				goto l1;
			}
		l1:	/* end sizeBitsOf: */;
		}
		segOop = (segOop + sz) + (headerTypeBytes[(longAt(segOop + sz)) & TypeMask]);
	}
	segOop = ((segmentWordArray + (BASE_HEADER_SIZE)) + (BYTES_PER_WORD)) + (headerTypeBytes[(longAt((segmentWordArray + (BASE_HEADER_SIZE)) + (BYTES_PER_WORD))) & TypeMask]);
	while (segOop <= endSeg) {
		if (!(oopHasAcceptableClass(segOop))) {
			/* begin primitiveFail */
			if (primFailCode == 0) {
				primFailCode = 1;
			}
			return null;
		}

		/* first field */

		fieldPtr = segOop + (BASE_HEADER_SIZE);

		/* last field */
		/* Go through all oops, remapping them... */

		lastPtr = segOop + (lastPointerOf(segOop));
		while (!(fieldPtr > lastPtr)) {

			/* Examine each pointer field */

			fieldOop = longAt(fieldPtr);
			if (!(oopHasAcceptableClass(fieldOop))) {
				/* begin primitiveFail */
				if (primFailCode == 0) {
					primFailCode = 1;
				}
				return null;
			}
			fieldPtr += BYTES_PER_WORD;
		}
		/* begin objectAfter: */
		if (DoAssertionChecks) {
			if ((((usqInt) segOop)) >= (((usqInt) endOfMemory))) {
				error("no objects after the end of memory");
			}
		}
		if (((longAt(segOop)) & TypeMask) == HeaderTypeFree) {
			sz1 = (longAt(segOop)) & (ALL_BUT_TYPE_MASK);
		} else {
			/* begin sizeBitsOf: */
			header2 = longAt(segOop);
			if ((header2 & TypeMask) == HeaderTypeSizeAndClass) {
				sz1 = (longAt(segOop - ((BYTES_PER_WORD) * 2))) & (LONG_SIZE_MASK);
				goto l2;
			} else {
				sz1 = header2 & (SIZE_MASK);
				goto l2;
			}
		l2:	/* end sizeBitsOf: */;
		}
		segOop = (segOop + sz1) + (headerTypeBytes[(longAt(segOop + sz1)) & TypeMask]);
	}
	extraSize = headerTypeBytes[(longAt(segmentWordArray)) & TypeMask];
	hdrTypeBits = (longAt(segmentWordArray)) & TypeMask;
	if (extraSize == 8) {
		longAtput(segmentWordArray - extraSize, ((BASE_HEADER_SIZE) + (BYTES_PER_WORD)) + hdrTypeBits);
	} else {
		header = longAt(segmentWordArray);
		longAtput(segmentWordArray, ((header - (header & (SIZE_MASK))) + (BASE_HEADER_SIZE)) + (BYTES_PER_WORD));
	}
	if (DoAssertionChecks) {
		verifyCleanHeaders();
	}
	/* begin pop:thenPush: */
	longAtput((sp = stackPointer - ((3 - 1) * (BYTES_PER_WORD))), ((segmentWordArray + (BASE_HEADER_SIZE)) + (BYTES_PER_WORD)) + (headerTypeBytes[(longAt((segmentWordArray + (BASE_HEADER_SIZE)) + (BYTES_PER_WORD))) & TypeMask]));
	stackPointer = sp;
	return null;
}

void primitiveLoadInstVar(void) {
    sqInt thisReceiver;
    sqInt top;
    sqInt object;
    sqInt sp;

	/* begin popStack */
	top = longAt(stackPointer);
	stackPointer -= BYTES_PER_WORD;
	thisReceiver = top;
	/* begin push: */
	object = longAt((thisReceiver + (BASE_HEADER_SIZE)) + ((primitiveIndex - 264) << (SHIFT_FOR_WORD)));
	longAtput((sp = stackPointer + (BYTES_PER_WORD)), object);
	stackPointer = sp;
}


/*	Answer the local microseconds since the Smalltalk epoch. The value is
	derived from the Posix epoch (see primitiveUTCMicrosecondClock) with a
	constant offset corresponding to elapsed microseconds between the two
	epochs according to RFC 868, and with an offset duration corresponding to
	the current offset of local time from UTC. */

EXPORT(sqInt) primitiveLocalMicrosecondClock(void) {
    sqLong clock;
    static usqLong epochDelta= 2177452800000000ULL;
    int offset;
    usqLong offsetMillis;
    sqInt uSecs;
    sqInt sp;

	if ((ioUtcWithOffset(&clock, &offset)) == -1) {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		return null;
	}

	/* adjust for nominal Smalltalk epoch */

	clock += epochDelta;
	offsetMillis = offset;
	offsetMillis = offsetMillis * 1000000;

	/* adjust for local time offset */

	clock += offsetMillis;
	uSecs = positive64BitIntegerFor(clock);
	/* begin pop:thenPush: */
	longAtput((sp = stackPointer - ((1 - 1) * (BYTES_PER_WORD))), uSecs);
	stackPointer = sp;
	return null;
}


/*	Natural log. */

sqInt primitiveLogN(void) {
    double rcvr;

	rcvr = popFloat();
	if (!primFailCode) {
		pushFloat(log(rcvr));
	} else {
		/* begin unPop: */
		stackPointer += 1 * (BYTES_PER_WORD);
	}
	return null;
}


/*	Register the low-space semaphore. If the argument is not a 
	Semaphore, unregister the current low-space Semaphore. */

sqInt primitiveLowSpaceSemaphore(void) {
    sqInt arg;
    sqInt top;

	/* begin popStack */
	top = longAt(stackPointer);
	stackPointer -= BYTES_PER_WORD;
	arg = top;
	if ((fetchClassOf(arg)) == (longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassSemaphore << (SHIFT_FOR_WORD))))) {
		/* begin storePointer:ofObject:withValue: */
		if ((((usqInt) specialObjectsOop)) < (((usqInt) youngStart))) {
			possibleRootStoreIntovalue(specialObjectsOop, arg);
		}
		longAtput((specialObjectsOop + (BASE_HEADER_SIZE)) + (TheLowSpaceSemaphore << (SHIFT_FOR_WORD)), arg);
	} else {
		/* begin storePointer:ofObject:withValue: */
		if ((((usqInt) specialObjectsOop)) < (((usqInt) youngStart))) {
			possibleRootStoreIntovalue(specialObjectsOop, nilObj);
		}
		longAtput((specialObjectsOop + (BASE_HEADER_SIZE)) + (TheLowSpaceSemaphore << (SHIFT_FOR_WORD)), nilObj);
	}
	return null;
}

sqInt primitiveMakePoint(void) {
    sqInt argument;
    sqInt pt;
    sqInt rcvr;
    sqInt pointResult;
    sqInt pointResult1;
    sqInt pointResult2;
    sqInt sp;

	argument = longAt(stackPointer);
	rcvr = longAt(stackPointer - (1 * (BYTES_PER_WORD)));
	if ((rcvr & 1)) {
		if ((argument & 1)) {
			/* begin makePointwithxValue:yValue: */
			pointResult = instantiateSmallClasssizeInBytes(longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassPoint << (SHIFT_FOR_WORD))), 3 * (BYTES_PER_WORD));
			longAtput((pointResult + (BASE_HEADER_SIZE)) + (XIndex << (SHIFT_FOR_WORD)), ((((rcvr >> 1)) << 1) | 1));
			longAtput((pointResult + (BASE_HEADER_SIZE)) + (YIndex << (SHIFT_FOR_WORD)), ((((argument >> 1)) << 1) | 1));
			pt = pointResult;
		} else {
			/* begin makePointwithxValue:yValue: */
			pointResult1 = instantiateSmallClasssizeInBytes(longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassPoint << (SHIFT_FOR_WORD))), 3 * (BYTES_PER_WORD));
			longAtput((pointResult1 + (BASE_HEADER_SIZE)) + (XIndex << (SHIFT_FOR_WORD)), ((((rcvr >> 1)) << 1) | 1));
			longAtput((pointResult1 + (BASE_HEADER_SIZE)) + (YIndex << (SHIFT_FOR_WORD)), ((0 << 1) | 1));
			pt = pointResult1;
			/* begin storePointer:ofObject:withValue: */
			if ((((usqInt) pt)) < (((usqInt) youngStart))) {
				possibleRootStoreIntovalue(pt, longAt(stackPointer - (0 * (BYTES_PER_WORD))));
			}
			longAtput((pt + (BASE_HEADER_SIZE)) + (1 << (SHIFT_FOR_WORD)), longAt(stackPointer - (0 * (BYTES_PER_WORD))));
		}
	} else {
		if (!((fetchClassOf(rcvr)) == (longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassFloat << (SHIFT_FOR_WORD)))))) {
			/* begin success: */
			if (!(0)) {
				if (!primFailCode) {
					primFailCode = 1;
				}
			}
			return null;
		}
		/* begin makePointwithxValue:yValue: */
		pointResult2 = instantiateSmallClasssizeInBytes(longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassPoint << (SHIFT_FOR_WORD))), 3 * (BYTES_PER_WORD));
		longAtput((pointResult2 + (BASE_HEADER_SIZE)) + (XIndex << (SHIFT_FOR_WORD)), ((0 << 1) | 1));
		longAtput((pointResult2 + (BASE_HEADER_SIZE)) + (YIndex << (SHIFT_FOR_WORD)), ((0 << 1) | 1));
		pt = pointResult2;
		/* begin storePointer:ofObject:withValue: */
		if ((((usqInt) pt)) < (((usqInt) youngStart))) {
			possibleRootStoreIntovalue(pt, longAt(stackPointer - (1 * (BYTES_PER_WORD))));
		}
		longAtput((pt + (BASE_HEADER_SIZE)) + (0 << (SHIFT_FOR_WORD)), longAt(stackPointer - (1 * (BYTES_PER_WORD))));
		/* begin storePointer:ofObject:withValue: */
		if ((((usqInt) pt)) < (((usqInt) youngStart))) {
			possibleRootStoreIntovalue(pt, longAt(stackPointer - (0 * (BYTES_PER_WORD))));
		}
		longAtput((pt + (BASE_HEADER_SIZE)) + (1 << (SHIFT_FOR_WORD)), longAt(stackPointer - (0 * (BYTES_PER_WORD))));
	}
	/* begin pop:thenPush: */
	longAtput((sp = stackPointer - ((2 - 1) * (BYTES_PER_WORD))), pt);
	stackPointer = sp;
	return null;
}


/*	Primitive. Mark the method for exception handling. The primitive must fail after marking the context so that the regular code is run. */

sqInt primitiveMarkHandlerMethod(void) {
	/* begin primitiveFail */
	if (primFailCode == 0) {
		primFailCode = 1;
	}
	return null;
}


/*	Primitive. Mark the method for exception unwinding. The primitive must fail after marking the context so that the regular code is run.  It must also *not* allow a context switch. */

sqInt primitiveMarkUnwindMethod(void) {
	/* begin primitiveFail */
	if (primFailCode == 0) {
		primFailCode = 1;
	}
	return null;
}

sqInt primitiveMaxIdentityHash(void) {
    sqInt sp;

	/* begin pop:thenPushInteger: */
	longAtput((sp = stackPointer - ((1 - 1) * (BYTES_PER_WORD))), ((HashMaskUnshifted << 1) | 1));
	stackPointer = sp;
	return null;
}


/*	Return the method an external primitive was defined in */

sqInt primitiveMethod(void) {
	return newMethod;
}


/*	This is a named (not numbered) primitive in the null module (ie the VM) */

EXPORT(sqInt) primitiveMicrosecondClock(void) {
    sqInt oop;
    sqInt sp;

	/* begin pop:thenPush: */
	oop = positive64BitIntegerFor(ioMicroSecondClock());
	longAtput((sp = stackPointer - ((1 - 1) * (BYTES_PER_WORD))), oop);
	stackPointer = sp;
	return null;
}


/*	Return the value of the millisecond clock as an integer. Note that the millisecond clock wraps around periodically. On some platforms it can wrap daily. The range is limited to SmallInteger maxVal / 2 to allow delays of up to that length without overflowing a SmallInteger. */

sqInt primitiveMillisecondClock(void) {
    sqInt oop;
    sqInt sp;

	/* begin pop:thenPush: */
	oop = ((((ioMSecs()) & MillisecondClockMask) << 1) | 1);
	longAtput((sp = stackPointer - ((1 - 1) * (BYTES_PER_WORD))), oop);
	stackPointer = sp;
	return null;
}


/*	Provide access to the millisecond clock mask to support calculation
	of durations based on the millisecond clock value. */

EXPORT(sqInt) primitiveMillisecondClockMask(void) {
    sqInt sp;

	/* begin pop:thenPush: */
	longAtput((sp = stackPointer - ((1 - 1) * (BYTES_PER_WORD))), ((MillisecondClockMask << 1) | 1));
	stackPointer = sp;
	return null;
}

sqInt primitiveMod(void) {
    sqInt mod;
    sqInt sp;

	mod = doPrimitiveModby(longAt(stackPointer - (1 * (BYTES_PER_WORD))), longAt(stackPointer));
	/* begin pop2AndPushIntegerIfOK: */
	if (!primFailCode) {
		if (
# ifdef SQ_HOST32  // cast to int for 64 bit image on 32 bit host
			(((((int) mod)) ^ ((((int) mod)) << 1)) >= 0)
# else
			((mod >= -1073741824) && (mod <= 1073741823))
# endif  // SQ_HOST32
		) {
			/* begin pop:thenPush: */
			longAtput((sp = stackPointer - ((2 - 1) * (BYTES_PER_WORD))), ((mod << 1) | 1));
			stackPointer = sp;
		} else {
			/* begin primitiveFail */
			if (primFailCode == 0) {
				primFailCode = 1;
			}
		}
	}
	return null;
}


/*	Primitive arithmetic operations for large integers in 64 bit range */

EXPORT(sqInt) primitiveModLargeIntegers(void) {
    usqLong a;
    sqInt aIsNegative;
    usqLong b;
    sqInt bIsNegative;
    sqInt oopArg;
    sqInt oopRcvr;
    sqInt oopResult;
    usqLong result;
    sqInt sp;

	oopArg = longAt(stackPointer - (0 * (BYTES_PER_WORD)));
	oopRcvr = longAt(stackPointer - (1 * (BYTES_PER_WORD)));
	aIsNegative = isNegativeIntegerValueOf(oopRcvr);
	bIsNegative = isNegativeIntegerValueOf(oopArg);
	a = magnitude64BitValueOf(oopRcvr);
	b = magnitude64BitValueOf(oopArg);
	if (b == 0) {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
	}
	if (!(!primFailCode)) {
		return null;
	}

	/* Handle remainder of same sign as argument */

	result = a % b;
	if (!(result == 0)) {
		if (!(bIsNegative == aIsNegative)) {
			result = b - result;
		}
	}
	oopResult = magnitude64BitIntegerForneg(result, bIsNegative);
	if (!primFailCode) {
		/* begin pop:thenPush: */
		longAtput((sp = stackPointer - ((2 - 1) * (BYTES_PER_WORD))), oopResult);
		stackPointer = sp;
	}
	return null;
}


/*	Obsolete on virtually all platforms; old style input polling code.
	Return the mouse button state. The low three bits encode the state of the <red><yellow><blue> mouse buttons. The next four bits encode the Smalltalk modifier bits <cmd><option><ctrl><shift>. */

sqInt primitiveMouseButtons(void) {
    sqInt buttonWord;
    sqInt sp;

	/* begin pop: */
	stackPointer -= 1 * (BYTES_PER_WORD);
	buttonWord = ioGetButtonState();
	/* begin pushInteger: */
	/* begin push: */
	longAtput((sp = stackPointer + (BYTES_PER_WORD)), ((buttonWord << 1) | 1));
	stackPointer = sp;
	return null;
}


/*	Obsolete on virtually all platforms; old style input polling code.
	Return a Point indicating current position of the mouse. Note that mouse coordinates may be negative if the mouse moves above or to the left of the top-left corner of the Smalltalk window. */

sqInt primitiveMousePoint(void) {
    sqInt pointWord;
    sqInt x;
    sqInt y;
    sqInt object;
    sqInt sp;
    sqInt pointResult;

	/* begin pop: */
	stackPointer -= 1 * (BYTES_PER_WORD);
	pointWord = ioMousePoint();
	/* begin signExtend16: */
	if ((((((usqInt) pointWord) >> 16) & 65535) & 32768) == 0) {
		x = (((usqInt) pointWord) >> 16) & 65535;
		goto l1;
	} else {
		x = ((((usqInt) pointWord) >> 16) & 65535) - 65536;
		goto l1;
	}
l1:	/* end signExtend16: */;
	/* begin signExtend16: */
	if (((pointWord & 65535) & 32768) == 0) {
		y = pointWord & 65535;
		goto l2;
	} else {
		y = (pointWord & 65535) - 65536;
		goto l2;
	}
l2:	/* end signExtend16: */;
	/* begin push: */
	/* begin makePointwithxValue:yValue: */
	pointResult = instantiateSmallClasssizeInBytes(longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassPoint << (SHIFT_FOR_WORD))), 3 * (BYTES_PER_WORD));
	longAtput((pointResult + (BASE_HEADER_SIZE)) + (XIndex << (SHIFT_FOR_WORD)), ((x << 1) | 1));
	longAtput((pointResult + (BASE_HEADER_SIZE)) + (YIndex << (SHIFT_FOR_WORD)), ((y << 1) | 1));
	object = pointResult;
	longAtput((sp = stackPointer + (BYTES_PER_WORD)), object);
	stackPointer = sp;
	return null;
}

sqInt primitiveMultiply(void) {
    sqInt integerArg;
    sqInt integerRcvr;
    sqInt integerResult;
    sqInt sp;
    sqInt integerPointer;
    sqInt integerPointer1;

	/* begin stackIntegerValue: */
	integerPointer = longAt(stackPointer - (1 * (BYTES_PER_WORD)));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		integerRcvr = (integerPointer >> 1);
		goto l1;
	} else {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		integerRcvr = 0;
		goto l1;
	}
	integerRcvr = null;
l1:	/* end stackIntegerValue: */;
	/* begin stackIntegerValue: */
	integerPointer1 = longAt(stackPointer - (0 * (BYTES_PER_WORD)));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer1 & 1)) {
		integerArg = (integerPointer1 >> 1);
		goto l2;
	} else {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		integerArg = 0;
		goto l2;
	}
	integerArg = null;
l2:	/* end stackIntegerValue: */;
	if (!primFailCode) {

		/* check for C overflow by seeing if computation is reversible */

		integerResult = integerRcvr * integerArg;
		if ((integerArg == 0) || ((integerResult / integerArg) == integerRcvr)) {
			/* begin pop2AndPushIntegerIfOK: */
			if (!primFailCode) {
				if (
# ifdef SQ_HOST32  // cast to int for 64 bit image on 32 bit host
					(((((int) integerResult)) ^ ((((int) integerResult)) << 1)) >= 0)
# else
					((integerResult >= -1073741824) && (integerResult <= 1073741823))
# endif  // SQ_HOST32
				) {
					/* begin pop:thenPush: */
					longAtput((sp = stackPointer - ((2 - 1) * (BYTES_PER_WORD))), ((integerResult << 1) | 1));
					stackPointer = sp;
				} else {
					/* begin primitiveFail */
					if (primFailCode == 0) {
						primFailCode = 1;
					}
				}
			}
		} else {
			/* begin primitiveFail */
			if (primFailCode == 0) {
				primFailCode = 1;
			}
		}
	}
	return null;
}


/*	Primitive arithmetic operations for large integers in 64 bit range */

EXPORT(sqInt) primitiveMultiplyLargeIntegers(void) {
    usqLong a;
    sqInt aIsNegative;
    usqLong b;
    sqInt bIsNegative;
    sqInt oopArg;
    sqInt oopRcvr;
    sqInt oopResult;
    usqLong result;
    sqInt sp;

	oopArg = longAt(stackPointer - (0 * (BYTES_PER_WORD)));
	oopRcvr = longAt(stackPointer - (1 * (BYTES_PER_WORD)));
	aIsNegative = isNegativeIntegerValueOf(oopRcvr);
	bIsNegative = isNegativeIntegerValueOf(oopArg);
	a = magnitude64BitValueOf(oopRcvr);
	b = magnitude64BitValueOf(oopArg);
	if (!(!primFailCode)) {
		return null;
	}
	if ((a > 1) && ((b > 1) && (a > (18446744073709551615U / b)))) {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		return null;
	}
	result = a * b;
	oopResult = magnitude64BitIntegerForneg(result, aIsNegative != bIsNegative);
	if (!primFailCode) {
		/* begin pop:thenPush: */
		longAtput((sp = stackPointer - ((2 - 1) * (BYTES_PER_WORD))), oopResult);
		stackPointer = sp;
	}
	return null;
}


/*	Allocate a new fixed-size instance. Fail if the allocation would leave less than lowSpaceThreshold bytes free. May cause a GC */

sqInt primitiveNew(void) {
    sqInt class;
    sqInt spaceOkay;
    sqInt object;
    sqInt sp;
    sqInt format;
    usqInt minFree;
    usqInt minFree1;


	/* The following may cause GC! */

	class = longAt(stackPointer);
	/* begin sufficientSpaceToInstantiate:indexableSize: */
	format = (((usqInt) ((longAt((class + (BASE_HEADER_SIZE)) + (InstanceSpecificationIndex << (SHIFT_FOR_WORD)))) - 1)) >> 8) & 15;
	if ((0 > 0) && (format < 2)) {
		spaceOkay = 0;
		goto l1;
	}
	if (format < 8) {
		if (isExcessiveAllocationRequestshift(0, SHIFT_FOR_WORD)) {
			spaceOkay = 0;
			goto l1;
		}
		/* begin sufficientSpaceToAllocate: */
		minFree = (lowSpaceThreshold + (2500 + (0 * (BYTES_PER_WORD)))) + (BASE_HEADER_SIZE);
		if (oopisGreaterThanOrEqualTo((longAt(freeBlock)) & (ALL_BUT_TYPE_MASK), minFree)) {
			spaceOkay = 1;
			goto l1;
		} else {
			spaceOkay = sufficientSpaceAfterGC(minFree);
			goto l1;
		}
		spaceOkay = null;
		goto l1;
	} else {
		if (isExcessiveAllocationRequestshift(0, 0)) {
			spaceOkay = 0;
			goto l1;
		}
		/* begin sufficientSpaceToAllocate: */
		minFree1 = (lowSpaceThreshold + (2500 + 0)) + (BASE_HEADER_SIZE);
		if (oopisGreaterThanOrEqualTo((longAt(freeBlock)) & (ALL_BUT_TYPE_MASK), minFree1)) {
			spaceOkay = 1;
			goto l1;
		} else {
			spaceOkay = sufficientSpaceAfterGC(minFree1);
			goto l1;
		}
		spaceOkay = null;
		goto l1;
	}
l1:	/* end sufficientSpaceToInstantiate:indexableSize: */;
	/* begin success: */
	if (!(spaceOkay)) {
		if (!primFailCode) {
			primFailCode = 1;
		}
	}
	if (!primFailCode) {
		/* begin push: */
		object = instantiateClassindexableSize(popStack(), 0);
		longAtput((sp = stackPointer + (BYTES_PER_WORD)), object);
		stackPointer = sp;
	}
	return null;
}

sqInt primitiveNewMethod(void) {
    sqInt bytecodeCount;
    sqInt class;
    sqInt header;
    sqInt i;
    sqInt literalCount;
    sqInt size;
    sqInt theMethod;
    sqInt top;
    sqInt integerPointer;
    sqInt top1;
    sqInt top2;
    sqInt sp;

	/* begin popStack */
	top = longAt(stackPointer);
	stackPointer -= BYTES_PER_WORD;
	header = top;
	/* begin popInteger */
	/* begin popStack */
	top1 = longAt(stackPointer);
	stackPointer -= BYTES_PER_WORD;
	integerPointer = top1;
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		bytecodeCount = (integerPointer >> 1);
		goto l1;
	} else {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		bytecodeCount = 0;
		goto l1;
	}
	bytecodeCount = null;
l1:	/* end popInteger */;
	/* begin success: */
	if (!((header & 1))) {
		if (!primFailCode) {
			primFailCode = 1;
		}
	}
	if (!(!primFailCode)) {
		/* begin unPop: */
		stackPointer += 2 * (BYTES_PER_WORD);
		return null;
	}
	/* begin popStack */
	top2 = longAt(stackPointer);
	stackPointer -= BYTES_PER_WORD;
	class = top2;
	size = ((((((usqInt) header) >> 10) & 255) + 1) * (BYTES_PER_WORD)) + bytecodeCount;
	theMethod = instantiateClassindexableSize(class, size);
	longAtput((theMethod + (BASE_HEADER_SIZE)) + (HeaderIndex << (SHIFT_FOR_WORD)), header);
	literalCount = (((usqInt) header) >> 10) & 255;
	for (i = 1; i <= literalCount; i += 1) {
		/* begin storePointer:ofObject:withValue: */
		if ((((usqInt) theMethod)) < (((usqInt) youngStart))) {
			possibleRootStoreIntovalue(theMethod, nilObj);
		}
		longAtput((theMethod + (BASE_HEADER_SIZE)) + (i << (SHIFT_FOR_WORD)), nilObj);
	}
	/* begin push: */
	longAtput((sp = stackPointer + (BYTES_PER_WORD)), theMethod);
	stackPointer = sp;
	return null;
}


/*	Allocate a new indexable instance. Fail if the allocation would leave less than lowSpaceThreshold bytes free. */

sqInt primitiveNewWithArg(void) {
    sqInt class;
    usqInt size;
    sqInt spaceOkay;
    sqInt oop;
    sqInt sp;
    sqInt format;
    usqInt minFree;
    usqInt minFree1;

	
# if (SQ_IMAGE64 && SQ_HOST64)  // permit large object allocation on 64 bit image and host
	size = positive64BitValueOf(longAt(stackPointer));
# else
	size = positive32BitValueOf(longAt(stackPointer));
# endif  // SQ_IMAGE64 && SQ_HOST64
	
	class = longAt(stackPointer - (1 * (BYTES_PER_WORD)));
	/* begin success: */
	if (!(size >= 0)) {
		if (!primFailCode) {
			primFailCode = 1;
		}
	}
	if (!primFailCode) {

		/* The following may cause GC! */

		/* begin sufficientSpaceToInstantiate:indexableSize: */
		format = (((usqInt) ((longAt((class + (BASE_HEADER_SIZE)) + (InstanceSpecificationIndex << (SHIFT_FOR_WORD)))) - 1)) >> 8) & 15;
		if ((size > 0) && (format < 2)) {
			spaceOkay = 0;
			goto l1;
		}
		if (format < 8) {
			if (isExcessiveAllocationRequestshift(size, SHIFT_FOR_WORD)) {
				spaceOkay = 0;
				goto l1;
			}
			/* begin sufficientSpaceToAllocate: */
			minFree = (lowSpaceThreshold + (2500 + (size * (BYTES_PER_WORD)))) + (BASE_HEADER_SIZE);
			if (oopisGreaterThanOrEqualTo((longAt(freeBlock)) & (ALL_BUT_TYPE_MASK), minFree)) {
				spaceOkay = 1;
				goto l1;
			} else {
				spaceOkay = sufficientSpaceAfterGC(minFree);
				goto l1;
			}
			spaceOkay = null;
			goto l1;
		} else {
			if (isExcessiveAllocationRequestshift(size, 0)) {
				spaceOkay = 0;
				goto l1;
			}
			/* begin sufficientSpaceToAllocate: */
			minFree1 = (lowSpaceThreshold + (2500 + size)) + (BASE_HEADER_SIZE);
			if (oopisGreaterThanOrEqualTo((longAt(freeBlock)) & (ALL_BUT_TYPE_MASK), minFree1)) {
				spaceOkay = 1;
				goto l1;
			} else {
				spaceOkay = sufficientSpaceAfterGC(minFree1);
				goto l1;
			}
			spaceOkay = null;
			goto l1;
		}
	l1:	/* end sufficientSpaceToInstantiate:indexableSize: */;
		/* begin success: */
		if (!(spaceOkay)) {
			if (!primFailCode) {
				primFailCode = 1;
			}
		}
		class = longAt(stackPointer - (1 * (BYTES_PER_WORD)));
	}
	if (!primFailCode) {
		/* begin pop:thenPush: */
		oop = instantiateClassindexableSize(class, size);
		longAtput((sp = stackPointer - ((2 - 1) * (BYTES_PER_WORD))), oop);
		stackPointer = sp;
	}
	return null;
}

sqInt primitiveNextInstance(void) {
    sqInt instance;
    sqInt object;
    sqInt sp;
    sqInt classPointer;
    sqInt thisClass;
    sqInt thisObj;
    sqInt obj;
    sqInt obj1;
    sqInt sz;
    sqInt header;
    sqInt sz1;
    sqInt header1;
    sqInt ccIndex;
    sqInt oop1;
    sqInt sz2;
    sqInt header2;
    sqInt ccIndex1;
    sqInt oop11;
    sqInt sz3;
    sqInt header3;

	object = longAt(stackPointer);
	/* begin instanceAfter: */
	/* begin fetchClassOf: */
	if ((object & 1)) {
		classPointer = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassInteger << (SHIFT_FOR_WORD)));
		goto l8;
	}
	ccIndex1 = (((usqInt) (longAt(object))) >> 12) & 31;
	if (ccIndex1 == 0) {
		classPointer = (longAt(object - (BASE_HEADER_SIZE))) & (ALL_BUT_TYPE_MASK);
		goto l8;
	} else {
		/* begin fetchPointer:ofObject: */
		oop11 = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (CompactClasses << (SHIFT_FOR_WORD)));
		classPointer = longAt((oop11 + (BASE_HEADER_SIZE)) + ((ccIndex1 - 1) << (SHIFT_FOR_WORD)));
		goto l8;
	}
l8:	/* end fetchClassOf: */;
	/* begin accessibleObjectAfter: */
	/* begin objectAfter: */
	if (DoAssertionChecks) {
		if ((((usqInt) object)) >= (((usqInt) endOfMemory))) {
			error("no objects after the end of memory");
		}
	}
	if (((longAt(object)) & TypeMask) == HeaderTypeFree) {
		sz3 = (longAt(object)) & (ALL_BUT_TYPE_MASK);
	} else {
		/* begin sizeBitsOf: */
		header3 = longAt(object);
		if ((header3 & TypeMask) == HeaderTypeSizeAndClass) {
			sz3 = (longAt(object - ((BYTES_PER_WORD) * 2))) & (LONG_SIZE_MASK);
			goto l9;
		} else {
			sz3 = header3 & (SIZE_MASK);
			goto l9;
		}
	l9:	/* end sizeBitsOf: */;
	}
	obj1 = (object + sz3) + (headerTypeBytes[(longAt(object + sz3)) & TypeMask]);
	while ((((usqInt) obj1)) < (((usqInt) endOfMemory))) {
		if (!(((longAt(obj1)) & TypeMask) == HeaderTypeFree)) {
			thisObj = obj1;
			goto l3;
		}
		/* begin objectAfter: */
		if (DoAssertionChecks) {
			if ((((usqInt) obj1)) >= (((usqInt) endOfMemory))) {
				error("no objects after the end of memory");
			}
		}
		if (((longAt(obj1)) & TypeMask) == HeaderTypeFree) {
			sz = (longAt(obj1)) & (ALL_BUT_TYPE_MASK);
		} else {
			/* begin sizeBitsOf: */
			header = longAt(obj1);
			if ((header & TypeMask) == HeaderTypeSizeAndClass) {
				sz = (longAt(obj1 - ((BYTES_PER_WORD) * 2))) & (LONG_SIZE_MASK);
				goto l4;
			} else {
				sz = header & (SIZE_MASK);
				goto l4;
			}
		l4:	/* end sizeBitsOf: */;
		}
		obj1 = (obj1 + sz) + (headerTypeBytes[(longAt(obj1 + sz)) & TypeMask]);
	}
	thisObj = null;
l3:	/* end accessibleObjectAfter: */;
	while (!(thisObj == null)) {
		/* begin fetchClassOf: */
		if ((thisObj & 1)) {
			thisClass = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassInteger << (SHIFT_FOR_WORD)));
			goto l6;
		}
		ccIndex = (((usqInt) (longAt(thisObj))) >> 12) & 31;
		if (ccIndex == 0) {
			thisClass = (longAt(thisObj - (BASE_HEADER_SIZE))) & (ALL_BUT_TYPE_MASK);
			goto l6;
		} else {
			/* begin fetchPointer:ofObject: */
			oop1 = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (CompactClasses << (SHIFT_FOR_WORD)));
			thisClass = longAt((oop1 + (BASE_HEADER_SIZE)) + ((ccIndex - 1) << (SHIFT_FOR_WORD)));
			goto l6;
		}
	l6:	/* end fetchClassOf: */;
		if (thisClass == classPointer) {
			instance = thisObj;
			goto l1;
		}
		/* begin accessibleObjectAfter: */
		/* begin objectAfter: */
		if (DoAssertionChecks) {
			if ((((usqInt) thisObj)) >= (((usqInt) endOfMemory))) {
				error("no objects after the end of memory");
			}
		}
		if (((longAt(thisObj)) & TypeMask) == HeaderTypeFree) {
			sz2 = (longAt(thisObj)) & (ALL_BUT_TYPE_MASK);
		} else {
			/* begin sizeBitsOf: */
			header2 = longAt(thisObj);
			if ((header2 & TypeMask) == HeaderTypeSizeAndClass) {
				sz2 = (longAt(thisObj - ((BYTES_PER_WORD) * 2))) & (LONG_SIZE_MASK);
				goto l7;
			} else {
				sz2 = header2 & (SIZE_MASK);
				goto l7;
			}
		l7:	/* end sizeBitsOf: */;
		}
		obj = (thisObj + sz2) + (headerTypeBytes[(longAt(thisObj + sz2)) & TypeMask]);
		while ((((usqInt) obj)) < (((usqInt) endOfMemory))) {
			if (!(((longAt(obj)) & TypeMask) == HeaderTypeFree)) {
				thisObj = obj;
				goto l2;
			}
			/* begin objectAfter: */
			if (DoAssertionChecks) {
				if ((((usqInt) obj)) >= (((usqInt) endOfMemory))) {
					error("no objects after the end of memory");
				}
			}
			if (((longAt(obj)) & TypeMask) == HeaderTypeFree) {
				sz1 = (longAt(obj)) & (ALL_BUT_TYPE_MASK);
			} else {
				/* begin sizeBitsOf: */
				header1 = longAt(obj);
				if ((header1 & TypeMask) == HeaderTypeSizeAndClass) {
					sz1 = (longAt(obj - ((BYTES_PER_WORD) * 2))) & (LONG_SIZE_MASK);
					goto l5;
				} else {
					sz1 = header1 & (SIZE_MASK);
					goto l5;
				}
			l5:	/* end sizeBitsOf: */;
			}
			obj = (obj + sz1) + (headerTypeBytes[(longAt(obj + sz1)) & TypeMask]);
		}
		thisObj = null;
	l2:	/* end accessibleObjectAfter: */;
	}
	instance = nilObj;
l1:	/* end instanceAfter: */;
	if (instance == nilObj) {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
	} else {
		/* begin pop:thenPush: */
		longAtput((sp = stackPointer - (((argumentCount + 1) - 1) * (BYTES_PER_WORD))), instance);
		stackPointer = sp;
	}
	return null;
}


/*	Return the object following the receiver in the heap. Return the SmallInteger zero when there are no more objects. */

sqInt primitiveNextObject(void) {
    sqInt instance;
    sqInt object;
    sqInt sp;
    sqInt sp1;
    sqInt obj;
    sqInt sz;
    sqInt header;
    sqInt sz1;
    sqInt header1;

	object = longAt(stackPointer);
	/* begin accessibleObjectAfter: */
	/* begin objectAfter: */
	if (DoAssertionChecks) {
		if ((((usqInt) object)) >= (((usqInt) endOfMemory))) {
			error("no objects after the end of memory");
		}
	}
	if (((longAt(object)) & TypeMask) == HeaderTypeFree) {
		sz1 = (longAt(object)) & (ALL_BUT_TYPE_MASK);
	} else {
		/* begin sizeBitsOf: */
		header1 = longAt(object);
		if ((header1 & TypeMask) == HeaderTypeSizeAndClass) {
			sz1 = (longAt(object - ((BYTES_PER_WORD) * 2))) & (LONG_SIZE_MASK);
			goto l3;
		} else {
			sz1 = header1 & (SIZE_MASK);
			goto l3;
		}
	l3:	/* end sizeBitsOf: */;
	}
	obj = (object + sz1) + (headerTypeBytes[(longAt(object + sz1)) & TypeMask]);
	while ((((usqInt) obj)) < (((usqInt) endOfMemory))) {
		if (!(((longAt(obj)) & TypeMask) == HeaderTypeFree)) {
			instance = obj;
			goto l1;
		}
		/* begin objectAfter: */
		if (DoAssertionChecks) {
			if ((((usqInt) obj)) >= (((usqInt) endOfMemory))) {
				error("no objects after the end of memory");
			}
		}
		if (((longAt(obj)) & TypeMask) == HeaderTypeFree) {
			sz = (longAt(obj)) & (ALL_BUT_TYPE_MASK);
		} else {
			/* begin sizeBitsOf: */
			header = longAt(obj);
			if ((header & TypeMask) == HeaderTypeSizeAndClass) {
				sz = (longAt(obj - ((BYTES_PER_WORD) * 2))) & (LONG_SIZE_MASK);
				goto l2;
			} else {
				sz = header & (SIZE_MASK);
				goto l2;
			}
		l2:	/* end sizeBitsOf: */;
		}
		obj = (obj + sz) + (headerTypeBytes[(longAt(obj + sz)) & TypeMask]);
	}
	instance = null;
l1:	/* end accessibleObjectAfter: */;
	if (instance == null) {
		/* begin pop:thenPushInteger: */
		longAtput((sp = stackPointer - (((argumentCount + 1) - 1) * (BYTES_PER_WORD))), ((0 << 1) | 1));
		stackPointer = sp;
	} else {
		/* begin pop:thenPush: */
		longAtput((sp1 = stackPointer - (((argumentCount + 1) - 1) * (BYTES_PER_WORD))), instance);
		stackPointer = sp1;
	}
	return null;
}


/*	A placeholder for primitives that haven't been implemented or are being withdrawn gradually. Just absorbs any arguments and returns the receiver. */

sqInt primitiveNoop(void) {
	/* begin pop: */
	stackPointer -= argumentCount * (BYTES_PER_WORD);
	return null;
}

sqInt primitiveNotEqual(void) {
    sqInt integerArgument;
    sqInt integerReceiver;
    sqInt result;
    sqInt top;
    sqInt top1;
    sqInt sp;
    sqInt sp1;

	/* begin popStack */
	top = longAt(stackPointer);
	stackPointer -= BYTES_PER_WORD;
	integerArgument = top;
	/* begin popStack */
	top1 = longAt(stackPointer);
	stackPointer -= BYTES_PER_WORD;
	integerReceiver = top1;
	result = !(compare31or32Bitsequal(integerReceiver, integerArgument));
	/* begin checkBooleanResult: */
	if (!primFailCode) {
		/* begin pushBool: */
		if (result) {
			/* begin push: */
			longAtput((sp = stackPointer + (BYTES_PER_WORD)), trueObj);
			stackPointer = sp;
		} else {
			/* begin push: */
			longAtput((sp1 = stackPointer + (BYTES_PER_WORD)), falseObj);
			stackPointer = sp1;
		}
	} else {
		/* begin unPop: */
		stackPointer += 2 * (BYTES_PER_WORD);
	}
	return null;
}


/*	Primitive comparison operations for large integers in 64 bit range */

EXPORT(sqInt) primitiveNotEqualLargeIntegers(void) {
    sqLong integerArg;
    sqLong integerRcvr;
    sqInt sp;

	integerArg = signed64BitValueOf(longAt(stackPointer - (0 * (BYTES_PER_WORD))));
	integerRcvr = signed64BitValueOf(longAt(stackPointer - (1 * (BYTES_PER_WORD))));
	if (!primFailCode) {
		/* begin pop:thenPushBool: */
		longAtput((sp = stackPointer - ((2 - 1) * (BYTES_PER_WORD))), (integerRcvr != integerArg
			? trueObj
			: falseObj));
		stackPointer = sp;
	}
	return null;
}


/*	is the receiver/first argument not the same object as the (last) argument?.
	 pop argumentCount because this can be used as a mirror primitive. */

sqInt primitiveNotIdentical(void) {
    sqInt otherObject;
    sqInt thisObject;
    sqInt sp;

	otherObject = longAt(stackPointer - (1 * (BYTES_PER_WORD)));
	thisObject = longAt(stackPointer);
	/* begin pop:thenPushBool: */
	longAtput((sp = stackPointer - (((argumentCount + 1) - 1) * (BYTES_PER_WORD))), (thisObject != otherObject
		? trueObj
		: falseObj));
	stackPointer = sp;
	return null;
}


/*	Defined for CompiledMethods only */

sqInt primitiveObjectAt(void) {
    sqInt index;
    sqInt thisReceiver;
    sqInt object;
    sqInt sp;
    sqInt top;
    sqInt integerPointer;
    sqInt top1;
    sqInt successBoolean;

	/* begin popInteger */
	/* begin popStack */
	top1 = longAt(stackPointer);
	stackPointer -= BYTES_PER_WORD;
	integerPointer = top1;
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		index = (integerPointer >> 1);
		goto l1;
	} else {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		index = 0;
		goto l1;
	}
	index = null;
l1:	/* end popInteger */;
	/* begin popStack */
	top = longAt(stackPointer);
	stackPointer -= BYTES_PER_WORD;
	thisReceiver = top;
	/* begin success: */
	if (!(index > 0)) {
		if (!primFailCode) {
			primFailCode = 1;
		}
	}
	/* begin success: */
	successBoolean = index <= ((literalCountOfHeader(longAt((thisReceiver + (BASE_HEADER_SIZE)) + (HeaderIndex << (SHIFT_FOR_WORD))))) + LiteralStart);
	if (!(successBoolean)) {
		if (!primFailCode) {
			primFailCode = 1;
		}
	}
	if (!primFailCode) {
		/* begin push: */
		object = longAt((thisReceiver + (BASE_HEADER_SIZE)) + ((index - 1) << (SHIFT_FOR_WORD)));
		longAtput((sp = stackPointer + (BYTES_PER_WORD)), object);
		stackPointer = sp;
	} else {
		/* begin unPop: */
		stackPointer += 2 * (BYTES_PER_WORD);
	}
	return null;
}


/*	Defined for CompiledMethods only */

sqInt primitiveObjectAtPut(void) {
    sqInt index;
    sqInt newValue;
    sqInt thisReceiver;
    sqInt sp;
    sqInt top;
    sqInt top1;
    sqInt integerPointer;
    sqInt top2;
    sqInt successBoolean;

	/* begin popStack */
	top = longAt(stackPointer);
	stackPointer -= BYTES_PER_WORD;
	newValue = top;
	/* begin popInteger */
	/* begin popStack */
	top2 = longAt(stackPointer);
	stackPointer -= BYTES_PER_WORD;
	integerPointer = top2;
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		index = (integerPointer >> 1);
		goto l1;
	} else {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		index = 0;
		goto l1;
	}
	index = null;
l1:	/* end popInteger */;
	/* begin popStack */
	top1 = longAt(stackPointer);
	stackPointer -= BYTES_PER_WORD;
	thisReceiver = top1;
	/* begin success: */
	if (!(index > 0)) {
		if (!primFailCode) {
			primFailCode = 1;
		}
	}
	/* begin success: */
	successBoolean = index <= ((literalCountOfHeader(longAt((thisReceiver + (BASE_HEADER_SIZE)) + (HeaderIndex << (SHIFT_FOR_WORD))))) + LiteralStart);
	if (!(successBoolean)) {
		if (!primFailCode) {
			primFailCode = 1;
		}
	}
	if (!primFailCode) {
		/* begin storePointer:ofObject:withValue: */
		if ((((usqInt) thisReceiver)) < (((usqInt) youngStart))) {
			possibleRootStoreIntovalue(thisReceiver, newValue);
		}
		longAtput((thisReceiver + (BASE_HEADER_SIZE)) + ((index - 1) << (SHIFT_FOR_WORD)), newValue);
		/* begin push: */
		longAtput((sp = stackPointer + (BYTES_PER_WORD)), newValue);
		stackPointer = sp;
	} else {
		/* begin unPop: */
		stackPointer += 3 * (BYTES_PER_WORD);
	}
	return null;
}

sqInt primitiveObjectPointsTo(void) {
    sqInt i;
    sqInt lastField;
    sqInt rcvr;
    sqInt thang;
    sqInt top;
    sqInt top1;
    sqInt contextSize;
    sqInt fmt;
    sqInt header;
    sqInt methodHeader;
    sqInt sz;
    sqInt sp;
    sqInt sp2;
    sqInt sp1;
    sqInt header1;
    sqInt type;
    sqInt sp3;
    sqInt sp11;
    sqInt sp4;
    sqInt sp12;

	/* begin popStack */
	top = longAt(stackPointer);
	stackPointer -= BYTES_PER_WORD;
	thang = top;
	/* begin popStack */
	top1 = longAt(stackPointer);
	stackPointer -= BYTES_PER_WORD;
	rcvr = top1;
	if ((rcvr & 1)) {
		/* begin pushBool: */
		if (0) {
			/* begin push: */
			longAtput((sp2 = stackPointer + (BYTES_PER_WORD)), trueObj);
			stackPointer = sp2;
		} else {
			/* begin push: */
			longAtput((sp1 = stackPointer + (BYTES_PER_WORD)), falseObj);
			stackPointer = sp1;
		}
		return null;
	}
	/* begin lastPointerOf: */
	header = longAt(rcvr);
	fmt = (((usqInt) header) >> 8) & 15;
	if (fmt <= 4) {
		if ((fmt == 3) && ((((((usqInt) header) >> 12) & 31) == 13) || ((((((usqInt) header) >> 12) & 31) == 14) || (((((usqInt) header) >> 12) & 31) == 4)))) {
			/* begin fetchStackPointerOf: */
			sp = longAt((rcvr + (BASE_HEADER_SIZE)) + (StackPointerIndex << (SHIFT_FOR_WORD)));
			if (!((sp & 1))) {
				contextSize = 0;
				goto l1;
			}
			contextSize = (sp >> 1);
		l1:	/* end fetchStackPointerOf: */;
			lastField = (CtxtTempFrameStart + contextSize) * (BYTES_PER_WORD);
			goto l2;
		}
		/* begin sizeBitsOfSafe: */
		header1 = longAt(rcvr);
		/* begin rightType: */
		if ((header1 & (SIZE_MASK)) == 0) {
			type = HeaderTypeSizeAndClass;
			goto l3;
		} else {
			if ((header1 & CompactClassMask) == 0) {
				type = HeaderTypeClass;
				goto l3;
			} else {
				type = HeaderTypeShort;
				goto l3;
			}
		}
	l3:	/* end rightType: */;
		if (type == HeaderTypeSizeAndClass) {
			sz = (longAt(rcvr - ((BYTES_PER_WORD) * 2))) & (ALL_BUT_TYPE_MASK);
			goto l4;
		} else {
			sz = header1 & (SIZE_MASK);
			goto l4;
		}
	l4:	/* end sizeBitsOfSafe: */;
		lastField = sz - (BASE_HEADER_SIZE);
		goto l2;
	}
	if (fmt < 12) {
		lastField = 0;
		goto l2;
	}
	methodHeader = longAt(rcvr + (BASE_HEADER_SIZE));
	lastField = (((((usqInt) methodHeader) >> 10) & 255) * (BYTES_PER_WORD)) + (BASE_HEADER_SIZE);
l2:	/* end lastPointerOf: */;
	for (i = (BASE_HEADER_SIZE); i <= lastField; i += (BYTES_PER_WORD)) {
		if ((longAt(rcvr + i)) == thang) {
			/* begin pushBool: */
			if (1) {
				/* begin push: */
				longAtput((sp3 = stackPointer + (BYTES_PER_WORD)), trueObj);
				stackPointer = sp3;
			} else {
				/* begin push: */
				longAtput((sp11 = stackPointer + (BYTES_PER_WORD)), falseObj);
				stackPointer = sp11;
			}
			return null;
		}
	}
	/* begin pushBool: */
	if (0) {
		/* begin push: */
		longAtput((sp4 = stackPointer + (BYTES_PER_WORD)), trueObj);
		stackPointer = sp4;
	} else {
		/* begin push: */
		longAtput((sp12 = stackPointer + (BYTES_PER_WORD)), falseObj);
		stackPointer = sp12;
	}
	return null;
}

void primitivePerform(void) {
    sqInt i;
    sqInt lookupClass;
    sqInt newReceiver;
    sqInt performMethod;
    sqInt performSelector;
    sqInt selectorIndex;
    sqInt successBoolean;
    sqInt valuePointer;
    sqInt fromIndex;
    sqInt lastFrom;
    sqInt toIndex;
    sqInt ccIndex;
    sqInt oop1;

	performSelector = messageSelector;
	performMethod = newMethod;
	messageSelector = longAt(stackPointer - ((argumentCount - 1) * (BYTES_PER_WORD)));

	/* NOTE: the following lookup may fail and be converted to #doesNotUnderstand:, so we must adjust argumentCount and slide args now, so that would work. */
	/* Slide arguments down over selector */

	newReceiver = longAt(stackPointer - (argumentCount * (BYTES_PER_WORD)));
	argumentCount -= 1;
	selectorIndex = (((usqInt) ((stackPointer - activeContext) - (BASE_HEADER_SIZE))) >> (SHIFT_FOR_WORD)) - argumentCount;
	/* begin transfer:fromIndex:ofObject:toIndex:ofObject: */
	flag("Dan");
	fromIndex = activeContext + ((selectorIndex + 1) * (BYTES_PER_WORD));
	toIndex = activeContext + (selectorIndex * (BYTES_PER_WORD));
	lastFrom = fromIndex + (argumentCount * (BYTES_PER_WORD));
	while ((((usqInt) fromIndex)) < (((usqInt) lastFrom))) {
		fromIndex += BYTES_PER_WORD;
		toIndex += BYTES_PER_WORD;
		longAtput(toIndex, longAt(fromIndex));
	}
	/* begin pop: */
	stackPointer -= 1 * (BYTES_PER_WORD);
	/* begin fetchClassOf: */
	if ((newReceiver & 1)) {
		lookupClass = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassInteger << (SHIFT_FOR_WORD)));
		goto l1;
	}
	ccIndex = (((usqInt) (longAt(newReceiver))) >> 12) & 31;
	if (ccIndex == 0) {
		lookupClass = (longAt(newReceiver - (BASE_HEADER_SIZE))) & (ALL_BUT_TYPE_MASK);
		goto l1;
	} else {
		/* begin fetchPointer:ofObject: */
		oop1 = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (CompactClasses << (SHIFT_FOR_WORD)));
		lookupClass = longAt((oop1 + (BASE_HEADER_SIZE)) + ((ccIndex - 1) << (SHIFT_FOR_WORD)));
		goto l1;
	}
l1:	/* end fetchClassOf: */;
	findNewMethodInClass(lookupClass);
	if (((newMethod & 1) == 0) && (((((usqInt) (longAt(newMethod))) >> 8) & 15) >= 12)) {
		/* begin success: */
		successBoolean = ((((usqInt) (longAt((newMethod + (BASE_HEADER_SIZE)) + (HeaderIndex << (SHIFT_FOR_WORD))))) >> 25) & 15) == argumentCount;
		if (!(successBoolean)) {
			if (!primFailCode) {
				primFailCode = 1;
			}
		}
	}
	if (!primFailCode) {
		executeNewMethodFromCache();
		/* begin initPrimCall */
		primFailCode = 0;
	} else {

		/* Slide the args back up (sigh) and re-insert the 
			selector.  */

		for (i = 1; i <= argumentCount; i += 1) {
			/* begin storePointer:ofObject:withValue: */
			valuePointer = longAt((activeContext + (BASE_HEADER_SIZE)) + (((argumentCount - i) + selectorIndex) << (SHIFT_FOR_WORD)));
			if ((((usqInt) activeContext)) < (((usqInt) youngStart))) {
				possibleRootStoreIntovalue((sqInt)activeContext, valuePointer);
			}
			longAtput((activeContext + (BASE_HEADER_SIZE)) + ((((argumentCount - i) + 1) + selectorIndex) << (SHIFT_FOR_WORD)), valuePointer);
		}
		/* begin unPop: */
		stackPointer += 1 * (BYTES_PER_WORD);
		/* begin storePointer:ofObject:withValue: */
		if ((((usqInt) activeContext)) < (((usqInt) youngStart))) {
			possibleRootStoreIntovalue((sqInt)activeContext, messageSelector);
		}
		longAtput((activeContext + (BASE_HEADER_SIZE)) + (selectorIndex << (SHIFT_FOR_WORD)), messageSelector);
		argumentCount += 1;
		newMethod = performMethod;
		messageSelector = performSelector;
	}
}


/*	Common routine used by perform:withArgs: and perform:withArgs:inSuperclass: */
/*	NOTE:  The case of doesNotUnderstand: is not a failure to perform.
	The only failures are arg types and consistency of argumentCount. */

sqInt primitivePerformAt(sqInt lookupClass) {
    sqInt argumentArray;
    sqInt arraySize;
    sqInt cntxSize;
    sqInt index;
    sqInt performArgCount;
    sqInt performMethod;
    sqInt performSelector;
    sqInt sz;
    sqInt header;
    sqInt sz1;
    sqInt header1;
    sqInt successBoolean;
    sqInt object;
    sqInt sp;
    sqInt successBoolean1;
    sqInt sp1;
    sqInt sp2;
    sqInt top;
    sqInt top1;

	argumentArray = longAt(stackPointer);
	if (!(((argumentArray & 1) == 0) && (((((usqInt) (longAt(argumentArray))) >> 8) & 15) == 2))) {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		return null;
	}
	if (!primFailCode) {

		/* Check for enough space in thisContext to push all args */

		/* begin fetchWordLengthOf: */
		/* begin sizeBitsOf: */
		header = longAt(argumentArray);
		if ((header & TypeMask) == HeaderTypeSizeAndClass) {
			sz = (longAt(argumentArray - ((BYTES_PER_WORD) * 2))) & (LONG_SIZE_MASK);
			goto l1;
		} else {
			sz = header & (SIZE_MASK);
			goto l1;
		}
	l1:	/* end sizeBitsOf: */;
		arraySize = ((usqInt) (sz - (BASE_HEADER_SIZE))) >> (SHIFT_FOR_WORD);
		/* begin fetchWordLengthOf: */
		/* begin sizeBitsOf: */
		header1 = longAt(activeContext);
		if ((header1 & TypeMask) == HeaderTypeSizeAndClass) {
			sz1 = (longAt(activeContext - ((BYTES_PER_WORD) * 2))) & (LONG_SIZE_MASK);
			goto l2;
		} else {
			sz1 = header1 & (SIZE_MASK);
			goto l2;
		}
	l2:	/* end sizeBitsOf: */;
		cntxSize = ((usqInt) (sz1 - (BASE_HEADER_SIZE))) >> (SHIFT_FOR_WORD);
		/* begin success: */
		successBoolean = ((((usqInt) ((stackPointer - activeContext) - (BASE_HEADER_SIZE))) >> (SHIFT_FOR_WORD)) + arraySize) < cntxSize;
		if (!(successBoolean)) {
			if (!primFailCode) {
				primFailCode = 1;
			}
		}
	}
	if (!(!primFailCode)) {
		return null;
	}
	performSelector = messageSelector;
	performMethod = newMethod;

	/* pop the arg array and the selector, then push the args out of the array, as if they were on the stack */

	performArgCount = argumentCount;
	/* begin popStack */
	top = longAt(stackPointer);
	stackPointer -= BYTES_PER_WORD;
	/* begin popStack */
	top1 = longAt(stackPointer);
	stackPointer -= BYTES_PER_WORD;
	messageSelector = top1;
	index = 1;
	while (index <= arraySize) {
		/* begin push: */
		object = longAt((argumentArray + (BASE_HEADER_SIZE)) + ((index - 1) << (SHIFT_FOR_WORD)));
		longAtput((sp = stackPointer + (BYTES_PER_WORD)), object);
		stackPointer = sp;
		index += 1;
	}
	argumentCount = arraySize;
	findNewMethodInClass(lookupClass);
	if (((newMethod & 1) == 0) && (((((usqInt) (longAt(newMethod))) >> 8) & 15) >= 12)) {
		/* begin success: */
		successBoolean1 = ((((usqInt) (longAt((newMethod + (BASE_HEADER_SIZE)) + (HeaderIndex << (SHIFT_FOR_WORD))))) >> 25) & 15) == argumentCount;
		if (!(successBoolean1)) {
			if (!primFailCode) {
				primFailCode = 1;
			}
		}
	}
	if (!primFailCode) {
		executeNewMethodFromCache();
		/* begin initPrimCall */
		primFailCode = 0;
	} else {

		/* Restore the state by popping all those array entries and pushing back the selector and array, and fail */

		/* begin pop: */
		stackPointer -= argumentCount * (BYTES_PER_WORD);
		/* begin push: */
		longAtput((sp1 = stackPointer + (BYTES_PER_WORD)), messageSelector);
		stackPointer = sp1;
		/* begin push: */
		longAtput((sp2 = stackPointer + (BYTES_PER_WORD)), argumentArray);
		stackPointer = sp2;
		messageSelector = performSelector;
		newMethod = performMethod;
		argumentCount = performArgCount;
	}
	return null;
}

void primitivePerformInSuperclass(void) {
    sqInt currentClass;
    sqInt lookupClass;
    sqInt rcvr;
    sqInt s1;
    sqInt s2;
    sqInt s3;
    sqInt s4;
    sqInt s5;
    sqInt sp;
    sqInt top;
    sqInt sp1;
    sqInt sp2;
    sqInt sp3;
    sqInt sp4;
    sqInt sp5;
    sqInt top1;
    sqInt top2;
    sqInt top3;
    sqInt top4;
    sqInt top5;
    sqInt sp6;
    sqInt sp7;
    sqInt sp8;
    sqInt ccIndex;
    sqInt oop1;

	lookupClass = longAt(stackPointer);
	rcvr = longAt(stackPointer - (3 * (BYTES_PER_WORD)));
	/* begin fetchClassOf: */
	if ((rcvr & 1)) {
		currentClass = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassInteger << (SHIFT_FOR_WORD)));
		goto l1;
	}
	ccIndex = (((usqInt) (longAt(rcvr))) >> 12) & 31;
	if (ccIndex == 0) {
		currentClass = (longAt(rcvr - (BASE_HEADER_SIZE))) & (ALL_BUT_TYPE_MASK);
		goto l1;
	} else {
		/* begin fetchPointer:ofObject: */
		oop1 = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (CompactClasses << (SHIFT_FOR_WORD)));
		currentClass = longAt((oop1 + (BASE_HEADER_SIZE)) + ((ccIndex - 1) << (SHIFT_FOR_WORD)));
		goto l1;
	}
l1:	/* end fetchClassOf: */;
	while (currentClass != lookupClass) {
		currentClass = longAt((currentClass + (BASE_HEADER_SIZE)) + (SuperclassIndex << (SHIFT_FOR_WORD)));
		if (currentClass == nilObj) {
			(primFailCode = PrimErrBadArgument); return;
		}
	}
	if (argumentCount == 3) {

		/* normal primitive call with 3 arguments expected on the stack */

		/* begin popStack */
		top = longAt(stackPointer);
		stackPointer -= BYTES_PER_WORD;
		primitivePerformAt(lookupClass);
		if (!(!primFailCode)) {
			/* begin push: */
			longAtput((sp = stackPointer + (BYTES_PER_WORD)), lookupClass);
			stackPointer = sp;
		}
	} else {
		if (argumentCount == 4) {

			/* mirror primitive call with extra argument specifying object to serve as receiver */
			/* save stack contents */

			/* begin popStack */
			top1 = longAt(stackPointer);
			stackPointer -= BYTES_PER_WORD;
			s1 = top1;
			/* begin popStack */
			top2 = longAt(stackPointer);
			stackPointer -= BYTES_PER_WORD;
			s2 = top2;
			/* begin popStack */
			top3 = longAt(stackPointer);
			stackPointer -= BYTES_PER_WORD;
			s3 = top3;
			/* begin popStack */
			top4 = longAt(stackPointer);
			stackPointer -= BYTES_PER_WORD;
			s4 = top4;
			/* begin popStack */
			top5 = longAt(stackPointer);
			stackPointer -= BYTES_PER_WORD;
			s5 = top5;
			/* begin push: */
			longAtput((sp6 = stackPointer + (BYTES_PER_WORD)), s4);
			stackPointer = sp6;
			/* begin push: */
			longAtput((sp7 = stackPointer + (BYTES_PER_WORD)), s3);
			stackPointer = sp7;
			/* begin push: */
			longAtput((sp8 = stackPointer + (BYTES_PER_WORD)), s2);
			stackPointer = sp8;
			primitivePerformAt(lookupClass);
			if (!(!primFailCode)) {

				/* restore original stack */

				/* begin pop: */
				stackPointer -= 3 * (BYTES_PER_WORD);
				/* begin push: */
				longAtput((sp1 = stackPointer + (BYTES_PER_WORD)), s5);
				stackPointer = sp1;
				/* begin push: */
				longAtput((sp2 = stackPointer + (BYTES_PER_WORD)), s4);
				stackPointer = sp2;
				/* begin push: */
				longAtput((sp3 = stackPointer + (BYTES_PER_WORD)), s3);
				stackPointer = sp3;
				/* begin push: */
				longAtput((sp4 = stackPointer + (BYTES_PER_WORD)), s2);
				stackPointer = sp4;
				/* begin push: */
				longAtput((sp5 = stackPointer + (BYTES_PER_WORD)), s1);
				stackPointer = sp5;
			}
		} else {

			/* wrong number of arguments */

			(primFailCode = PrimErrBadNumArgs); return;
		}
	}
}

void primitivePerformWithArgs(void) {
    sqInt lookupClass;
    sqInt rcvr;
    sqInt ccIndex;
    sqInt oop1;

	rcvr = longAt(stackPointer - (argumentCount * (BYTES_PER_WORD)));
	/* begin fetchClassOf: */
	if ((rcvr & 1)) {
		lookupClass = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassInteger << (SHIFT_FOR_WORD)));
		goto l1;
	}
	ccIndex = (((usqInt) (longAt(rcvr))) >> 12) & 31;
	if (ccIndex == 0) {
		lookupClass = (longAt(rcvr - (BASE_HEADER_SIZE))) & (ALL_BUT_TYPE_MASK);
		goto l1;
	} else {
		/* begin fetchPointer:ofObject: */
		oop1 = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (CompactClasses << (SHIFT_FOR_WORD)));
		lookupClass = longAt((oop1 + (BASE_HEADER_SIZE)) + ((ccIndex - 1) << (SHIFT_FOR_WORD)));
		goto l1;
	}
l1:	/* end fetchClassOf: */;
	primitivePerformAt(lookupClass);
}


/*	Answer a string corresponding to the version of the external platform source
	code, typically written in C and managed separately for each platform.
	This is a named (not numbered) primitive in the null module (ie the VM) */

EXPORT(sqInt) primitivePlatformSourceVersion(void) {
    sqInt len;
    void * p;
    sqInt versionString;
    sqInt sp;

	
# ifdef PLATFORM_SOURCE_VERSION  // version level of platform support code
	len = strlen(PLATFORM_SOURCE_VERSION);
	versionString = instantiateClassindexableSize(longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassString << (SHIFT_FOR_WORD))), len);
	/* begin arrayValueOf: */
	if ((!((versionString & 1))) && (((versionString & 1) == 0) && (isWordsOrBytesNonInt(versionString)))) {
		p = pointerForOop(versionString + (BASE_HEADER_SIZE));
		goto l1;
	}
	/* begin primitiveFail */
	if (primFailCode == 0) {
		primFailCode = 1;
	}
l1:	/* end arrayValueOf: */;
	strncpy(p, PLATFORM_SOURCE_VERSION, len);
# else
	/* begin primitiveFail */
	if (primFailCode == 0) {
		primFailCode = 1;
	}
	return null;
# endif  // PLATFORM_SOURCE_VERSION
	
	/* begin pop:thenPush: */
	longAtput((sp = stackPointer - ((1 - 1) * (BYTES_PER_WORD))), versionString);
	stackPointer = sp;
	return null;
}

void primitivePushFalse(void) {
    sqInt top;
    sqInt sp;

	/* begin popStack */
	top = longAt(stackPointer);
	stackPointer -= BYTES_PER_WORD;
	/* begin push: */
	longAtput((sp = stackPointer + (BYTES_PER_WORD)), falseObj);
	stackPointer = sp;
}

void primitivePushMinusOne(void) {
    sqInt top;
    sqInt sp;

	/* begin popStack */
	top = longAt(stackPointer);
	stackPointer -= BYTES_PER_WORD;
	/* begin push: */
	longAtput((sp = stackPointer + (BYTES_PER_WORD)), ConstMinusOne);
	stackPointer = sp;
}

void primitivePushNil(void) {
    sqInt top;
    sqInt sp;

	/* begin popStack */
	top = longAt(stackPointer);
	stackPointer -= BYTES_PER_WORD;
	/* begin push: */
	longAtput((sp = stackPointer + (BYTES_PER_WORD)), nilObj);
	stackPointer = sp;
}

void primitivePushOne(void) {
    sqInt top;
    sqInt sp;

	/* begin popStack */
	top = longAt(stackPointer);
	stackPointer -= BYTES_PER_WORD;
	/* begin push: */
	longAtput((sp = stackPointer + (BYTES_PER_WORD)), ConstOne);
	stackPointer = sp;
}


/*		no-op, really...
	thisReceiver := self popStack.
	self push: thisReceiver
 */

void primitivePushSelf(void) {
}

void primitivePushTrue(void) {
    sqInt top;
    sqInt sp;

	/* begin popStack */
	top = longAt(stackPointer);
	stackPointer -= BYTES_PER_WORD;
	/* begin push: */
	longAtput((sp = stackPointer + (BYTES_PER_WORD)), trueObj);
	stackPointer = sp;
}

void primitivePushTwo(void) {
    sqInt top;
    sqInt sp;

	/* begin popStack */
	top = longAt(stackPointer);
	stackPointer -= BYTES_PER_WORD;
	/* begin push: */
	longAtput((sp = stackPointer + (BYTES_PER_WORD)), ConstTwo);
	stackPointer = sp;
}

void primitivePushZero(void) {
    sqInt top;
    sqInt sp;

	/* begin popStack */
	top = longAt(stackPointer);
	stackPointer -= BYTES_PER_WORD;
	/* begin push: */
	longAtput((sp = stackPointer + (BYTES_PER_WORD)), ConstZero);
	stackPointer = sp;
}

sqInt primitiveQuit(void) {
	ioExitWithErrorCode((argumentCount == 1
		? ((longAt(stackPointer)) >> 1)
		: 0));
	return null;
}


/*	Rounds negative results towards zero. */

sqInt primitiveQuo(void) {
    sqInt integerArg;
    sqInt integerRcvr;
    sqInt integerResult;
    sqInt sp;
    sqInt integerPointer;
    sqInt integerPointer1;

	/* begin stackIntegerValue: */
	integerPointer = longAt(stackPointer - (1 * (BYTES_PER_WORD)));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		integerRcvr = (integerPointer >> 1);
		goto l1;
	} else {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		integerRcvr = 0;
		goto l1;
	}
	integerRcvr = null;
l1:	/* end stackIntegerValue: */;
	/* begin stackIntegerValue: */
	integerPointer1 = longAt(stackPointer - (0 * (BYTES_PER_WORD)));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer1 & 1)) {
		integerArg = (integerPointer1 >> 1);
		goto l2;
	} else {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		integerArg = 0;
		goto l2;
	}
	integerArg = null;
l2:	/* end stackIntegerValue: */;
	/* begin success: */
	if (!(integerArg != 0)) {
		if (!primFailCode) {
			primFailCode = 1;
		}
	}
	if (!primFailCode) {
		if (integerRcvr > 0) {
			if (integerArg > 0) {
				integerResult = integerRcvr / integerArg;
			} else {
				integerResult = 0 - (integerRcvr / (0 - integerArg));
			}
		} else {
			if (integerArg > 0) {
				integerResult = 0 - ((0 - integerRcvr) / integerArg);
			} else {
				integerResult = (0 - integerRcvr) / (0 - integerArg);
			}
		}
	}
	/* begin pop2AndPushIntegerIfOK: */
	if (!primFailCode) {
		if (
# ifdef SQ_HOST32  // cast to int for 64 bit image on 32 bit host
			(((((int) integerResult)) ^ ((((int) integerResult)) << 1)) >= 0)
# else
			((integerResult >= -1073741824) && (integerResult <= 1073741823))
# endif  // SQ_HOST32
		) {
			/* begin pop:thenPush: */
			longAtput((sp = stackPointer - ((2 - 1) * (BYTES_PER_WORD))), ((integerResult << 1) | 1));
			stackPointer = sp;
		} else {
			/* begin primitiveFail */
			if (primFailCode == 0) {
				primFailCode = 1;
			}
		}
	}
	return null;
}


/*	Primitive arithmetic operations for large integers in 64 bit range */

EXPORT(sqInt) primitiveQuoLargeIntegers(void) {
    usqLong a;
    sqInt aIsNegative;
    usqLong b;
    sqInt bIsNegative;
    sqInt oopArg;
    sqInt oopRcvr;
    sqInt oopResult;
    usqLong result;
    sqInt sp;

	oopArg = longAt(stackPointer - (0 * (BYTES_PER_WORD)));
	oopRcvr = longAt(stackPointer - (1 * (BYTES_PER_WORD)));
	aIsNegative = isNegativeIntegerValueOf(oopRcvr);
	bIsNegative = isNegativeIntegerValueOf(oopArg);
	a = magnitude64BitValueOf(oopRcvr);
	b = magnitude64BitValueOf(oopArg);
	if (b == 0) {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
	}
	if (!(!primFailCode)) {
		return null;
	}
	result = a / b;
	oopResult = magnitude64BitIntegerForneg(result, bIsNegative != aIsNegative);
	if (!primFailCode) {
		/* begin pop:thenPush: */
		longAtput((sp = stackPointer - ((2 - 1) * (BYTES_PER_WORD))), oopResult);
		stackPointer = sp;
	}
	return null;
}


/*	Relinquish the processor for up to the given number of microseconds. The exact behavior of this primitive is platform dependent. */

sqInt primitiveRelinquishProcessor(void) {
    sqInt microSecs;
    sqInt integerPointer;

	/* begin stackIntegerValue: */
	integerPointer = longAt(stackPointer - (0 * (BYTES_PER_WORD)));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		microSecs = (integerPointer >> 1);
		goto l1;
	} else {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		microSecs = 0;
		goto l1;
	}
	microSecs = null;
l1:	/* end stackIntegerValue: */;
	if (!primFailCode) {
		ioRelinquishProcessorForMicroseconds(microSecs);
		/* begin pop: */
		stackPointer -= 1 * (BYTES_PER_WORD);
	}
	return null;
}


/*	Primitive arithmetic operations for large integers in 64 bit range */

EXPORT(sqInt) primitiveRemLargeIntegers(void) {
    usqLong a;
    sqInt aIsNegative;
    usqLong b;
    sqInt oopArg;
    sqInt oopRcvr;
    sqInt oopResult;
    usqLong result;
    sqInt sp;

	oopArg = longAt(stackPointer - (0 * (BYTES_PER_WORD)));
	oopRcvr = longAt(stackPointer - (1 * (BYTES_PER_WORD)));
	aIsNegative = isNegativeIntegerValueOf(oopRcvr);
	a = magnitude64BitValueOf(oopRcvr);
	b = magnitude64BitValueOf(oopArg);
	if (b == 0) {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
	}
	if (!(!primFailCode)) {
		return null;
	}
	result = a % b;
	oopResult = magnitude64BitIntegerForneg(result, aIsNegative);
	if (!primFailCode) {
		/* begin pop:thenPush: */
		longAtput((sp = stackPointer - ((2 - 1) * (BYTES_PER_WORD))), oopResult);
		stackPointer = sp;
	}
	return null;
}

sqInt primitiveResponse(void) {
    sqInt delta;
    sqInt nArgs;
    sqInt primIdx;

	if (DoBalanceChecks) {

		/* check stack balance */

		nArgs = argumentCount;
		delta = stackPointer - activeContext;
	}
	primIdx = primitiveIndex;
	/* begin initPrimCall */
	primFailCode = 0;
	dispatchFunctionPointerOnin(primIdx, primitiveTable);
	if (DoBalanceChecks) {
		if (!(balancedStackafterPrimitivewithArgs(delta, primIdx, nArgs))) {
			printUnbalancedStack(primIdx);
		}
	}
	checkForInterrupts();

	/* clear out primIndex so VM knows we're no longer in primitive */

	primitiveIndex = 0;
	return primFailCode;
}


/*	Put this process on the scheduler's lists thus allowing it to proceed next
	time there is a chance for processes of its priority level */

void primitiveResume(void) {
    sqInt proc;


	/* rcvr */
	/* self success: ((self fetchClassOf: proc) = (self splObj: ClassProcess)). */

	proc = longAt(stackPointer);
	if (!primFailCode) {
		resume(proc);
	}
}


/*	Primitive. Answer a copy (snapshot) element of the root table.
	The primitive can cause GC itself and if so the return value may
	be inaccurate - in this case one should guard the read operation
	by looking at the gc counter statistics. */

EXPORT(sqInt) primitiveRootTable(void) {
    sqInt i;
    sqInt oop;
    sqInt sz;
    sqInt sp;

	sz = rootTableCount;

	/* can cause GC */

	oop = instantiateClassindexableSize(longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassArray << (SHIFT_FOR_WORD))), sz);
	if (sz > rootTableCount) {
		sz = rootTableCount;
	}
	for (i = 1; i <= sz; i += 1) {
		/* begin storePointer:ofObject:withValue: */
		if ((((usqInt) oop)) < (((usqInt) youngStart))) {
			possibleRootStoreIntovalue(oop, rootTable[i]);
		}
		longAtput((oop + (BASE_HEADER_SIZE)) + ((i - 1) << (SHIFT_FOR_WORD)), rootTable[i]);
	}
	/* begin pop: */
	stackPointer -= (argumentCount + 1) * (BYTES_PER_WORD);
	/* begin push: */
	longAtput((sp = stackPointer + (BYTES_PER_WORD)), oop);
	stackPointer = sp;
	return null;
}


/*	Primitive. Answer the nth element of the root table.
	This primitive avoids the creation of an extra array;
	it is intended for enumerations of the form:
		index := 1.
		[root := Smalltalk rootTableAt: index.
		root == nil] whileFalse:[index := index + 1].
	 */

EXPORT(sqInt) primitiveRootTableAt(void) {
    sqInt index;
    sqInt sp;
    sqInt successBoolean;
    sqInt integerPointer;

	/* begin stackIntegerValue: */
	integerPointer = longAt(stackPointer - (0 * (BYTES_PER_WORD)));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		index = (integerPointer >> 1);
		goto l1;
	} else {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		index = 0;
		goto l1;
	}
	index = null;
l1:	/* end stackIntegerValue: */;
	/* begin success: */
	successBoolean = (index > 0) && (index <= rootTableCount);
	if (!(successBoolean)) {
		if (!primFailCode) {
			primFailCode = 1;
		}
	}
	if (!primFailCode) {
		/* begin pop: */
		stackPointer -= (argumentCount + 1) * (BYTES_PER_WORD);
		/* begin push: */
		longAtput((sp = stackPointer + (BYTES_PER_WORD)), rootTable[index]);
		stackPointer = sp;
	}
	return null;
}


/*	The character scanner primitive. */

sqInt primitiveScanCharacters(void) {
    sqInt ascii;
    sqInt glyphIndex;
    sqInt kernDelta;
    sqInt maxGlyph;
    sqInt nextDestX;
    sqInt nilOop;
    sqInt rcvr;
    sqInt scanDestX;
    sqInt scanLastIndex;
    sqInt scanMap;
    sqInt scanRightX;
    sqInt scanStartIndex;
    sqInt scanStopIndex;
    sqInt scanXTable;
    sqInt sourceString;
    sqInt sourceX;
    sqInt sourceX2;
    sqInt stopReason;
    sqInt stops;
    sqInt sp;
    sqInt object;
    sqInt sp1;
    sqInt object1;
    sqInt sp2;
    sqInt oop;
    sqInt oop1;
    sqInt oop2;
    sqInt integerPointer;
    sqInt integerPointer1;
    sqInt integerPointer2;
    sqInt integerPointer3;

	if (!(argumentCount == 6)) {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		return null;
	}
	/* begin stackIntegerValue: */
	integerPointer = longAt(stackPointer - (0 * (BYTES_PER_WORD)));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		kernDelta = (integerPointer >> 1);
		goto l4;
	} else {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		kernDelta = 0;
		goto l4;
	}
	kernDelta = null;
l4:	/* end stackIntegerValue: */;
	/* begin stackObjectValue: */
	oop = longAt(stackPointer - (1 * (BYTES_PER_WORD)));
	if ((oop & 1)) {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		stops = null;
		goto l1;
	}
	stops = oop;
l1:	/* end stackObjectValue: */;
	if (!(((stops & 1) == 0) && (((((usqInt) (longAt(stops))) >> 8) & 15) == 2))) {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		return null;
	}
	if (!((slotSizeOf(stops)) >= 258)) {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		return null;
	}
	/* begin stackIntegerValue: */
	integerPointer1 = longAt(stackPointer - (2 * (BYTES_PER_WORD)));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer1 & 1)) {
		scanRightX = (integerPointer1 >> 1);
		goto l5;
	} else {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		scanRightX = 0;
		goto l5;
	}
	scanRightX = null;
l5:	/* end stackIntegerValue: */;
	/* begin stackObjectValue: */
	oop1 = longAt(stackPointer - (3 * (BYTES_PER_WORD)));
	if ((oop1 & 1)) {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		sourceString = null;
		goto l2;
	}
	sourceString = oop1;
l2:	/* end stackObjectValue: */;
	if (!(((sourceString & 1) == 0) && (((((usqInt) (longAt(sourceString))) >> 8) & 15) >= 8))) {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		return null;
	}
	/* begin stackIntegerValue: */
	integerPointer2 = longAt(stackPointer - (4 * (BYTES_PER_WORD)));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer2 & 1)) {
		scanStopIndex = (integerPointer2 >> 1);
		goto l6;
	} else {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		scanStopIndex = 0;
		goto l6;
	}
	scanStopIndex = null;
l6:	/* end stackIntegerValue: */;
	/* begin stackIntegerValue: */
	integerPointer3 = longAt(stackPointer - (5 * (BYTES_PER_WORD)));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer3 & 1)) {
		scanStartIndex = (integerPointer3 >> 1);
		goto l7;
	} else {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		scanStartIndex = 0;
		goto l7;
	}
	scanStartIndex = null;
l7:	/* end stackIntegerValue: */;
	if (!((scanStartIndex > 0) && ((scanStopIndex > 0) && (scanStopIndex <= (byteSizeOf(sourceString)))))) {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		return null;
	}
	/* begin stackObjectValue: */
	oop2 = longAt(stackPointer - (6 * (BYTES_PER_WORD)));
	if ((oop2 & 1)) {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		rcvr = null;
		goto l3;
	}
	rcvr = oop2;
l3:	/* end stackObjectValue: */;
	if (!((((rcvr & 1) == 0) && (((((usqInt) (longAt(rcvr))) >> 8) & 15) <= 4)) && ((slotSizeOf(rcvr)) >= 4))) {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		return null;
	}
	scanDestX = fetchIntegerofObject(0, rcvr);
	scanLastIndex = fetchIntegerofObject(1, rcvr);
	scanXTable = longAt((rcvr + (BASE_HEADER_SIZE)) + (2 << (SHIFT_FOR_WORD)));
	scanMap = longAt((rcvr + (BASE_HEADER_SIZE)) + (3 << (SHIFT_FOR_WORD)));
	if (!((((scanXTable & 1) == 0) && (((((usqInt) (longAt(scanXTable))) >> 8) & 15) == 2)) && (((scanMap & 1) == 0) && (((((usqInt) (longAt(scanMap))) >> 8) & 15) == 2)))) {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		return null;
	}
	if (!((slotSizeOf(scanMap)) == 256)) {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		return null;
	}
	if (!(!primFailCode)) {
		return null;
	}

	/* Okay, here we go. We have eliminated nearly all failure 
	conditions, to optimize the inner fetches. */

	maxGlyph = (slotSizeOf(scanXTable)) - 2;
	scanLastIndex = scanStartIndex;
	nilOop = nilObj;
	while (scanLastIndex <= scanStopIndex) {

		/* Known to be okay since scanStartIndex > 0 and scanStopIndex <= sourceString size */


		/* Known to be okay since stops size >= 258 */

		ascii = byteAt((sourceString + (BASE_HEADER_SIZE)) + (scanLastIndex - 1));
		if (!(((stopReason = longAt((stops + (BASE_HEADER_SIZE)) + (ascii << (SHIFT_FOR_WORD))))) == nilOop)) {

			/* Store everything back and get out of here since some stop conditionn needs to be checked */

			if (!(
# ifdef SQ_HOST32  // cast to int for 64 bit image on 32 bit host
					(((((int) scanDestX)) ^ ((((int) scanDestX)) << 1)) >= 0)
# else
					((scanDestX >= -1073741824) && (scanDestX <= 1073741823))
# endif  // SQ_HOST32
				)) {
				/* begin primitiveFail */
				if (primFailCode == 0) {
					primFailCode = 1;
				}
				return null;
			}
			/* begin storeInteger:ofObject:withValue: */
			if (
# ifdef SQ_HOST32  // cast to int for 64 bit image on 32 bit host
				(((((int) scanDestX)) ^ ((((int) scanDestX)) << 1)) >= 0)
# else
				((scanDestX >= -1073741824) && (scanDestX <= 1073741823))
# endif  // SQ_HOST32
			) {
				longAtput((rcvr + (BASE_HEADER_SIZE)) + (0 << (SHIFT_FOR_WORD)), ((scanDestX << 1) | 1));
			} else {
				/* begin primitiveFail */
				if (primFailCode == 0) {
					primFailCode = 1;
				}
			}
			/* begin storeInteger:ofObject:withValue: */
			if (
# ifdef SQ_HOST32  // cast to int for 64 bit image on 32 bit host
				(((((int) scanLastIndex)) ^ ((((int) scanLastIndex)) << 1)) >= 0)
# else
				((scanLastIndex >= -1073741824) && (scanLastIndex <= 1073741823))
# endif  // SQ_HOST32
			) {
				longAtput((rcvr + (BASE_HEADER_SIZE)) + (1 << (SHIFT_FOR_WORD)), ((scanLastIndex << 1) | 1));
			} else {
				/* begin primitiveFail */
				if (primFailCode == 0) {
					primFailCode = 1;
				}
			}
			/* begin pop: */
			stackPointer -= 7 * (BYTES_PER_WORD);
			/* begin push: */
			longAtput((sp = stackPointer + (BYTES_PER_WORD)), stopReason);
			stackPointer = sp;
			return null;
		}

		/* fail if the glyphIndex is out of range */

		glyphIndex = fetchIntegerofObject(ascii, scanMap);
		if (primFailCode || ((glyphIndex < 0) || (glyphIndex > maxGlyph))) {
			/* begin primitiveFail */
			if (primFailCode == 0) {
				primFailCode = 1;
			}
			return null;
		}
		sourceX = fetchIntegerofObject(glyphIndex, scanXTable);

		/* Above may fail if non-integer entries in scanXTable */

		sourceX2 = fetchIntegerofObject(glyphIndex + 1, scanXTable);
		if (primFailCode) {
			return null;
		}
		nextDestX = (scanDestX + sourceX2) - sourceX;
		if (nextDestX > scanRightX) {

			/* Store everything back and get out of here since we got to the right edge */

			if (!(
# ifdef SQ_HOST32  // cast to int for 64 bit image on 32 bit host
					(((((int) scanDestX)) ^ ((((int) scanDestX)) << 1)) >= 0)
# else
					((scanDestX >= -1073741824) && (scanDestX <= 1073741823))
# endif  // SQ_HOST32
				)) {
				/* begin primitiveFail */
				if (primFailCode == 0) {
					primFailCode = 1;
				}
				return null;
			}
			/* begin storeInteger:ofObject:withValue: */
			if (
# ifdef SQ_HOST32  // cast to int for 64 bit image on 32 bit host
				(((((int) scanDestX)) ^ ((((int) scanDestX)) << 1)) >= 0)
# else
				((scanDestX >= -1073741824) && (scanDestX <= 1073741823))
# endif  // SQ_HOST32
			) {
				longAtput((rcvr + (BASE_HEADER_SIZE)) + (0 << (SHIFT_FOR_WORD)), ((scanDestX << 1) | 1));
			} else {
				/* begin primitiveFail */
				if (primFailCode == 0) {
					primFailCode = 1;
				}
			}
			/* begin storeInteger:ofObject:withValue: */
			if (
# ifdef SQ_HOST32  // cast to int for 64 bit image on 32 bit host
				(((((int) scanLastIndex)) ^ ((((int) scanLastIndex)) << 1)) >= 0)
# else
				((scanLastIndex >= -1073741824) && (scanLastIndex <= 1073741823))
# endif  // SQ_HOST32
			) {
				longAtput((rcvr + (BASE_HEADER_SIZE)) + (1 << (SHIFT_FOR_WORD)), ((scanLastIndex << 1) | 1));
			} else {
				/* begin primitiveFail */
				if (primFailCode == 0) {
					primFailCode = 1;
				}
			}
			/* begin pop: */
			stackPointer -= 7 * (BYTES_PER_WORD);
			/* begin push: */
			object = longAt((stops + (BASE_HEADER_SIZE)) + ((CrossedX - 1) << (SHIFT_FOR_WORD)));
			longAtput((sp1 = stackPointer + (BYTES_PER_WORD)), object);
			stackPointer = sp1;
			return null;
		}
		scanDestX = nextDestX + kernDelta;
		scanLastIndex += 1;
	}
	if (!(
# ifdef SQ_HOST32  // cast to int for 64 bit image on 32 bit host
			(((((int) scanDestX)) ^ ((((int) scanDestX)) << 1)) >= 0)
# else
			((scanDestX >= -1073741824) && (scanDestX <= 1073741823))
# endif  // SQ_HOST32
		)) {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		return null;
	}
	/* begin storeInteger:ofObject:withValue: */
	if (
# ifdef SQ_HOST32  // cast to int for 64 bit image on 32 bit host
		(((((int) scanDestX)) ^ ((((int) scanDestX)) << 1)) >= 0)
# else
		((scanDestX >= -1073741824) && (scanDestX <= 1073741823))
# endif  // SQ_HOST32
	) {
		longAtput((rcvr + (BASE_HEADER_SIZE)) + (0 << (SHIFT_FOR_WORD)), ((scanDestX << 1) | 1));
	} else {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
	}
	/* begin storeInteger:ofObject:withValue: */
	if (
# ifdef SQ_HOST32  // cast to int for 64 bit image on 32 bit host
		(((((int) scanStopIndex)) ^ ((((int) scanStopIndex)) << 1)) >= 0)
# else
		((scanStopIndex >= -1073741824) && (scanStopIndex <= 1073741823))
# endif  // SQ_HOST32
	) {
		longAtput((rcvr + (BASE_HEADER_SIZE)) + (1 << (SHIFT_FOR_WORD)), ((scanStopIndex << 1) | 1));
	} else {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
	}
	/* begin pop: */
	stackPointer -= 7 * (BYTES_PER_WORD);
	/* begin push: */
	object1 = longAt((stops + (BASE_HEADER_SIZE)) + ((EndOfRun - 1) << (SHIFT_FOR_WORD)));
	longAtput((sp2 = stackPointer + (BYTES_PER_WORD)), object1);
	stackPointer = sp2;
	return null;
}


/*	Return a SmallInteger indicating the current depth of the OS screen. Negative values are used to imply LSB type pixel format an there is some support in the VM for handling either MSB or LSB */

EXPORT(sqInt) primitiveScreenDepth(void) {
    sqInt depth;
    sqInt sp;

	depth = ioScreenDepth();
	if (primFailCode) {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		return null;
	}
	/* begin pop:thenPushInteger: */
	longAtput((sp = stackPointer - ((1 - 1) * (BYTES_PER_WORD))), ((depth << 1) | 1));
	stackPointer = sp;
	return null;
}


/*	Return a point indicating the current size of the Smalltalk window. Currently there is a limit of 65535 in each direction because the point is encoded into a single 32bit value in the image header. This might well become a problem one day */

sqInt primitiveScreenSize(void) {
    sqInt pointWord;
    sqInt object;
    sqInt sp;
    sqInt pointResult;

	/* begin pop: */
	stackPointer -= 1 * (BYTES_PER_WORD);
	pointWord = ioScreenSize();
	/* begin push: */
	/* begin makePointwithxValue:yValue: */
	pointResult = instantiateSmallClasssizeInBytes(longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassPoint << (SHIFT_FOR_WORD))), 3 * (BYTES_PER_WORD));
	longAtput((pointResult + (BASE_HEADER_SIZE)) + (XIndex << (SHIFT_FOR_WORD)), ((((((usqInt) pointWord) >> 16) & 65535) << 1) | 1));
	longAtput((pointResult + (BASE_HEADER_SIZE)) + (YIndex << (SHIFT_FOR_WORD)), (((pointWord & 65535) << 1) | 1));
	object = pointResult;
	longAtput((sp = stackPointer + (BYTES_PER_WORD)), object);
	stackPointer = sp;
	return null;
}


/*	Return the number of seconds since January 1, 1901 as an integer. */

sqInt primitiveSecondsClock(void) {
    sqInt oop;
    sqInt sp;

	/* begin pop:thenPush: */
	oop = positive32BitIntegerFor(ioSeconds());
	longAtput((sp = stackPointer - ((1 - 1) * (BYTES_PER_WORD))), oop);
	stackPointer = sp;
	return null;
}


/*	Set to OS to the requested display mode.
	See also DisplayScreen setDisplayDepth:extent:fullscreen: */

sqInt primitiveSetDisplayMode(void) {
    sqInt d;
    sqInt fsFlag;
    sqInt h;
    sqInt okay;
    sqInt w;
    sqInt sp;
    sqInt integerPointer;
    sqInt integerPointer1;
    sqInt integerPointer2;

	/* begin booleanValueOf: */
	if ((longAt(stackPointer)) == trueObj) {
		fsFlag = 1;
		goto l1;
	}
	if ((longAt(stackPointer)) == falseObj) {
		fsFlag = 0;
		goto l1;
	}
	/* begin primitiveFail */
	if (primFailCode == 0) {
		primFailCode = 1;
	}
	fsFlag = null;
l1:	/* end booleanValueOf: */;
	/* begin stackIntegerValue: */
	integerPointer = longAt(stackPointer - (1 * (BYTES_PER_WORD)));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		h = (integerPointer >> 1);
		goto l2;
	} else {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		h = 0;
		goto l2;
	}
	h = null;
l2:	/* end stackIntegerValue: */;
	/* begin stackIntegerValue: */
	integerPointer1 = longAt(stackPointer - (2 * (BYTES_PER_WORD)));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer1 & 1)) {
		w = (integerPointer1 >> 1);
		goto l3;
	} else {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		w = 0;
		goto l3;
	}
	w = null;
l3:	/* end stackIntegerValue: */;
	/* begin stackIntegerValue: */
	integerPointer2 = longAt(stackPointer - (3 * (BYTES_PER_WORD)));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer2 & 1)) {
		d = (integerPointer2 >> 1);
		goto l4;
	} else {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		d = 0;
		goto l4;
	}
	d = null;
l4:	/* end stackIntegerValue: */;
	if (!primFailCode) {
		okay = ioSetDisplayMode(w, h, d, fsFlag);
	}
	if (!primFailCode) {
		/* begin pop:thenPushBool: */
		longAtput((sp = stackPointer - ((5 - 1) * (BYTES_PER_WORD))), (okay
			? trueObj
			: falseObj));
		stackPointer = sp;
	}
	return null;
}


/*	On platforms that support it, set full-screen mode to the value of the boolean argument. */

sqInt primitiveSetFullScreen(void) {
    sqInt argOop;

	argOop = longAt(stackPointer);
	if (argOop == trueObj) {
		ioSetFullScreen(1);
	} else {
		if (argOop == falseObj) {
			ioSetFullScreen(0);
		} else {
			/* begin primitiveFail */
			if (primFailCode == 0) {
				primFailCode = 1;
			}
		}
	}
	if (!primFailCode) {
		/* begin pop: */
		stackPointer -= 1 * (BYTES_PER_WORD);
	}
	return null;
}


/*	Primitive. Indicate if the GC logic should have bias to grow */

EXPORT(sqInt) primitiveSetGCBiasToGrow(void) {
    sqInt flag;
    sqInt integerPointer;

	/* begin stackIntegerValue: */
	integerPointer = longAt(stackPointer - (0 * (BYTES_PER_WORD)));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		flag = (integerPointer >> 1);
		goto l1;
	} else {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		flag = 0;
		goto l1;
	}
	flag = null;
l1:	/* end stackIntegerValue: */;
	if (!primFailCode) {
		/* begin setGcBiasToGrow: */
		gcBiasToGrow = flag;
		/* begin pop: */
		stackPointer -= argumentCount * (BYTES_PER_WORD);
	}
	return null;
}


/*	Primitive. If the GC logic has  bias to grow, set growth limit */

EXPORT(sqInt) primitiveSetGCBiasToGrowGCLimit(void) {
    sqInt value;
    sqInt integerPointer;

	/* begin stackIntegerValue: */
	integerPointer = longAt(stackPointer - (0 * (BYTES_PER_WORD)));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		value = (integerPointer >> 1);
		goto l1;
	} else {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		value = 0;
		goto l1;
	}
	value = null;
l1:	/* end stackIntegerValue: */;
	if (!primFailCode) {
		/* begin setGCBiasToGrowGCLimit: */
		gcBiasToGrowGCLimit = value;
		gcBiasToGrowThreshold = (usqInt)youngStart - (((int) memory));
		/* begin pop: */
		stackPointer -= argumentCount * (BYTES_PER_WORD);
	}
	return null;
}


/*	Primitive. Indicate the semaphore to be signalled for upon garbage collection */

EXPORT(sqInt) primitiveSetGCSemaphore(void) {
    sqInt index;
    sqInt integerPointer;

	/* begin stackIntegerValue: */
	integerPointer = longAt(stackPointer - (0 * (BYTES_PER_WORD)));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		index = (integerPointer >> 1);
		goto l1;
	} else {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		index = 0;
		goto l1;
	}
	index = null;
l1:	/* end stackIntegerValue: */;
	if (!primFailCode) {
		/* begin setGcSemaphoreIndex: */
		gcSemaphoreIndex = index;
		/* begin pop: */
		stackPointer -= argumentCount * (BYTES_PER_WORD);
	}
	return null;
}

sqInt primitiveSetIdentityHash(void) {
    sqInt hash;
    sqInt oldHash;
    sqInt thisReceiver;
    sqInt sp;
    sqInt oop;
    sqInt integerPointer;

	/* begin stackIntegerValue: */
	integerPointer = longAt(stackPointer - (0 * (BYTES_PER_WORD)));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		hash = (integerPointer >> 1);
		goto l2;
	} else {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		hash = 0;
		goto l2;
	}
	hash = null;
l2:	/* end stackIntegerValue: */;
	/* begin stackObjectValue: */
	oop = longAt(stackPointer - (1 * (BYTES_PER_WORD)));
	if ((oop & 1)) {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		thisReceiver = null;
		goto l1;
	}
	thisReceiver = oop;
l1:	/* end stackObjectValue: */;
	if (!primFailCode) {
		oldHash = (((usqInt) (longAt(thisReceiver))) >> 17) & 4095;
		/* begin setHashBitsOf:to: */
		longAtput(thisReceiver, ((((longAt(thisReceiver)) | HashBits) - HashBits)) | ((hash & HashMaskUnshifted) << HashBitsOffset));
		/* begin pop:thenPushInteger: */
		longAtput((sp = stackPointer - (((argumentCount + 1) - 1) * (BYTES_PER_WORD))), ((oldHash << 1) | 1));
		stackPointer = sp;
	}
	return null;
}


/*	Set the user interrupt keycode. The keycode is an integer whose encoding is described in the comment for primitiveKbdNext. */

sqInt primitiveSetInterruptKey(void) {
    sqInt keycode;
    sqInt integerPointer;
    sqInt top;

	/* begin popInteger */
	/* begin popStack */
	top = longAt(stackPointer);
	stackPointer -= BYTES_PER_WORD;
	integerPointer = top;
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		keycode = (integerPointer >> 1);
		goto l1;
	} else {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		keycode = 0;
		goto l1;
	}
	keycode = null;
l1:	/* end popInteger */;
	if (!primFailCode) {
		interruptKeycode = keycode;
	} else {
		/* begin unPop: */
		stackPointer += 1 * (BYTES_PER_WORD);
	}
	return null;
}


/*	Treat the receiver, which can be indexible by either bytes or words, as an array of signed 16-bit values. Return the contents of the given index. Note that the index specifies the i-th 16-bit entry, not the i-th byte or word. */

sqInt primitiveShortAt(void) {
    sqInt addr;
    sqInt index;
    sqInt rcvr;
    sqInt sz;
    sqInt value;
    sqInt sp;
    sqInt successBoolean;
    sqInt successBoolean1;
    sqInt integerPointer;

	/* begin stackIntegerValue: */
	integerPointer = longAt(stackPointer - (0 * (BYTES_PER_WORD)));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		index = (integerPointer >> 1);
		goto l1;
	} else {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		index = 0;
		goto l1;
	}
	index = null;
l1:	/* end stackIntegerValue: */;
	rcvr = longAt(stackPointer - (1 * (BYTES_PER_WORD)));
	/* begin success: */
	successBoolean = (!((rcvr & 1))) && (((rcvr & 1) == 0) && (isWordsOrBytesNonInt(rcvr)));
	if (!(successBoolean)) {
		if (!primFailCode) {
			primFailCode = 1;
		}
	}
	if (!(!primFailCode)) {
		return null;
	}

	/* number of 16-bit fields */

	sz = ((sqInt) ((sizeBitsOf(rcvr)) - (BASE_HEADER_SIZE)) >> 1);
	/* begin success: */
	successBoolean1 = (index >= 1) && (index <= sz);
	if (!(successBoolean1)) {
		if (!primFailCode) {
			primFailCode = 1;
		}
	}
	if (!primFailCode) {
		addr = (rcvr + (BASE_HEADER_SIZE)) + (2 * (index - 1));
		value = shortAt(addr);
		/* begin pop:thenPushInteger: */
		longAtput((sp = stackPointer - ((2 - 1) * (BYTES_PER_WORD))), ((value << 1) | 1));
		stackPointer = sp;
	}
	return null;
}


/*	Treat the receiver, which can be indexible by either bytes or words, as an array of signed 16-bit values. Set the contents of the given index to the given value. Note that the index specifies the i-th 16-bit entry, not the i-th byte or word. */

sqInt primitiveShortAtPut(void) {
    sqInt addr;
    sqInt index;
    sqInt rcvr;
    sqInt sz;
    sqInt value;
    sqInt successBoolean;
    sqInt successBoolean1;
    sqInt successBoolean2;
    sqInt integerPointer;
    sqInt integerPointer1;

	/* begin stackIntegerValue: */
	integerPointer = longAt(stackPointer - (0 * (BYTES_PER_WORD)));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		value = (integerPointer >> 1);
		goto l1;
	} else {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		value = 0;
		goto l1;
	}
	value = null;
l1:	/* end stackIntegerValue: */;
	/* begin stackIntegerValue: */
	integerPointer1 = longAt(stackPointer - (1 * (BYTES_PER_WORD)));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer1 & 1)) {
		index = (integerPointer1 >> 1);
		goto l2;
	} else {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		index = 0;
		goto l2;
	}
	index = null;
l2:	/* end stackIntegerValue: */;
	rcvr = longAt(stackPointer - (2 * (BYTES_PER_WORD)));
	/* begin success: */
	successBoolean = (!((rcvr & 1))) && (((rcvr & 1) == 0) && (isWordsOrBytesNonInt(rcvr)));
	if (!(successBoolean)) {
		if (!primFailCode) {
			primFailCode = 1;
		}
	}
	if (!(!primFailCode)) {
		return null;
	}

	/* number of 16-bit fields */

	sz = ((sqInt) ((sizeBitsOf(rcvr)) - (BASE_HEADER_SIZE)) >> 1);
	/* begin success: */
	successBoolean1 = (index >= 1) && (index <= sz);
	if (!(successBoolean1)) {
		if (!primFailCode) {
			primFailCode = 1;
		}
	}
	/* begin success: */
	successBoolean2 = (value >= -32768) && (value <= 32767);
	if (!(successBoolean2)) {
		if (!primFailCode) {
			primFailCode = 1;
		}
	}
	if (!primFailCode) {
		addr = (rcvr + (BASE_HEADER_SIZE)) + (2 * (index - 1));
		shortAtput(addr, value);
		/* begin pop: */
		stackPointer -= 2 * (BYTES_PER_WORD);
	}
	return null;
}


/*	Force the given rectangular section of the Display to be 
	copied to the screen. */

sqInt primitiveShowDisplayRect(void) {
    sqInt bottom;
    sqInt left;
    sqInt right;
    sqInt top;
    sqInt integerPointer;
    sqInt integerPointer1;
    sqInt integerPointer2;
    sqInt integerPointer3;

	/* begin stackIntegerValue: */
	integerPointer = longAt(stackPointer - (0 * (BYTES_PER_WORD)));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		bottom = (integerPointer >> 1);
		goto l1;
	} else {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		bottom = 0;
		goto l1;
	}
	bottom = null;
l1:	/* end stackIntegerValue: */;
	/* begin stackIntegerValue: */
	integerPointer1 = longAt(stackPointer - (1 * (BYTES_PER_WORD)));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer1 & 1)) {
		top = (integerPointer1 >> 1);
		goto l2;
	} else {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		top = 0;
		goto l2;
	}
	top = null;
l2:	/* end stackIntegerValue: */;
	/* begin stackIntegerValue: */
	integerPointer2 = longAt(stackPointer - (2 * (BYTES_PER_WORD)));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer2 & 1)) {
		right = (integerPointer2 >> 1);
		goto l3;
	} else {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		right = 0;
		goto l3;
	}
	right = null;
l3:	/* end stackIntegerValue: */;
	/* begin stackIntegerValue: */
	integerPointer3 = longAt(stackPointer - (3 * (BYTES_PER_WORD)));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer3 & 1)) {
		left = (integerPointer3 >> 1);
		goto l4;
	} else {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		left = 0;
		goto l4;
	}
	left = null;
l4:	/* end stackIntegerValue: */;
	displayBitsOfLeftTopRightBottom(longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (TheDisplay << (SHIFT_FOR_WORD))), left, top, right, bottom);
	if (!primFailCode) {
		ioForceDisplayUpdate();
		/* begin pop: */
		stackPointer -= 4 * (BYTES_PER_WORD);
	}
	return null;
}


/*	synchromously signal the semaphore. This may change the active process as a result */

sqInt primitiveSignal(void) {
    sqInt sema;
    sqInt classOop;
    sqInt ccIndex;
    sqInt cl;
    sqInt oop1;


	/* rcvr */

	sema = longAt(stackPointer);
	/* begin assertClassOf:is: */
	classOop = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassSemaphore << (SHIFT_FOR_WORD)));
	if ((sema & 1)) {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		goto l1;
	}
	ccIndex = (((usqInt) (longAt(sema))) >> 12) & 31;
	if (ccIndex == 0) {
		cl = (longAt(sema - (BASE_HEADER_SIZE))) & (ALL_BUT_TYPE_MASK);
	} else {
		/* begin fetchPointer:ofObject: */
		oop1 = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (CompactClasses << (SHIFT_FOR_WORD)));
		cl = longAt((oop1 + (BASE_HEADER_SIZE)) + ((ccIndex - 1) << (SHIFT_FOR_WORD)));
	}
	/* begin success: */
	if (!(cl == classOop)) {
		if (!primFailCode) {
			primFailCode = 1;
		}
	}
l1:	/* end assertClassOf:is: */;
	if (!primFailCode) {
		synchronousSignal(sema);
	}
	return null;
}


/*	Set the low-water mark for free space. When the free space 
	falls below this level, the new and new: primitives fail and 
	system attempts to allocate space (e.g., to create a method 
	context) cause the low-space semaphore (if one is 
	registered) to be signalled. */

sqInt primitiveSignalAtBytesLeft(void) {
    sqInt bytes;
    sqInt integerPointer;
    sqInt top;

	/* begin popInteger */
	/* begin popStack */
	top = longAt(stackPointer);
	stackPointer -= BYTES_PER_WORD;
	integerPointer = top;
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		bytes = (integerPointer >> 1);
		goto l1;
	} else {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		bytes = 0;
		goto l1;
	}
	bytes = null;
l1:	/* end popInteger */;
	if (!primFailCode) {
		/* begin setLowSpaceThreshold: */
		lowSpaceThreshold = bytes;
	} else {
		/* begin setLowSpaceThreshold: */
		lowSpaceThreshold = 0;
		/* begin unPop: */
		stackPointer += 1 * (BYTES_PER_WORD);
	}
	return null;
}


/*	Cause the time semaphore, if one has been registered, to
	be signalled when the millisecond clock is greater than or
	equal to the given tick value. A tick value of zero turns off
	timer interrupts. */

void primitiveSignalAtMilliseconds(void) {
    sqInt sema;
    sqInt tick;
    sqInt integerPointer;
    sqInt top;
    sqInt top1;

	/* begin popInteger */
	/* begin popStack */
	top = longAt(stackPointer);
	stackPointer -= BYTES_PER_WORD;
	integerPointer = top;
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		tick = (integerPointer >> 1);
		goto l1;
	} else {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		tick = 0;
		goto l1;
	}
	tick = null;
l1:	/* end popInteger */;
	/* begin popStack */
	top1 = longAt(stackPointer);
	stackPointer -= BYTES_PER_WORD;
	sema = top1;
	if (!primFailCode) {
		if ((fetchClassOf(sema)) == (longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassSemaphore << (SHIFT_FOR_WORD))))) {
			/* begin storePointer:ofObject:withValue: */
			if ((((usqInt) specialObjectsOop)) < (((usqInt) youngStart))) {
				possibleRootStoreIntovalue(specialObjectsOop, sema);
			}
			longAtput((specialObjectsOop + (BASE_HEADER_SIZE)) + (TheTimerSemaphore << (SHIFT_FOR_WORD)), sema);
			nextWakeupTick = tick;
		} else {
			/* begin storePointer:ofObject:withValue: */
			if ((((usqInt) specialObjectsOop)) < (((usqInt) youngStart))) {
				possibleRootStoreIntovalue(specialObjectsOop, nilObj);
			}
			longAtput((specialObjectsOop + (BASE_HEADER_SIZE)) + (TheTimerSemaphore << (SHIFT_FOR_WORD)), nilObj);
			nextWakeupTick = 0;
		}
	} else {
		/* begin unPop: */
		stackPointer += 2 * (BYTES_PER_WORD);
	}
}

sqInt primitiveSine(void) {
    double rcvr;

	rcvr = popFloat();
	if (!primFailCode) {
		pushFloat(sin(rcvr));
	} else {
		/* begin unPop: */
		stackPointer += 1 * (BYTES_PER_WORD);
	}
	return null;
}

sqInt primitiveSize(void) {
    sqInt rcvr;
    sqInt sz;
    sqInt oop;
    sqInt sp;

	rcvr = longAt(stackPointer);
	if ((rcvr & 1)) {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		return null;
	}
	if (((((usqInt) (longAt(rcvr))) >> 8) & 15) < 2) {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		return null;
	}
	sz = stSizeOf(rcvr);
	if (!primFailCode) {
		/* begin pop:thenPush: */
		oop = positive32BitIntegerFor(sz);
		longAtput((sp = stackPointer - (((argumentCount + 1) - 1) * (BYTES_PER_WORD))), oop);
		stackPointer = sp;
	}
	return null;
}


/*	save a normal snapshot under the same name as it was loaded unless it has been renamed by the last primitiveImageName */

sqInt primitiveSnapshot(void) {
	snapshot(0);
	return null;
}


/*	save an embedded snapshot */

sqInt primitiveSnapshotEmbedded(void) {
	snapshot(1);
	return null;
}

sqInt primitiveSomeInstance(void) {
    sqInt class;
    sqInt instance;
    sqInt sp;
    sqInt thisClass;
    sqInt thisObj;
    sqInt obj;
    sqInt sz;
    sqInt header;
    sqInt ccIndex;
    sqInt oop1;
    sqInt sz1;
    sqInt header1;
    sqInt obj1;
    sqInt sz2;
    sqInt header2;

	class = longAt(stackPointer);
	/* begin initialInstanceOf: */
	/* begin firstAccessibleObject */
	obj1 = memory + (headerTypeBytes[(longAt(memory)) & TypeMask]);
	while ((((usqInt) obj1)) < (((usqInt) endOfMemory))) {
		if (!(((longAt(obj1)) & TypeMask) == HeaderTypeFree)) {
			thisObj = obj1;
			goto l6;
		}
		/* begin objectAfter: */
		if (DoAssertionChecks) {
			if ((((usqInt) obj1)) >= (((usqInt) endOfMemory))) {
				error("no objects after the end of memory");
			}
		}
		if (((longAt(obj1)) & TypeMask) == HeaderTypeFree) {
			sz2 = (longAt(obj1)) & (ALL_BUT_TYPE_MASK);
		} else {
			/* begin sizeBitsOf: */
			header2 = longAt(obj1);
			if ((header2 & TypeMask) == HeaderTypeSizeAndClass) {
				sz2 = (longAt(obj1 - ((BYTES_PER_WORD) * 2))) & (LONG_SIZE_MASK);
				goto l7;
			} else {
				sz2 = header2 & (SIZE_MASK);
				goto l7;
			}
		l7:	/* end sizeBitsOf: */;
		}
		obj1 = (obj1 + sz2) + (headerTypeBytes[(longAt(obj1 + sz2)) & TypeMask]);
	}
	error("heap is empty");
l6:	/* end firstAccessibleObject */;
	while (!(thisObj == null)) {
		/* begin fetchClassOf: */
		if ((thisObj & 1)) {
			thisClass = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassInteger << (SHIFT_FOR_WORD)));
			goto l4;
		}
		ccIndex = (((usqInt) (longAt(thisObj))) >> 12) & 31;
		if (ccIndex == 0) {
			thisClass = (longAt(thisObj - (BASE_HEADER_SIZE))) & (ALL_BUT_TYPE_MASK);
			goto l4;
		} else {
			/* begin fetchPointer:ofObject: */
			oop1 = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (CompactClasses << (SHIFT_FOR_WORD)));
			thisClass = longAt((oop1 + (BASE_HEADER_SIZE)) + ((ccIndex - 1) << (SHIFT_FOR_WORD)));
			goto l4;
		}
	l4:	/* end fetchClassOf: */;
		if (thisClass == class) {
			instance = thisObj;
			goto l1;
		}
		/* begin accessibleObjectAfter: */
		/* begin objectAfter: */
		if (DoAssertionChecks) {
			if ((((usqInt) thisObj)) >= (((usqInt) endOfMemory))) {
				error("no objects after the end of memory");
			}
		}
		if (((longAt(thisObj)) & TypeMask) == HeaderTypeFree) {
			sz1 = (longAt(thisObj)) & (ALL_BUT_TYPE_MASK);
		} else {
			/* begin sizeBitsOf: */
			header1 = longAt(thisObj);
			if ((header1 & TypeMask) == HeaderTypeSizeAndClass) {
				sz1 = (longAt(thisObj - ((BYTES_PER_WORD) * 2))) & (LONG_SIZE_MASK);
				goto l5;
			} else {
				sz1 = header1 & (SIZE_MASK);
				goto l5;
			}
		l5:	/* end sizeBitsOf: */;
		}
		obj = (thisObj + sz1) + (headerTypeBytes[(longAt(thisObj + sz1)) & TypeMask]);
		while ((((usqInt) obj)) < (((usqInt) endOfMemory))) {
			if (!(((longAt(obj)) & TypeMask) == HeaderTypeFree)) {
				thisObj = obj;
				goto l2;
			}
			/* begin objectAfter: */
			if (DoAssertionChecks) {
				if ((((usqInt) obj)) >= (((usqInt) endOfMemory))) {
					error("no objects after the end of memory");
				}
			}
			if (((longAt(obj)) & TypeMask) == HeaderTypeFree) {
				sz = (longAt(obj)) & (ALL_BUT_TYPE_MASK);
			} else {
				/* begin sizeBitsOf: */
				header = longAt(obj);
				if ((header & TypeMask) == HeaderTypeSizeAndClass) {
					sz = (longAt(obj - ((BYTES_PER_WORD) * 2))) & (LONG_SIZE_MASK);
					goto l3;
				} else {
					sz = header & (SIZE_MASK);
					goto l3;
				}
			l3:	/* end sizeBitsOf: */;
			}
			obj = (obj + sz) + (headerTypeBytes[(longAt(obj + sz)) & TypeMask]);
		}
		thisObj = null;
	l2:	/* end accessibleObjectAfter: */;
	}
	instance = nilObj;
l1:	/* end initialInstanceOf: */;
	if (instance == nilObj) {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
	} else {
		/* begin pop:thenPush: */
		longAtput((sp = stackPointer - (((argumentCount + 1) - 1) * (BYTES_PER_WORD))), instance);
		stackPointer = sp;
	}
	return null;
}


/*	Return the first object in the heap. */

sqInt primitiveSomeObject(void) {
    sqInt object;
    sqInt sp;
    sqInt obj;
    sqInt sz;
    sqInt header;

	/* begin pop: */
	stackPointer -= (argumentCount + 1) * (BYTES_PER_WORD);
	/* begin push: */
	/* begin firstAccessibleObject */
	obj = memory + (headerTypeBytes[(longAt(memory)) & TypeMask]);
	while ((((usqInt) obj)) < (((usqInt) endOfMemory))) {
		if (!(((longAt(obj)) & TypeMask) == HeaderTypeFree)) {
			object = obj;
			goto l1;
		}
		/* begin objectAfter: */
		if (DoAssertionChecks) {
			if ((((usqInt) obj)) >= (((usqInt) endOfMemory))) {
				error("no objects after the end of memory");
			}
		}
		if (((longAt(obj)) & TypeMask) == HeaderTypeFree) {
			sz = (longAt(obj)) & (ALL_BUT_TYPE_MASK);
		} else {
			/* begin sizeBitsOf: */
			header = longAt(obj);
			if ((header & TypeMask) == HeaderTypeSizeAndClass) {
				sz = (longAt(obj - ((BYTES_PER_WORD) * 2))) & (LONG_SIZE_MASK);
				goto l2;
			} else {
				sz = header & (SIZE_MASK);
				goto l2;
			}
		l2:	/* end sizeBitsOf: */;
		}
		obj = (obj + sz) + (headerTypeBytes[(longAt(obj + sz)) & TypeMask]);
	}
	error("heap is empty");
l1:	/* end firstAccessibleObject */;
	longAtput((sp = stackPointer + (BYTES_PER_WORD)), object);
	stackPointer = sp;
	return null;
}


/*	Return the oop of the SpecialObjectsArray. */

sqInt primitiveSpecialObjectsOop(void) {
    sqInt sp;

	/* begin pop:thenPush: */
	longAtput((sp = stackPointer - ((1 - 1) * (BYTES_PER_WORD))), specialObjectsOop);
	stackPointer = sp;
	return null;
}

sqInt primitiveSquareRoot(void) {
    double rcvr;

	rcvr = popFloat();
	/* begin success: */
	if (!(rcvr >= 0.0)) {
		if (!primFailCode) {
			primFailCode = 1;
		}
	}
	if (!primFailCode) {
		pushFloat(sqrt(rcvr));
	} else {
		/* begin unPop: */
		stackPointer += 1 * (BYTES_PER_WORD);
	}
	return null;
}


/*	This primitive is called from Squeak as...
		<imageSegment> storeSegmentFor: arrayOfRoots into: aWordArray outPointers: anArray. */
/*	This primitive will store a binary image segment (in the same format as the Squeak image file) of the receiver and every object in its proper tree of subParts (ie, that is not refered to from anywhere else outside the tree).  All pointers from within the tree to objects outside the tree will be copied into the array of outpointers.  In their place in the image segment will be an oop equal to the offset in the outPointer array (the first would be 4). but with the high bit set. */
/*	The primitive expects the array and wordArray to be more than adequately long.  In this case it returns normally, and truncates the two arrays to exactly the right size.  To simplify truncation, both incoming arrays are required to be 256 bytes or more long (ie with 3-word headers).  If either array is too small, the primitive will fail, but in no other case.

During operation of the primitive, it is necessary to convert from both internal and external oops to their mapped values.  To make this fast, the headers of the original objects in question are replaced by the mapped values (and this is noted by adding the forbidden XX header type).  Tables are kept of both kinds of oops, as well as of the original headers for restoration.

To be specific, there are two similar two-part tables, the outpointer array, and one in the upper fifth of the segmentWordArray.  Each grows oops from the bottom up, and preserved headers from halfway up.

In case of either success or failure, the headers must be restored.  In the event of primitive failure, the table of outpointers must also be nilled out (since the garbage in the high half will not have been discarded. */

sqInt primitiveStoreImageSegment(void) {
    sqInt arrayOfRoots;
    sqInt doingClass;
    usqInt endSeg;
    sqInt extraSize;
    sqInt fieldOop;
    usqInt fieldPtr;
    usqInt firstIn;
    usqInt firstOut;
    usqInt hdrBaseIn;
    usqInt hdrBaseOut;
    sqInt hdrTypeBits;
    sqInt header;
    usqInt lastIn;
    usqInt lastOut;
    usqInt lastPtr;
    usqInt lastSeg;
    sqInt mapOop;
    sqInt outPointerArray;
    usqInt savedYoungStart;
    usqInt segOop;
    sqInt segmentWordArray;
    sqInt versionOffset;
    sqInt i;
    sqInt lastAddr;
    sqInt i1;
    sqInt lastAddr1;
    sqInt i2;
    sqInt lastAddr2;
    sqInt i3;
    sqInt lastAddr3;
    sqInt in;
    sqInt lastIn1;
    sqInt out;
    sqInt in1;
    sqInt lastIn2;
    sqInt out1;
    sqInt sz;
    sqInt header1;

	outPointerArray = longAt(stackPointer);
	segmentWordArray = longAt(stackPointer - (1 * (BYTES_PER_WORD)));

	/* Essential type checks */

	arrayOfRoots = longAt(stackPointer - (2 * (BYTES_PER_WORD)));
	if (!((((((usqInt) (longAt(arrayOfRoots))) >> 8) & 15) == 2) && ((((((usqInt) (longAt(outPointerArray))) >> 8) & 15) == 2) && (((((usqInt) (longAt(segmentWordArray))) >> 8) & 15) == 6)))) {

		/* Must be indexable words */

		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		return null;
	}
	if (!((((longAt(outPointerArray)) & TypeMask) == HeaderTypeSizeAndClass) && (((longAt(segmentWordArray)) & TypeMask) == HeaderTypeSizeAndClass))) {

		/* Must be 3-word header */

		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		return null;
	}
	if (DoAssertionChecks) {
		verifyCleanHeaders();
	}
	firstOut = outPointerArray + (BASE_HEADER_SIZE);
	lastOut = firstOut - (BYTES_PER_WORD);

	/* top half */

	hdrBaseOut = outPointerArray + (((lastPointerOf(outPointerArray)) / ((BYTES_PER_WORD) * 2)) * (BYTES_PER_WORD));
	lastSeg = segmentWordArray;

	/* Write a version number for byte order and version check */

	endSeg = (segmentWordArray + (sizeBitsOf(segmentWordArray))) - (BYTES_PER_WORD);
	versionOffset = BYTES_PER_WORD;
	lastSeg += versionOffset;
	if (lastSeg > endSeg) {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		return null;
	}
	longAtput(lastSeg, imageSegmentVersion());

	/* Take 1/8 of seg */

	firstIn = endSeg - (((sizeBitsOf(segmentWordArray)) / ((BYTES_PER_WORD) * 8)) * (BYTES_PER_WORD));
	lastIn = firstIn - (BYTES_PER_WORD);

	/* top half of that */
	/* First mark the rootArray and all root objects. */

	hdrBaseIn = firstIn + (((sizeBitsOf(segmentWordArray)) / ((BYTES_PER_WORD) * 16)) * (BYTES_PER_WORD));
	longAtput(arrayOfRoots, (longAt(arrayOfRoots)) | (MARK_BIT));
	lastPtr = arrayOfRoots + (lastPointerOf(arrayOfRoots));
	fieldPtr = arrayOfRoots + (BASE_HEADER_SIZE);
	while (fieldPtr <= lastPtr) {
		fieldOop = longAt(fieldPtr);
		if (!((fieldOop & 1))) {
			longAtput(fieldOop, (longAt(fieldOop)) | (MARK_BIT));
		}
		fieldPtr += BYTES_PER_WORD;
	}
	savedYoungStart = youngStart;
	/* begin setYoungStart: */
	youngStart = memory;
	/* begin setFreeContexts: */
	freeContexts = NilContext;
	/* begin setFreeLargeContexts: */
	freeLargeContexts = NilContext;
	markAndTraceInterpreterOops(1);
	/* begin setYoungStart: */
	youngStart = savedYoungStart;
	longAtput(arrayOfRoots, (longAt(arrayOfRoots)) & (ALL_BUT_MARK_BIT));
	fieldPtr = arrayOfRoots + (BASE_HEADER_SIZE);
	while (fieldPtr <= lastPtr) {
		fieldOop = longAt(fieldPtr);
		if (!((fieldOop & 1))) {
			longAtput(fieldOop, (longAt(fieldOop)) & (ALL_BUT_MARK_BIT));
		}
		fieldPtr += BYTES_PER_WORD;
	}
	lastIn += BYTES_PER_WORD;
	if (lastIn >= hdrBaseIn) {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
	}
	lastSeg = copyObjtoSegmentaddrstopAtsaveOopAtheaderAt(arrayOfRoots, segmentWordArray, lastSeg, firstIn, lastIn, hdrBaseIn + (lastIn - firstIn));
	if (!(!primFailCode)) {
		lastIn -= BYTES_PER_WORD;
		restoreHeadersFromtofromandtofrom(firstIn, lastIn, hdrBaseIn, firstOut, lastOut, hdrBaseOut);
		/* begin primitiveFailAfterCleanup: */
		lastAddr = outPointerArray + (lastPointerOf(outPointerArray));
		i = outPointerArray + (BASE_HEADER_SIZE);
		while (i <= lastAddr) {
			longAtput(i, nilObj);
			i += BYTES_PER_WORD;
		}
		if (DoAssertionChecks) {
			verifyCleanHeaders();
		}
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		return null;
	}
	segOop = ((segmentWordArray + versionOffset) + (BASE_HEADER_SIZE)) + (headerTypeBytes[(longAt((segmentWordArray + versionOffset) + (BASE_HEADER_SIZE))) & TypeMask]);
	while (segOop <= lastSeg) {
		if (((longAt(segOop)) & TypeMask) <= 1) {

			/* This object has a class field (type=0 or 1) -- start with that. */

			fieldPtr = segOop - (BYTES_PER_WORD);
			doingClass = 1;
		} else {

			/* No class field -- start with first data field */

			fieldPtr = segOop + (BASE_HEADER_SIZE);
			doingClass = 0;
		}

		/* last field */
		/* Go through all oops, remapping them... */

		lastPtr = segOop + (lastPointerOf(segOop));
		while (!(fieldPtr > lastPtr)) {

			/* Examine each pointer field */

			fieldOop = longAt(fieldPtr);
			if (doingClass) {
				hdrTypeBits = fieldOop & TypeMask;
				fieldOop -= hdrTypeBits;
			}
			if ((fieldOop & 1)) {

				/* Just an integer -- nothing to do */

				fieldPtr += BYTES_PER_WORD;
			} else {
				header = longAt(fieldOop);
				if ((header & TypeMask) == HeaderTypeFree) {

					/* Has already been forwarded -- this is the link */

					mapOop = header & (ALL_BUT_TYPE_MASK);
				} else {
					if (((longAt(fieldOop)) & (MARK_BIT)) == 0) {

						/* Points to an unmarked obj -- an internal pointer.
							Copy the object into the segment, and forward its oop. */

						lastIn += BYTES_PER_WORD;
						if (lastIn >= hdrBaseIn) {
							/* begin primitiveFail */
							if (primFailCode == 0) {
								primFailCode = 1;
							}
						}
						lastSeg = copyObjtoSegmentaddrstopAtsaveOopAtheaderAt(fieldOop, segmentWordArray, lastSeg, firstIn, lastIn, hdrBaseIn + (lastIn - firstIn));
						if (!(!primFailCode)) {

							/* Out of space in segment */

							lastIn -= BYTES_PER_WORD;
							restoreHeadersFromtofromandtofrom(firstIn, lastIn, hdrBaseIn, firstOut, lastOut, hdrBaseOut);
							/* begin primitiveFailAfterCleanup: */
							lastAddr1 = outPointerArray + (lastPointerOf(outPointerArray));
							i1 = outPointerArray + (BASE_HEADER_SIZE);
							while (i1 <= lastAddr1) {
								longAtput(i1, nilObj);
								i1 += BYTES_PER_WORD;
							}
							if (DoAssertionChecks) {
								verifyCleanHeaders();
							}
							/* begin primitiveFail */
							if (primFailCode == 0) {
								primFailCode = 1;
							}
							return null;
						}
						mapOop = (longAt(fieldOop)) & (ALL_BUT_TYPE_MASK);
					} else {

						/* Points to a marked obj -- an external pointer.
							Map it as a tagged index in outPointers, and forward its oop. */

						lastOut += BYTES_PER_WORD;
						if (lastOut >= hdrBaseOut) {

							/* Out of space in outPointerArray */

							lastOut -= BYTES_PER_WORD;
							restoreHeadersFromtofromandtofrom(firstIn, lastIn, hdrBaseIn, firstOut, lastOut, hdrBaseOut);
							/* begin primitiveFailAfterCleanup: */
							lastAddr2 = outPointerArray + (lastPointerOf(outPointerArray));
							i2 = outPointerArray + (BASE_HEADER_SIZE);
							while (i2 <= lastAddr2) {
								longAtput(i2, nilObj);
								i2 += BYTES_PER_WORD;
							}
							if (DoAssertionChecks) {
								verifyCleanHeaders();
							}
							/* begin primitiveFail */
							if (primFailCode == 0) {
								primFailCode = 1;
							}
							return null;
						}
						mapOop = (lastOut - outPointerArray) | 2147483648U;
						/* begin forward:to:savingOopAt:andHeaderAt: */
						longAtput(lastOut, fieldOop);
						longAtput(hdrBaseOut + (lastOut - firstOut), longAt(fieldOop));
						longAtput(fieldOop, mapOop + HeaderTypeFree);
					}
				}
				if (doingClass) {
					longAtput(fieldPtr, mapOop + hdrTypeBits);
					fieldPtr += (BYTES_PER_WORD) * 2;
					doingClass = 0;
				} else {
					longAtput(fieldPtr, mapOop);
					fieldPtr += BYTES_PER_WORD;
				}
			}
		}
		/* begin objectAfter: */
		if (DoAssertionChecks) {
			if ((((usqInt) segOop)) >= (((usqInt) endOfMemory))) {
				error("no objects after the end of memory");
			}
		}
		if (((longAt(segOop)) & TypeMask) == HeaderTypeFree) {
			sz = (longAt(segOop)) & (ALL_BUT_TYPE_MASK);
		} else {
			/* begin sizeBitsOf: */
			header1 = longAt(segOop);
			if ((header1 & TypeMask) == HeaderTypeSizeAndClass) {
				sz = (longAt(segOop - ((BYTES_PER_WORD) * 2))) & (LONG_SIZE_MASK);
				goto l1;
			} else {
				sz = header1 & (SIZE_MASK);
				goto l1;
			}
		l1:	/* end sizeBitsOf: */;
		}
		segOop = (segOop + sz) + (headerTypeBytes[(longAt(segOop + sz)) & TypeMask]);
	}
	restoreHeadersFromtofromandtofrom(firstIn, lastIn, hdrBaseIn, firstOut, lastOut, hdrBaseOut);
	if ((((outPointerArray + (lastPointerOf(outPointerArray))) - lastOut) < 12) || ((endSeg - lastSeg) < 12)) {

		/* Not enough room to insert simple 3-word headers */

		/* begin primitiveFailAfterCleanup: */
		lastAddr3 = outPointerArray + (lastPointerOf(outPointerArray));
		i3 = outPointerArray + (BASE_HEADER_SIZE);
		while (i3 <= lastAddr3) {
			longAtput(i3, nilObj);
			i3 += BYTES_PER_WORD;
		}
		if (DoAssertionChecks) {
			verifyCleanHeaders();
		}
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		return null;
	}
	extraSize = headerTypeBytes[(longAt(segmentWordArray)) & TypeMask];

	/* Copy the 3-word wordArray header to establish a free chunk. */

	hdrTypeBits = (longAt(segmentWordArray)) & TypeMask;
	/* begin transfer:from:to: */
	flag("Dan");
	in = (segmentWordArray - extraSize) - (BYTES_PER_WORD);
	lastIn1 = in + (3 * (BYTES_PER_WORD));
	out = (lastOut + (BYTES_PER_WORD)) - (BYTES_PER_WORD);
	while ((((usqInt) in)) < (((usqInt) lastIn1))) {
		longAtput((out += BYTES_PER_WORD), longAt((in += BYTES_PER_WORD)));
	}
	longAtput(lastOut + (BYTES_PER_WORD), (((outPointerArray + (lastPointerOf(outPointerArray))) - lastOut) - extraSize) + hdrTypeBits);
	longAtput(outPointerArray - extraSize, ((lastOut - firstOut) + ((BYTES_PER_WORD) * 2)) + hdrTypeBits);
	beRootIfOld(outPointerArray);
	/* begin transfer:from:to: */
	flag("Dan");
	in1 = (segmentWordArray - extraSize) - (BYTES_PER_WORD);
	lastIn2 = in1 + (3 * (BYTES_PER_WORD));
	out1 = (lastSeg + (BYTES_PER_WORD)) - (BYTES_PER_WORD);
	while ((((usqInt) in1)) < (((usqInt) lastIn2))) {
		longAtput((out1 += BYTES_PER_WORD), longAt((in1 += BYTES_PER_WORD)));
	}
	longAtput(segmentWordArray - extraSize, ((lastSeg - segmentWordArray) + (BASE_HEADER_SIZE)) + hdrTypeBits);
	longAtput(lastSeg + (BYTES_PER_WORD), ((endSeg - lastSeg) - extraSize) + hdrTypeBits);
	if (DoAssertionChecks) {
		verifyCleanHeaders();
	}
	/* begin pop: */
	stackPointer -= 3 * (BYTES_PER_WORD);
	return null;
}


/*	Atomic store into context stackPointer. 
	Also ensures that any newly accessible cells are initialized to nil  */

void primitiveStoreStackp(void) {
    sqInt ctxt;
    sqInt i;
    sqInt newStackp;
    sqInt stackp;
    sqInt sp;
    sqInt successBoolean;
    sqInt integerPointer;
    sqInt otherOop;

	ctxt = longAt(stackPointer - (1 * (BYTES_PER_WORD)));
	/* begin stackIntegerValue: */
	integerPointer = longAt(stackPointer - (0 * (BYTES_PER_WORD)));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		newStackp = (integerPointer >> 1);
		goto l2;
	} else {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		newStackp = 0;
		goto l2;
	}
	newStackp = null;
l2:	/* end stackIntegerValue: */;
	/* begin success: */
	if (!((((usqInt) newStackp)) >= (((usqInt) 0)))) {
		if (!primFailCode) {
			primFailCode = 1;
		}
	}
	/* begin success: */
	/* begin oop:isLessThanOrEqualTo: */
	otherOop = (((LARGE_CONTEXT_SIZE) - (BASE_HEADER_SIZE)) / (BYTES_PER_WORD)) - CtxtTempFrameStart;
	successBoolean = (((usqInt) newStackp)) <= (((usqInt) otherOop));
	if (!(successBoolean)) {
		if (!primFailCode) {
			primFailCode = 1;
		}
	}
	if (!(!primFailCode)) {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		return;
	}
	/* begin fetchStackPointerOf: */
	sp = longAt((ctxt + (BASE_HEADER_SIZE)) + (StackPointerIndex << (SHIFT_FOR_WORD)));
	if (!((sp & 1))) {
		stackp = 0;
		goto l1;
	}
	stackp = (sp >> 1);
l1:	/* end fetchStackPointerOf: */;
	if ((((usqInt) newStackp)) > (((usqInt) stackp))) {

		/* Nil any newly accessible cells */

		for (i = (stackp + 1); i <= newStackp; i += 1) {
			/* begin storePointer:ofObject:withValue: */
			if ((((usqInt) ctxt)) < (((usqInt) youngStart))) {
				possibleRootStoreIntovalue(ctxt, nilObj);
			}
			longAtput((ctxt + (BASE_HEADER_SIZE)) + (((i + CtxtTempFrameStart) - 1) << (SHIFT_FOR_WORD)), nilObj);
		}
	}
	/* begin storeStackPointerValue:inContext: */
	longAtput((ctxt + (BASE_HEADER_SIZE)) + (StackPointerIndex << (SHIFT_FOR_WORD)), ((newStackp << 1) | 1));
	/* begin pop: */
	stackPointer -= 1 * (BYTES_PER_WORD);
}

sqInt primitiveStringAt(void) {
	commonAt(1);
	return null;
}

sqInt primitiveStringAtPut(void) {
	commonAtPut(1);
	return null;
}


/*	 
	<array> primReplaceFrom: start to: stop with: replacement 
	startingAt: repStart  
	<primitive: 105>
	 */

sqInt primitiveStringReplace(void) {
    sqInt array;
    sqInt arrayFmt;
    sqInt arrayInstSize;
    sqInt hdr;
    sqInt i;
    sqInt repl;
    sqInt replFmt;
    sqInt replInstSize;
    sqInt replStart;
    sqInt srcIndex;
    sqInt start;
    sqInt stop;
    sqInt totalLength;
    sqInt valuePointer;
    sqInt valueWord;
    sqInt sz;
    sqInt class;
    sqInt classFormat;
    sqInt sz1;
    sqInt class1;
    sqInt classFormat1;
    sqInt integerPointer;
    sqInt integerPointer1;
    sqInt integerPointer2;
    sqInt ccIndex;
    sqInt oop1;
    sqInt ccIndex1;
    sqInt oop11;

	array = longAt(stackPointer - (4 * (BYTES_PER_WORD)));
	/* begin stackIntegerValue: */
	integerPointer = longAt(stackPointer - (3 * (BYTES_PER_WORD)));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		start = (integerPointer >> 1);
		goto l5;
	} else {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		start = 0;
		goto l5;
	}
	start = null;
l5:	/* end stackIntegerValue: */;
	/* begin stackIntegerValue: */
	integerPointer1 = longAt(stackPointer - (2 * (BYTES_PER_WORD)));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer1 & 1)) {
		stop = (integerPointer1 >> 1);
		goto l6;
	} else {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		stop = 0;
		goto l6;
	}
	stop = null;
l6:	/* end stackIntegerValue: */;
	repl = longAt(stackPointer - (1 * (BYTES_PER_WORD)));
	/* begin stackIntegerValue: */
	integerPointer2 = longAt(stackPointer - (0 * (BYTES_PER_WORD)));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer2 & 1)) {
		replStart = (integerPointer2 >> 1);
		goto l7;
	} else {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		replStart = 0;
		goto l7;
	}
	replStart = null;
l7:	/* end stackIntegerValue: */;
	if (!(!primFailCode)) {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		return null;
	}
	if ((repl & 1)) {

		/* can happen in LgInt copy */

		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		return null;
	}
	hdr = longAt(array);
	arrayFmt = (((usqInt) hdr) >> 8) & 15;
	/* begin lengthOf:baseHeader:format: */
	if ((hdr & TypeMask) == HeaderTypeSizeAndClass) {
		sz = (longAt(array - ((BYTES_PER_WORD) * 2))) & (LONG_SIZE_MASK);
	} else {
		sz = hdr & (SIZE_MASK);
	}
	sz -= hdr & (SIZE_4_BIT);
	if (arrayFmt <= 4) {
		totalLength = ((usqInt) (sz - (BASE_HEADER_SIZE))) >> (SHIFT_FOR_WORD);
		goto l1;
	}
	if (arrayFmt < 8) {
		totalLength = ((usqInt) (sz - (BASE_HEADER_SIZE))) >> 2;
		goto l1;
	} else {
		totalLength = (sz - (BASE_HEADER_SIZE)) - (arrayFmt & 3);
		goto l1;
	}
l1:	/* end lengthOf:baseHeader:format: */;
	/* begin fixedFieldsOf:format:length: */
	if ((arrayFmt > 4) || (arrayFmt == 2)) {
		arrayInstSize = 0;
		goto l2;
	}
	if (arrayFmt < 2) {
		arrayInstSize = totalLength;
		goto l2;
	}
	/* begin fetchClassOf: */
	if ((array & 1)) {
		class = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassInteger << (SHIFT_FOR_WORD)));
		goto l8;
	}
	ccIndex = (((usqInt) (longAt(array))) >> 12) & 31;
	if (ccIndex == 0) {
		class = (longAt(array - (BASE_HEADER_SIZE))) & (ALL_BUT_TYPE_MASK);
		goto l8;
	} else {
		/* begin fetchPointer:ofObject: */
		oop1 = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (CompactClasses << (SHIFT_FOR_WORD)));
		class = longAt((oop1 + (BASE_HEADER_SIZE)) + ((ccIndex - 1) << (SHIFT_FOR_WORD)));
		goto l8;
	}
l8:	/* end fetchClassOf: */;
	classFormat = (longAt((class + (BASE_HEADER_SIZE)) + (InstanceSpecificationIndex << (SHIFT_FOR_WORD)))) - 1;
	arrayInstSize = (((((usqInt) classFormat) >> 11) & 192) + ((((usqInt) classFormat) >> 2) & 63)) - 1;
l2:	/* end fixedFieldsOf:format:length: */;
	if (!((start >= 1) && (((start - 1) <= stop) && ((stop + arrayInstSize) <= totalLength)))) {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		return null;
	}
	hdr = longAt(repl);
	replFmt = (((usqInt) hdr) >> 8) & 15;
	/* begin lengthOf:baseHeader:format: */
	if ((hdr & TypeMask) == HeaderTypeSizeAndClass) {
		sz1 = (longAt(repl - ((BYTES_PER_WORD) * 2))) & (LONG_SIZE_MASK);
	} else {
		sz1 = hdr & (SIZE_MASK);
	}
	sz1 -= hdr & (SIZE_4_BIT);
	if (replFmt <= 4) {
		totalLength = ((usqInt) (sz1 - (BASE_HEADER_SIZE))) >> (SHIFT_FOR_WORD);
		goto l3;
	}
	if (replFmt < 8) {
		totalLength = ((usqInt) (sz1 - (BASE_HEADER_SIZE))) >> 2;
		goto l3;
	} else {
		totalLength = (sz1 - (BASE_HEADER_SIZE)) - (replFmt & 3);
		goto l3;
	}
l3:	/* end lengthOf:baseHeader:format: */;
	/* begin fixedFieldsOf:format:length: */
	if ((replFmt > 4) || (replFmt == 2)) {
		replInstSize = 0;
		goto l4;
	}
	if (replFmt < 2) {
		replInstSize = totalLength;
		goto l4;
	}
	/* begin fetchClassOf: */
	if ((repl & 1)) {
		class1 = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassInteger << (SHIFT_FOR_WORD)));
		goto l9;
	}
	ccIndex1 = (((usqInt) (longAt(repl))) >> 12) & 31;
	if (ccIndex1 == 0) {
		class1 = (longAt(repl - (BASE_HEADER_SIZE))) & (ALL_BUT_TYPE_MASK);
		goto l9;
	} else {
		/* begin fetchPointer:ofObject: */
		oop11 = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (CompactClasses << (SHIFT_FOR_WORD)));
		class1 = longAt((oop11 + (BASE_HEADER_SIZE)) + ((ccIndex1 - 1) << (SHIFT_FOR_WORD)));
		goto l9;
	}
l9:	/* end fetchClassOf: */;
	classFormat1 = (longAt((class1 + (BASE_HEADER_SIZE)) + (InstanceSpecificationIndex << (SHIFT_FOR_WORD)))) - 1;
	replInstSize = (((((usqInt) classFormat1) >> 11) & 192) + ((((usqInt) classFormat1) >> 2) & 63)) - 1;
l4:	/* end fixedFieldsOf:format:length: */;
	if (!((replStart >= 1) && ((((stop - start) + replStart) + replInstSize) <= totalLength))) {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		return null;
	}
	if (arrayFmt < 8) {
		if (!(arrayFmt == replFmt)) {
			/* begin primitiveFail */
			if (primFailCode == 0) {
				primFailCode = 1;
			}
			return null;
		}
	} else {
		if (!((arrayFmt & 12) == (replFmt & 12))) {
			/* begin primitiveFail */
			if (primFailCode == 0) {
				primFailCode = 1;
			}
			return null;
		}
	}

	/* - 1 for 0-based access */

	srcIndex = (replStart + replInstSize) - 1;
	if (arrayFmt <= 4) {

		/* pointer type objects */

		for (i = ((start + arrayInstSize) - 1); i <= ((stop + arrayInstSize) - 1); i += 1) {
			/* begin storePointer:ofObject:withValue: */
			valuePointer = longAt((repl + (BASE_HEADER_SIZE)) + (srcIndex << (SHIFT_FOR_WORD)));
			if ((((usqInt) array)) < (((usqInt) youngStart))) {
				possibleRootStoreIntovalue(array, valuePointer);
			}
			longAtput((array + (BASE_HEADER_SIZE)) + (i << (SHIFT_FOR_WORD)), valuePointer);
			srcIndex += 1;
		}
	} else {
		if (arrayFmt < 8) {

			/* 32-bit-word type objects */

			for (i = ((start + arrayInstSize) - 1); i <= ((stop + arrayInstSize) - 1); i += 1) {
				/* begin storeLong32:ofObject:withValue: */
				valueWord = long32At((repl + (BASE_HEADER_SIZE)) + (srcIndex << 2));
				long32Atput((array + (BASE_HEADER_SIZE)) + (i << 2), valueWord);
				srcIndex += 1;
			}
		} else {

			/* byte-type objects */

			for (i = ((start + arrayInstSize) - 1); i <= ((stop + arrayInstSize) - 1); i += 1) {
				byteAtput((array + (BASE_HEADER_SIZE)) + i, byteAt((repl + (BASE_HEADER_SIZE)) + srcIndex));
				srcIndex += 1;
			}
		}
	}
	/* begin pop: */
	stackPointer -= argumentCount * (BYTES_PER_WORD);
	return null;
}

sqInt primitiveSubtract(void) {
    sqInt integerResult;
    sqInt sp;

	/* begin pop2AndPushIntegerIfOK: */
	integerResult = (stackIntegerValue(1)) - (stackIntegerValue(0));
	if (!primFailCode) {
		if (
# ifdef SQ_HOST32  // cast to int for 64 bit image on 32 bit host
			(((((int) integerResult)) ^ ((((int) integerResult)) << 1)) >= 0)
# else
			((integerResult >= -1073741824) && (integerResult <= 1073741823))
# endif  // SQ_HOST32
		) {
			/* begin pop:thenPush: */
			longAtput((sp = stackPointer - ((2 - 1) * (BYTES_PER_WORD))), ((integerResult << 1) | 1));
			stackPointer = sp;
		} else {
			/* begin primitiveFail */
			if (primFailCode == 0) {
				primFailCode = 1;
			}
		}
	}
	return null;
}


/*	Primitive arithmetic operations for large integers in 64 bit range */

EXPORT(sqInt) primitiveSubtractLargeIntegers(void) {
    usqLong a;
    sqInt aIsNegative;
    usqLong b;
    sqInt bIsNegative;
    sqInt oopArg;
    sqInt oopRcvr;
    sqInt oopResult;
    usqLong result;
    sqInt resultIsNegative;
    sqInt sp;

	oopArg = longAt(stackPointer - (0 * (BYTES_PER_WORD)));
	oopRcvr = longAt(stackPointer - (1 * (BYTES_PER_WORD)));
	aIsNegative = isNegativeIntegerValueOf(oopRcvr);
	bIsNegative = isNegativeIntegerValueOf(oopArg);
	a = magnitude64BitValueOf(oopRcvr);
	b = magnitude64BitValueOf(oopArg);
	if (!(!primFailCode)) {
		return null;
	}
	if (aIsNegative != bIsNegative) {

		/* Protect against overflow */

		if (a > (18446744073709551615U - b)) {
			/* begin primitiveFail */
			if (primFailCode == 0) {
				primFailCode = 1;
			}
			return null;
		}
		result = a + b;
		resultIsNegative = aIsNegative;
	} else {
		if (a >= b) {
			result = a - b;
			resultIsNegative = aIsNegative;
		} else {
			result = b - a;
			resultIsNegative = !aIsNegative;
		}
	}
	oopResult = magnitude64BitIntegerForneg(result, resultIsNegative);
	if (!primFailCode) {
		/* begin pop:thenPush: */
		longAtput((sp = stackPointer - ((2 - 1) * (BYTES_PER_WORD))), oopResult);
		stackPointer = sp;
	}
	return null;
}


/*	Primitive. Suspend the receiver, aProcess such that it can be executed again
	by sending #resume. If the given process is not currently running, take it off
	its corresponding list. The primitive returns the list the receiver was previously on. */

sqInt primitiveSuspend(void) {
    sqInt activeProc;
    sqInt myList;
    sqInt process;
    sqInt sp;
    sqInt sp1;
    sqInt firstLink;
    sqInt lastLink;
    sqInt nextLink;
    sqInt tempLink;
    sqInt oop;
    sqInt oop1;

	process = longAt(stackPointer);
	/* begin fetchPointer:ofObject: */
	/* begin fetchPointer:ofObject: */
	oop1 = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (SchedulerAssociation << (SHIFT_FOR_WORD)));
	oop = longAt((oop1 + (BASE_HEADER_SIZE)) + (ValueIndex << (SHIFT_FOR_WORD)));
	activeProc = longAt((oop + (BASE_HEADER_SIZE)) + (ActiveProcessIndex << (SHIFT_FOR_WORD)));
	if (process == activeProc) {
		/* begin pop: */
		stackPointer -= 1 * (BYTES_PER_WORD);
		/* begin push: */
		longAtput((sp = stackPointer + (BYTES_PER_WORD)), nilObj);
		stackPointer = sp;
		transferTo(wakeHighestPriority());
	} else {

		/* XXXX Fixme. We should really check whether myList is a kind of LinkedList or not
		but we can't easily so just do a quick check for nil which is the most common case. */

		myList = longAt((process + (BASE_HEADER_SIZE)) + (MyListIndex << (SHIFT_FOR_WORD)));
		if (myList == nilObj) {
			/* begin primitiveFail */
			if (primFailCode == 0) {
				primFailCode = 1;
			}
			return null;
		}
		/* begin removeProcess:fromList: */
		firstLink = longAt((myList + (BASE_HEADER_SIZE)) + (FirstLinkIndex << (SHIFT_FOR_WORD)));
		lastLink = longAt((myList + (BASE_HEADER_SIZE)) + (LastLinkIndex << (SHIFT_FOR_WORD)));
		if (process == firstLink) {
			nextLink = longAt((process + (BASE_HEADER_SIZE)) + (NextLinkIndex << (SHIFT_FOR_WORD)));
			/* begin storePointer:ofObject:withValue: */
			if ((((usqInt) myList)) < (((usqInt) youngStart))) {
				possibleRootStoreIntovalue(myList, nextLink);
			}
			longAtput((myList + (BASE_HEADER_SIZE)) + (FirstLinkIndex << (SHIFT_FOR_WORD)), nextLink);
			if (process == lastLink) {
				/* begin storePointer:ofObject:withValue: */
				if ((((usqInt) myList)) < (((usqInt) youngStart))) {
					possibleRootStoreIntovalue(myList, nilObj);
				}
				longAtput((myList + (BASE_HEADER_SIZE)) + (LastLinkIndex << (SHIFT_FOR_WORD)), nilObj);
			}
		} else {
			tempLink = firstLink;
					while (1) {
				if (tempLink == nilObj) {
					/* begin success: */
					if (!(0)) {
						if (!primFailCode) {
							primFailCode = 1;
						}
					}
					goto l1;
				}
				nextLink = longAt((tempLink + (BASE_HEADER_SIZE)) + (NextLinkIndex << (SHIFT_FOR_WORD)));
				if (nextLink == process) break;
				tempLink = longAt((tempLink + (BASE_HEADER_SIZE)) + (NextLinkIndex << (SHIFT_FOR_WORD)));
			}
			nextLink = longAt((process + (BASE_HEADER_SIZE)) + (NextLinkIndex << (SHIFT_FOR_WORD)));
			/* begin storePointer:ofObject:withValue: */
			if ((((usqInt) tempLink)) < (((usqInt) youngStart))) {
				possibleRootStoreIntovalue(tempLink, nextLink);
			}
			longAtput((tempLink + (BASE_HEADER_SIZE)) + (NextLinkIndex << (SHIFT_FOR_WORD)), nextLink);
			if (process == lastLink) {
				/* begin storePointer:ofObject:withValue: */
				if ((((usqInt) myList)) < (((usqInt) youngStart))) {
					possibleRootStoreIntovalue(myList, tempLink);
				}
				longAtput((myList + (BASE_HEADER_SIZE)) + (LastLinkIndex << (SHIFT_FOR_WORD)), tempLink);
			}
		}
		/* begin storePointer:ofObject:withValue: */
		if ((((usqInt) process)) < (((usqInt) youngStart))) {
			possibleRootStoreIntovalue(process, nilObj);
		}
		longAtput((process + (BASE_HEADER_SIZE)) + (NextLinkIndex << (SHIFT_FOR_WORD)), nilObj);
	l1:	/* end removeProcess:fromList: */;
		if (!primFailCode) {
			/* begin storePointer:ofObject:withValue: */
			if ((((usqInt) process)) < (((usqInt) youngStart))) {
				possibleRootStoreIntovalue(process, nilObj);
			}
			longAtput((process + (BASE_HEADER_SIZE)) + (MyListIndex << (SHIFT_FOR_WORD)), nilObj);
			/* begin pop: */
			stackPointer -= 1 * (BYTES_PER_WORD);
			/* begin push: */
			longAtput((sp1 = stackPointer + (BYTES_PER_WORD)), myList);
			stackPointer = sp1;
		}
	}
	return null;
}


/*	Primitive. Terminate up the context stack from the receiver up to but not including the argument, if previousContext is on my Context stack. Make previousContext my sender. This prim has to shadow the code in ContextPart>terminateTo: to be correct */

void primitiveTerminateTo(void) {
    sqInt aContext;
    sqInt currentCntx;
    sqInt nextCntx;
    sqInt nilOop;
    sqInt thisCntx;
    sqInt top;
    sqInt top1;
    sqInt sp;

	/* begin popStack */
	top = longAt(stackPointer);
	stackPointer -= BYTES_PER_WORD;
	aContext = top;
	/* begin popStack */
	top1 = longAt(stackPointer);
	stackPointer -= BYTES_PER_WORD;
	thisCntx = top1;
	if (contexthasSender(thisCntx, aContext)) {
		nilOop = nilObj;
		currentCntx = longAt((thisCntx + (BASE_HEADER_SIZE)) + (SenderIndex << (SHIFT_FOR_WORD)));
		while (!(currentCntx == aContext)) {
			nextCntx = longAt((currentCntx + (BASE_HEADER_SIZE)) + (SenderIndex << (SHIFT_FOR_WORD)));
			/* begin storePointer:ofObject:withValue: */
			if ((((usqInt) currentCntx)) < (((usqInt) youngStart))) {
				possibleRootStoreIntovalue(currentCntx, nilOop);
			}
			longAtput((currentCntx + (BASE_HEADER_SIZE)) + (SenderIndex << (SHIFT_FOR_WORD)), nilOop);
			/* begin storePointer:ofObject:withValue: */
			if ((((usqInt) currentCntx)) < (((usqInt) youngStart))) {
				possibleRootStoreIntovalue(currentCntx, nilOop);
			}
			longAtput((currentCntx + (BASE_HEADER_SIZE)) + (InstructionPointerIndex << (SHIFT_FOR_WORD)), nilOop);
			currentCntx = nextCntx;
		}
	}
	/* begin storePointer:ofObject:withValue: */
	if ((((usqInt) thisCntx)) < (((usqInt) youngStart))) {
		possibleRootStoreIntovalue(thisCntx, aContext);
	}
	longAtput((thisCntx + (BASE_HEADER_SIZE)) + (SenderIndex << (SHIFT_FOR_WORD)), aContext);
	/* begin push: */
	longAtput((sp = stackPointer + (BYTES_PER_WORD)), thisCntx);
	stackPointer = sp;
	return;
}


/*	Return true if the host OS does support the given display depth. */

sqInt primitiveTestDisplayDepth(void) {
    sqInt bitsPerPixel;
    sqInt okay;
    sqInt sp;
    sqInt integerPointer;

	/* begin stackIntegerValue: */
	integerPointer = longAt(stackPointer - (0 * (BYTES_PER_WORD)));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		bitsPerPixel = (integerPointer >> 1);
		goto l1;
	} else {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		bitsPerPixel = 0;
		goto l1;
	}
	bitsPerPixel = null;
l1:	/* end stackIntegerValue: */;
	if (!primFailCode) {
		okay = ioHasDisplayDepth(bitsPerPixel);
	}
	if (!primFailCode) {
		/* begin pop:thenPushBool: */
		longAtput((sp = stackPointer - ((2 - 1) * (BYTES_PER_WORD))), (okay
			? trueObj
			: falseObj));
		stackPointer = sp;
	}
	return null;
}


/*	Given an object with indexable pointer fields, reduce the size of the indexable fields
	to the requested size. Answer the number of bytes freed, or zero if the object cannot
	be shortened. */

EXPORT(sqInt) primitiveTestShortenIndexableSize(void) {
    sqInt array;
    sqInt bytesFreed;
    sqInt newSize;
    sqInt sp;
    sqInt integerPointer;

	/* begin stackIntegerValue: */
	integerPointer = longAt(stackPointer - (0 * (BYTES_PER_WORD)));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		newSize = (integerPointer >> 1);
		goto l1;
	} else {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		newSize = 0;
		goto l1;
	}
	newSize = null;
l1:	/* end stackIntegerValue: */;
	array = longAt(stackPointer - (1 * (BYTES_PER_WORD)));
	/* begin pop: */
	stackPointer -= (argumentCount + 1) * (BYTES_PER_WORD);
	bytesFreed = shortentoIndexableSize(array, newSize);
	/* begin pushInteger: */
	/* begin push: */
	longAtput((sp = stackPointer + (BYTES_PER_WORD)), ((bytesFreed << 1) | 1));
	stackPointer = sp;
	return null;
}

sqInt primitiveTimesTwoPower(void) {
    sqInt arg;
    double rcvr;
    sqInt integerPointer;
    sqInt top;

	/* begin popInteger */
	/* begin popStack */
	top = longAt(stackPointer);
	stackPointer -= BYTES_PER_WORD;
	integerPointer = top;
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		arg = (integerPointer >> 1);
		goto l1;
	} else {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		arg = 0;
		goto l1;
	}
	arg = null;
l1:	/* end popInteger */;
	rcvr = popFloat();
	if (!primFailCode) {
		pushFloat(ldexp(rcvr, arg));
	} else {
		/* begin unPop: */
		stackPointer += 2 * (BYTES_PER_WORD);
	}
	return null;
}

sqInt primitiveTruncated(void) {
    double frac;
    double rcvr;
    double trunc;

	rcvr = popFloat();
	if (!primFailCode) {
		frac = modf(rcvr, &trunc);
		flag("Dan");
		success((-1073741824.0 <= trunc) && (trunc <= 1073741823.0));
	}
	if (!primFailCode) {
		pushInteger((sqInt) trunc);
	} else {
		/* begin unPop: */
		stackPointer += 1 * (BYTES_PER_WORD);
	}
	return null;
}


/*	Answer the UTC microseconds since the Smalltalk epoch. The value is
	derived from the Posix epoch (see primitiveUTCMicrosecondClock) with a
	constant offset corresponding to elapsed microseconds between the two
	epochs according to RFC 868. */

EXPORT(sqInt) primitiveUTCMicrosecondClock(void) {
    sqLong clock;
    static usqLong epochDelta= 2177452800000000ULL;
    int offset;
    sqInt uSecs;
    sqInt sp;

	if ((ioUtcWithOffset(&clock, &offset)) == -1) {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		return null;
	}
	clock += epochDelta;
	uSecs = positive64BitIntegerFor(clock);
	/* begin pop:thenPush: */
	longAtput((sp = stackPointer - ((1 - 1) * (BYTES_PER_WORD))), uSecs);
	stackPointer = sp;
	return null;
}


/*	Primitive. Unload the module with the given name. */
/*	Reloading of the module will happen *later* automatically, when a 
	function from it is called. This is ensured by invalidating current sessionID. */

sqInt primitiveUnloadModule(void) {
    sqInt moduleName;

	if (!(argumentCount == 1)) {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		return null;
	}
	moduleName = longAt(stackPointer);
	if ((moduleName & 1)) {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		return null;
	}
	if (!(((moduleName & 1) == 0) && (((((usqInt) (longAt(moduleName))) >> 8) & 15) >= 8))) {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		return null;
	}
	if (!(ioUnloadModuleOfLength(oopForPointer(firstIndexableField(moduleName)), byteSizeOf(moduleName)))) {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		return null;
	}
	flushExternalPrimitives();
	/* begin forceInterruptCheck */
	interruptCheckCounter = -1000;
	nextPollTick = 0;
	/* begin pop: */
	stackPointer -= 1 * (BYTES_PER_WORD);
	return null;
}


/*	Answer an array with UTC microseconds since the Posix epoch and
	the current seconds offset from GMT in the local time zone. An empty
	two element array may be supplied as a parameter.
	This is a named (not numbered) primitive in the null module (ie the VM) */

EXPORT(sqInt) primitiveUtcWithOffset(void) {
    sqLong clock;
    int offset;
    sqInt resultArray;
    sqInt top;
    sqInt oop;
    sqInt valuePointer;
    sqInt sp;
    sqInt oop1;

	if (argumentCount > 1) {
		return (primFailCode = PrimErrBadNumArgs);
	}
	if ((ioUtcWithOffset(&clock, &offset)) == -1) {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		return null;
	}
	/* begin pushRemappableOop: */
	oop = positive64BitIntegerFor(clock);
	remapBuffer[(remapBufferCount += 1)] = oop;
	if (argumentCount > 0) {
		/* begin popStack */
		top = longAt(stackPointer);
		stackPointer -= BYTES_PER_WORD;
		resultArray = top;
		if (!((((resultArray & 1) == 0) && (((((usqInt) (longAt(resultArray))) >> 8) & 15) <= 4)) && ((lengthOf(resultArray)) == 2))) {
			return (primFailCode = PrimErrBadArgument);
		}
	} else {
		resultArray = instantiateClassindexableSize(longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassArray << (SHIFT_FOR_WORD))), 2);
	}
	/* begin storePointer:ofObject:withValue: */
	/* begin popRemappableOop */
	oop1 = remapBuffer[remapBufferCount];
	remapBufferCount -= 1;
	valuePointer = oop1;
	if ((((usqInt) resultArray)) < (((usqInt) youngStart))) {
		possibleRootStoreIntovalue(resultArray, valuePointer);
	}
	longAtput((resultArray + (BASE_HEADER_SIZE)) + (0 << (SHIFT_FOR_WORD)), valuePointer);
	longAtput((resultArray + (BASE_HEADER_SIZE)) + (1 << (SHIFT_FOR_WORD)), ((offset << 1) | 1));
	/* begin pop:thenPush: */
	longAtput((sp = stackPointer - ((1 - 1) * (BYTES_PER_WORD))), resultArray);
	stackPointer = sp;
	return null;
}


/*	Behaviour depends on argument count:
		0 args:	return an Array of VM parameter values;
		1 arg:	return the indicated VM parameter;
		2 args:	set the VM indicated parameter.
	VM parameters are numbered as follows:
		1	end of old-space (0-based, read-only)
		2	end of young-space (read-only)
		3	end of memory (read-only)
		4	allocationCount (read-only)
		5	allocations between GCs (read-write)
		6	survivor count tenuring threshold (read-write)
		7	full GCs since startup (read-only)
		8	total milliseconds in full GCs since startup (read-only)
		9	incremental GCs since startup (read-only)
		10	total milliseconds in incremental GCs since startup (read-only)
		11	tenures of surving objects since startup (read-only)
		12-20 specific to the translating VM
		21	root table size (read-only)
		22	root table overflows since startup (read-only)
		23	bytes of extra memory to reserve for VM buffers, plugins, etc.
		24	memory threshold above which shrinking object memory (rw)
		25	memory headroom when growing object memory (rw)
		26  interruptChecksEveryNms - force an ioProcessEvents every N milliseconds, in case the image  is not calling getNextEvent often (rw)
		27	number of times mark loop iterated for current IGC/FGC (read-only) includes ALL marking
		28	number of times sweep loop iterated  for current IGC/FGC (read-only)
		29	number of times make forward loop iterated for current IGC/FGC (read-only)
		30	number of times compact move loop iterated for current IGC/FGC (read-only)
		31	number of grow memory requests (read-only)
		32	number of shrink memory requests (read-only)
		33	number of root table entries used for current IGC/FGC (read-only)
		34	number of allocations done before current IGC/FGC (read-only)
		35	number of survivor objects after current IGC/FGC (read-only)
		36  millisecond clock when current IGC/FGC completed (read-only)
		37  number of marked objects for Roots of the world, not including Root Table entries for current IGC/FGC (read-only)
		38  milliseconds taken by current IGC  (read-only)
		39  Number of finalization signals for Weak Objects pending when current IGC/FGC completed (read-only)
		40 BytesPerWord for this image
		
	Note: Thanks to Ian Piumarta for this primitive. */

void primitiveVMParameter(void) {
    sqInt arg;
    sqInt i;
    sqInt index;
    sqInt mem;
    sqInt paramsArraySize;
    sqInt result;
    sqLong resultLargePositiveInteger;
    sqInt statFullGCMSecsObj;
    sqInt statGCTimeObj;
    sqInt statIGCDeltaTimeObj;
    sqInt statIncrGCMSecsObj;
    sqInt oop;
    sqInt oop1;
    sqInt oop2;
    sqInt oop3;
    sqInt oop4;
    sqInt oop5;
    sqInt oop6;
    sqInt oop7;
    sqInt oop8;
    sqInt valuePointer;
    sqInt valuePointer1;
    sqInt valuePointer2;
    sqInt valuePointer3;
    sqInt valuePointer4;
    sqInt valuePointer5;
    sqInt valuePointer6;
    sqInt valuePointer7;
    sqInt sp;
    sqInt sp1;
    sqInt oop9;
    sqInt sp2;
    sqInt sp3;

	mem = memory;
	paramsArraySize = 40;
	if (argumentCount == 0) {
		result = instantiateClassindexableSize(longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassArray << (SHIFT_FOR_WORD))), paramsArraySize);
		/* begin pushRemappableOop: */
		remapBuffer[(remapBufferCount += 1)] = result;
		/* begin pushRemappableOop: */
		oop = positive64BitIntegerFor(statFullGCMSecs);
		remapBuffer[(remapBufferCount += 1)] = oop;
		/* begin pushRemappableOop: */
		oop1 = positive64BitIntegerFor(statIncrGCMSecs);
		remapBuffer[(remapBufferCount += 1)] = oop1;
		/* begin pushRemappableOop: */
		oop2 = positive64BitIntegerFor(statGCTime);
		remapBuffer[(remapBufferCount += 1)] = oop2;
		/* begin pushRemappableOop: */
		oop3 = positive64BitIntegerFor(statIGCDeltaTime);
		remapBuffer[(remapBufferCount += 1)] = oop3;
		/* begin popRemappableOop */
		oop4 = remapBuffer[remapBufferCount];
		remapBufferCount -= 1;
		statIGCDeltaTimeObj = oop4;
		/* begin popRemappableOop */
		oop5 = remapBuffer[remapBufferCount];
		remapBufferCount -= 1;
		statGCTimeObj = oop5;
		/* begin popRemappableOop */
		oop6 = remapBuffer[remapBufferCount];
		remapBufferCount -= 1;
		statIncrGCMSecsObj = oop6;
		/* begin popRemappableOop */
		oop7 = remapBuffer[remapBufferCount];
		remapBufferCount -= 1;
		statFullGCMSecsObj = oop7;
		/* begin popRemappableOop */
		oop8 = remapBuffer[remapBufferCount];
		remapBufferCount -= 1;
		result = oop8;
		for (i = 0; i <= (paramsArraySize - 1); i += 1) {
			/* begin storePointer:ofObject:withValue: */
			if ((((usqInt) result)) < (((usqInt) youngStart))) {
				possibleRootStoreIntovalue(result, ConstZero);
			}
			longAtput((result + (BASE_HEADER_SIZE)) + (i << (SHIFT_FOR_WORD)), ConstZero);
		}
		/* begin storePointer:ofObject:withValue: */
		valuePointer = positive64BitIntegerFor(youngStart - mem);
		if ((((usqInt) result)) < (((usqInt) youngStart))) {
			possibleRootStoreIntovalue(result, valuePointer);
		}
		longAtput((result + (BASE_HEADER_SIZE)) + (0 << (SHIFT_FOR_WORD)), valuePointer);
		/* begin storePointer:ofObject:withValue: */
		valuePointer1 = positive64BitIntegerFor(freeBlock - mem);
		if ((((usqInt) result)) < (((usqInt) youngStart))) {
			possibleRootStoreIntovalue(result, valuePointer1);
		}
		longAtput((result + (BASE_HEADER_SIZE)) + (1 << (SHIFT_FOR_WORD)), valuePointer1);
		/* begin storePointer:ofObject:withValue: */
		valuePointer2 = positive64BitIntegerFor(endOfMemory - mem);
		if ((((usqInt) result)) < (((usqInt) youngStart))) {
			possibleRootStoreIntovalue(result, valuePointer2);
		}
		longAtput((result + (BASE_HEADER_SIZE)) + (2 << (SHIFT_FOR_WORD)), valuePointer2);
		/* begin storePointer:ofObject:withValue: */
		valuePointer3 = ((allocationCount << 1) | 1);
		if ((((usqInt) result)) < (((usqInt) youngStart))) {
			possibleRootStoreIntovalue(result, valuePointer3);
		}
		longAtput((result + (BASE_HEADER_SIZE)) + (3 << (SHIFT_FOR_WORD)), valuePointer3);
		/* begin storePointer:ofObject:withValue: */
		if ((((usqInt) result)) < (((usqInt) youngStart))) {
			possibleRootStoreIntovalue(result, ((allocationsBetweenGCs << 1) | 1));
		}
		longAtput((result + (BASE_HEADER_SIZE)) + (4 << (SHIFT_FOR_WORD)), ((allocationsBetweenGCs << 1) | 1));
		/* begin storePointer:ofObject:withValue: */
		if ((((usqInt) result)) < (((usqInt) youngStart))) {
			possibleRootStoreIntovalue(result, ((tenuringThreshold << 1) | 1));
		}
		longAtput((result + (BASE_HEADER_SIZE)) + (5 << (SHIFT_FOR_WORD)), ((tenuringThreshold << 1) | 1));
		/* begin storePointer:ofObject:withValue: */
		if ((((usqInt) result)) < (((usqInt) youngStart))) {
			possibleRootStoreIntovalue(result, ((statFullGCs << 1) | 1));
		}
		longAtput((result + (BASE_HEADER_SIZE)) + (6 << (SHIFT_FOR_WORD)), ((statFullGCs << 1) | 1));
		/* begin storePointer:ofObject:withValue: */
		if ((((usqInt) result)) < (((usqInt) youngStart))) {
			possibleRootStoreIntovalue(result, statFullGCMSecsObj);
		}
		longAtput((result + (BASE_HEADER_SIZE)) + (7 << (SHIFT_FOR_WORD)), statFullGCMSecsObj);
		/* begin storePointer:ofObject:withValue: */
		if ((((usqInt) result)) < (((usqInt) youngStart))) {
			possibleRootStoreIntovalue(result, ((statIncrGCs << 1) | 1));
		}
		longAtput((result + (BASE_HEADER_SIZE)) + (8 << (SHIFT_FOR_WORD)), ((statIncrGCs << 1) | 1));
		/* begin storePointer:ofObject:withValue: */
		if ((((usqInt) result)) < (((usqInt) youngStart))) {
			possibleRootStoreIntovalue(result, statIncrGCMSecsObj);
		}
		longAtput((result + (BASE_HEADER_SIZE)) + (9 << (SHIFT_FOR_WORD)), statIncrGCMSecsObj);
		/* begin storePointer:ofObject:withValue: */
		if ((((usqInt) result)) < (((usqInt) youngStart))) {
			possibleRootStoreIntovalue(result, ((statTenures << 1) | 1));
		}
		longAtput((result + (BASE_HEADER_SIZE)) + (10 << (SHIFT_FOR_WORD)), ((statTenures << 1) | 1));
		/* begin storePointer:ofObject:withValue: */
		valuePointer4 = ((rootTableCount << 1) | 1);
		if ((((usqInt) result)) < (((usqInt) youngStart))) {
			possibleRootStoreIntovalue(result, valuePointer4);
		}
		longAtput((result + (BASE_HEADER_SIZE)) + (20 << (SHIFT_FOR_WORD)), valuePointer4);
		/* begin storePointer:ofObject:withValue: */
		if ((((usqInt) result)) < (((usqInt) youngStart))) {
			possibleRootStoreIntovalue(result, ((statRootTableOverflows << 1) | 1));
		}
		longAtput((result + (BASE_HEADER_SIZE)) + (21 << (SHIFT_FOR_WORD)), ((statRootTableOverflows << 1) | 1));
		/* begin storePointer:ofObject:withValue: */
		valuePointer5 = positive64BitIntegerFor(extraVMMemory);
		if ((((usqInt) result)) < (((usqInt) youngStart))) {
			possibleRootStoreIntovalue(result, valuePointer5);
		}
		longAtput((result + (BASE_HEADER_SIZE)) + (22 << (SHIFT_FOR_WORD)), valuePointer5);
		/* begin storePointer:ofObject:withValue: */
		valuePointer6 = positive64BitIntegerFor((sqLong)shrinkThreshold);
		if ((((usqInt) result)) < (((usqInt) youngStart))) {
			possibleRootStoreIntovalue(result, valuePointer6);
		}
		longAtput((result + (BASE_HEADER_SIZE)) + (23 << (SHIFT_FOR_WORD)), valuePointer6);
		/* begin storePointer:ofObject:withValue: */
		valuePointer7 = positive64BitIntegerFor((sqLong)growHeadroom);
		if ((((usqInt) result)) < (((usqInt) youngStart))) {
			possibleRootStoreIntovalue(result, valuePointer7);
		}
		longAtput((result + (BASE_HEADER_SIZE)) + (24 << (SHIFT_FOR_WORD)), valuePointer7);
		/* begin storePointer:ofObject:withValue: */
		if ((((usqInt) result)) < (((usqInt) youngStart))) {
			possibleRootStoreIntovalue(result, ((interruptChecksEveryNms << 1) | 1));
		}
		longAtput((result + (BASE_HEADER_SIZE)) + (25 << (SHIFT_FOR_WORD)), ((interruptChecksEveryNms << 1) | 1));
		/* begin storePointer:ofObject:withValue: */
		if ((((usqInt) result)) < (((usqInt) youngStart))) {
			possibleRootStoreIntovalue(result, ((statMarkCount << 1) | 1));
		}
		longAtput((result + (BASE_HEADER_SIZE)) + (26 << (SHIFT_FOR_WORD)), ((statMarkCount << 1) | 1));
		/* begin storePointer:ofObject:withValue: */
		if ((((usqInt) result)) < (((usqInt) youngStart))) {
			possibleRootStoreIntovalue(result, ((statSweepCount << 1) | 1));
		}
		longAtput((result + (BASE_HEADER_SIZE)) + (27 << (SHIFT_FOR_WORD)), ((statSweepCount << 1) | 1));
		/* begin storePointer:ofObject:withValue: */
		if ((((usqInt) result)) < (((usqInt) youngStart))) {
			possibleRootStoreIntovalue(result, ((statMkFwdCount << 1) | 1));
		}
		longAtput((result + (BASE_HEADER_SIZE)) + (28 << (SHIFT_FOR_WORD)), ((statMkFwdCount << 1) | 1));
		/* begin storePointer:ofObject:withValue: */
		if ((((usqInt) result)) < (((usqInt) youngStart))) {
			possibleRootStoreIntovalue(result, ((statCompMoveCount << 1) | 1));
		}
		longAtput((result + (BASE_HEADER_SIZE)) + (29 << (SHIFT_FOR_WORD)), ((statCompMoveCount << 1) | 1));
		/* begin storePointer:ofObject:withValue: */
		if ((((usqInt) result)) < (((usqInt) youngStart))) {
			possibleRootStoreIntovalue(result, ((statGrowMemory << 1) | 1));
		}
		longAtput((result + (BASE_HEADER_SIZE)) + (30 << (SHIFT_FOR_WORD)), ((statGrowMemory << 1) | 1));
		/* begin storePointer:ofObject:withValue: */
		if ((((usqInt) result)) < (((usqInt) youngStart))) {
			possibleRootStoreIntovalue(result, ((statShrinkMemory << 1) | 1));
		}
		longAtput((result + (BASE_HEADER_SIZE)) + (31 << (SHIFT_FOR_WORD)), ((statShrinkMemory << 1) | 1));
		/* begin storePointer:ofObject:withValue: */
		if ((((usqInt) result)) < (((usqInt) youngStart))) {
			possibleRootStoreIntovalue(result, ((statRootTableCount << 1) | 1));
		}
		longAtput((result + (BASE_HEADER_SIZE)) + (32 << (SHIFT_FOR_WORD)), ((statRootTableCount << 1) | 1));
		/* begin storePointer:ofObject:withValue: */
		if ((((usqInt) result)) < (((usqInt) youngStart))) {
			possibleRootStoreIntovalue(result, ((statAllocationCount << 1) | 1));
		}
		longAtput((result + (BASE_HEADER_SIZE)) + (33 << (SHIFT_FOR_WORD)), ((statAllocationCount << 1) | 1));
		/* begin storePointer:ofObject:withValue: */
		if ((((usqInt) result)) < (((usqInt) youngStart))) {
			possibleRootStoreIntovalue(result, ((statSurvivorCount << 1) | 1));
		}
		longAtput((result + (BASE_HEADER_SIZE)) + (34 << (SHIFT_FOR_WORD)), ((statSurvivorCount << 1) | 1));
		/* begin storePointer:ofObject:withValue: */
		if ((((usqInt) result)) < (((usqInt) youngStart))) {
			possibleRootStoreIntovalue(result, statGCTimeObj);
		}
		longAtput((result + (BASE_HEADER_SIZE)) + (35 << (SHIFT_FOR_WORD)), statGCTimeObj);
		/* begin storePointer:ofObject:withValue: */
		if ((((usqInt) result)) < (((usqInt) youngStart))) {
			possibleRootStoreIntovalue(result, ((statSpecialMarkCount << 1) | 1));
		}
		longAtput((result + (BASE_HEADER_SIZE)) + (36 << (SHIFT_FOR_WORD)), ((statSpecialMarkCount << 1) | 1));
		/* begin storePointer:ofObject:withValue: */
		if ((((usqInt) result)) < (((usqInt) youngStart))) {
			possibleRootStoreIntovalue(result, statIGCDeltaTimeObj);
		}
		longAtput((result + (BASE_HEADER_SIZE)) + (37 << (SHIFT_FOR_WORD)), statIGCDeltaTimeObj);
		/* begin storePointer:ofObject:withValue: */
		if ((((usqInt) result)) < (((usqInt) youngStart))) {
			possibleRootStoreIntovalue(result, ((statpendingFinalizationSignals << 1) | 1));
		}
		longAtput((result + (BASE_HEADER_SIZE)) + (38 << (SHIFT_FOR_WORD)), ((statpendingFinalizationSignals << 1) | 1));
		/* begin storePointer:ofObject:withValue: */
		if ((((usqInt) result)) < (((usqInt) youngStart))) {
			possibleRootStoreIntovalue(result, (((BYTES_PER_WORD) << 1) | 1));
		}
		longAtput((result + (BASE_HEADER_SIZE)) + (39 << (SHIFT_FOR_WORD)), (((BYTES_PER_WORD) << 1) | 1));
		/* begin pop:thenPush: */
		longAtput((sp = stackPointer - ((1 - 1) * (BYTES_PER_WORD))), result);
		stackPointer = sp;
		return;
	}
	arg = longAt(stackPointer);
	if (!((arg & 1))) {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		return;
	}
	arg = (arg >> 1);
	resultLargePositiveInteger = -1;
	if (argumentCount == 1) {

		/* read VM parameter */

		if ((arg < 1) || (arg > paramsArraySize)) {
			/* begin primitiveFail */
			if (primFailCode == 0) {
				primFailCode = 1;
			}
			return;
		}
		if (arg == 1) {
			resultLargePositiveInteger = youngStart - mem;
		}
		if (arg == 2) {
			resultLargePositiveInteger = freeBlock - mem;
		}
		if (arg == 3) {
			resultLargePositiveInteger = endOfMemory - mem;
		}
		if (arg == 4) {
			result = allocationCount;
		}
		if (arg == 5) {
			result = allocationsBetweenGCs;
		}
		if (arg == 6) {
			result = tenuringThreshold;
		}
		if (arg == 7) {
			result = statFullGCs;
		}
		if (arg == 8) {
			resultLargePositiveInteger = statFullGCMSecs;
		}
		if (arg == 9) {
			result = statIncrGCs;
		}
		if (arg == 10) {
			resultLargePositiveInteger = statIncrGCMSecs;
		}
		if (arg == 11) {
			result = statTenures;
		}
		if ((arg >= 12) && (arg <= 20)) {
			result = 0;
		}
		if (arg == 21) {
			result = rootTableCount;
		}
		if (arg == 22) {
			result = statRootTableOverflows;
		}
		if (arg == 23) {
			resultLargePositiveInteger = extraVMMemory;
		}
		if (arg == 24) {
			resultLargePositiveInteger = shrinkThreshold;
		}
		if (arg == 25) {
			resultLargePositiveInteger = growHeadroom;
		}
		if (arg == 26) {
			result = interruptChecksEveryNms;
		}
		if (arg == 27) {
			result = statMarkCount;
		}
		if (arg == 28) {
			result = statSweepCount;
		}
		if (arg == 29) {
			result = statMkFwdCount;
		}
		if (arg == 30) {
			result = statCompMoveCount;
		}
		if (arg == 31) {
			result = statGrowMemory;
		}
		if (arg == 32) {
			result = statShrinkMemory;
		}
		if (arg == 33) {
			result = statRootTableCount;
		}
		if (arg == 34) {
			result = statAllocationCount;
		}
		if (arg == 35) {
			result = statSurvivorCount;
		}
		if (arg == 36) {
			resultLargePositiveInteger = statGCTime;
		}
		if (arg == 37) {
			result = statSpecialMarkCount;
		}
		if (arg == 38) {
			resultLargePositiveInteger = statIGCDeltaTime;
		}
		if (arg == 39) {
			result = statpendingFinalizationSignals;
		}
		if (arg == 40) {
			result = BYTES_PER_WORD;
		}
		if (resultLargePositiveInteger == -1) {
			/* begin pop:thenPush: */
			longAtput((sp1 = stackPointer - ((2 - 1) * (BYTES_PER_WORD))), ((result << 1) | 1));
			stackPointer = sp1;
		} else {
			/* begin pop:thenPush: */
			oop9 = positive64BitIntegerFor(resultLargePositiveInteger);
			longAtput((sp2 = stackPointer - ((2 - 1) * (BYTES_PER_WORD))), oop9);
			stackPointer = sp2;
		}
		return;
	}
	if (!(argumentCount == 2)) {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		return;
	}
	index = longAt(stackPointer - (1 * (BYTES_PER_WORD)));
	if (!((index & 1))) {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		return;
	}
	index = (index >> 1);
	if (index <= 0) {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		return;
	}
	/* begin primitiveFail */
	if (primFailCode == 0) {
		primFailCode = 1;
	}
	if (index == 5) {
		result = allocationsBetweenGCs;
		/* begin setAllocationsBetweenGCs: */
		allocationsBetweenGCs = arg;
		/* begin initPrimCall */
		primFailCode = 0;
	}
	if (index == 6) {
		result = tenuringThreshold;
		/* begin setTenuringThreshold: */
		tenuringThreshold = arg;
		/* begin initPrimCall */
		primFailCode = 0;
	}
	if (index == 23) {
		result = extraVMMemory;
		extraVMMemory = arg;
		/* begin initPrimCall */
		primFailCode = 0;
	}
	if (index == 24) {
		result = shrinkThreshold;
		if (arg > 0) {
			/* begin setShrinkThreshold: */
			shrinkThreshold = arg;
			/* begin initPrimCall */
			primFailCode = 0;
		}
	}
	if (index == 25) {
		result = growHeadroom;
		if (arg > 0) {
			/* begin setGrowHeadroom: */
			growHeadroom = arg;
			/* begin initPrimCall */
			primFailCode = 0;
		}
	}
	if (index == 26) {
		if (arg > 1) {
			result = interruptChecksEveryNms;
			interruptChecksEveryNms = arg;
			/* begin initPrimCall */
			primFailCode = 0;
		}
	}
	if (!primFailCode) {
		/* begin pop:thenPush: */
		longAtput((sp3 = stackPointer - ((3 - 1) * (BYTES_PER_WORD))), ((result << 1) | 1));
		stackPointer = sp3;
		return;
	}
	/* begin primitiveFail */
	if (primFailCode == 0) {
		primFailCode = 1;
	}
}


/*	Return a string containing the path name of VM's directory. */

sqInt primitiveVMPath(void) {
    sqInt s;
    sqInt sz;
    sqInt sp;

	sz = vmPathSize();
	s = instantiateClassindexableSize(longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassString << (SHIFT_FOR_WORD))), sz);
	vmPathGetLength(s + (BASE_HEADER_SIZE), sz);
	/* begin pop:thenPush: */
	longAtput((sp = stackPointer - ((1 - 1) * (BYTES_PER_WORD))), s);
	stackPointer = sp;
	return null;
}


/*	Answer a string corresponding to the version of virtual machine. This
	represents the version level of the Smalltalk source code (interpreter and various
	plugins) that is translated to C by a CCodeGenerator,  in addition to the external
	platform source code, typically written in C and managed separately for each platform.
	By convention, this is a string composed of the interpreter source version and the
	platform source version, e.g. '4.0.2-2172'.
	
	This is a named (not numbered) primitive in the null module (ie the VM) */

EXPORT(sqInt) primitiveVMVersion(void) {
    sqInt len;
    void * p;
    sqInt versionString;
    sqInt sp;

	
# ifdef VM_VERSION  // version level of interpreter plus platform support code
	len = strlen(VM_VERSION);
	versionString = instantiateClassindexableSize(longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassString << (SHIFT_FOR_WORD))), len);
	/* begin arrayValueOf: */
	if ((!((versionString & 1))) && (((versionString & 1) == 0) && (isWordsOrBytesNonInt(versionString)))) {
		p = pointerForOop(versionString + (BASE_HEADER_SIZE));
		goto l1;
	}
	/* begin primitiveFail */
	if (primFailCode == 0) {
		primFailCode = 1;
	}
l1:	/* end arrayValueOf: */;
	strncpy(p, VM_VERSION, len);
# else
	/* begin primitiveFail */
	if (primFailCode == 0) {
		primFailCode = 1;
	}
	return null;
# endif  // VM_VERSION
	
	/* begin pop:thenPush: */
	longAtput((sp = stackPointer - ((1 - 1) * (BYTES_PER_WORD))), versionString);
	stackPointer = sp;
	return null;
}

void primitiveValue(void) {
    sqInt blockArgumentCount;
    sqInt blockContext;
    sqInt initialIP;
    sqInt firstFrom;
    sqInt fromIndex;
    sqInt lastFrom;
    sqInt toIndex;
    sqInt successBoolean;
    sqInt tmp;
    sqInt localArgCount;
    sqInt valuePointer;

	blockContext = longAt(stackPointer - (argumentCount * (BYTES_PER_WORD)));
	/* begin argumentCountOfBlock: */
	localArgCount = longAt((blockContext + (BASE_HEADER_SIZE)) + (BlockArgumentCountIndex << (SHIFT_FOR_WORD)));
	/* begin checkedIntegerValueOf: */
	if ((localArgCount & 1)) {
		blockArgumentCount = (localArgCount >> 1);
		goto l1;
	} else {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		blockArgumentCount = 0;
		goto l1;
	}
	blockArgumentCount = null;
l1:	/* end argumentCountOfBlock: */;
	/* begin success: */
	successBoolean = (argumentCount == blockArgumentCount) && ((longAt((blockContext + (BASE_HEADER_SIZE)) + (CallerIndex << (SHIFT_FOR_WORD)))) == nilObj);
	if (!(successBoolean)) {
		if (!primFailCode) {
			primFailCode = 1;
		}
	}
	if (!primFailCode) {
		/* begin transfer:fromIndex:ofObject:toIndex:ofObject: */
		firstFrom = ((((usqInt) ((stackPointer - activeContext) - (BASE_HEADER_SIZE))) >> (SHIFT_FOR_WORD)) - argumentCount) + 1;
		flag("Dan");
		fromIndex = activeContext + (firstFrom * (BYTES_PER_WORD));
		toIndex = blockContext + (TempFrameStart * (BYTES_PER_WORD));
		lastFrom = fromIndex + (argumentCount * (BYTES_PER_WORD));
		while ((((usqInt) fromIndex)) < (((usqInt) lastFrom))) {
			fromIndex += BYTES_PER_WORD;
			toIndex += BYTES_PER_WORD;
			longAtput(toIndex, longAt(fromIndex));
		}
		/* begin pop: */
		stackPointer -= (argumentCount + 1) * (BYTES_PER_WORD);
		initialIP = longAt((blockContext + (BASE_HEADER_SIZE)) + (InitialIPIndex << (SHIFT_FOR_WORD)));
		longAtput((blockContext + (BASE_HEADER_SIZE)) + (InstructionPointerIndex << (SHIFT_FOR_WORD)), initialIP);
		/* begin storeStackPointerValue:inContext: */
		longAtput((blockContext + (BASE_HEADER_SIZE)) + (StackPointerIndex << (SHIFT_FOR_WORD)), ((argumentCount << 1) | 1));
		longAtput((blockContext + (BASE_HEADER_SIZE)) + (CallerIndex << (SHIFT_FOR_WORD)), activeContext);
		/* begin newActiveContext: */
		/* begin storeContextRegisters: */
		longAtput((activeContext + (BASE_HEADER_SIZE)) + (InstructionPointerIndex << (SHIFT_FOR_WORD)), ((((instructionPointer - method) - ((BASE_HEADER_SIZE) - 2)) << 1) | 1));
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer = (((((((usqInt) ((stackPointer - activeContext) - (BASE_HEADER_SIZE))) >> (SHIFT_FOR_WORD)) - TempFrameStart) + 1) << 1) | 1);
		longAtput((activeContext + (BASE_HEADER_SIZE)) + (StackPointerIndex << (SHIFT_FOR_WORD)), valuePointer);
		if ((((usqInt) blockContext)) < (((usqInt) youngStart))) {
			beRootIfOld(blockContext);
		}
		activeContext = blockContext;
		/* begin fetchContextRegisters: */
		tmp = longAt((blockContext + (BASE_HEADER_SIZE)) + (MethodIndex << (SHIFT_FOR_WORD)));
		if ((tmp & 1)) {
			tmp = longAt((blockContext + (BASE_HEADER_SIZE)) + (HomeIndex << (SHIFT_FOR_WORD)));
			if ((((usqInt) tmp)) < (((usqInt) youngStart))) {
				beRootIfOld(tmp);
			}
		} else {
			tmp = blockContext;
		}
		theHomeContext = tmp;
		receiver = longAt((tmp + (BASE_HEADER_SIZE)) + (ReceiverIndex << (SHIFT_FOR_WORD)));
		method = (usqInt)longAt((tmp + (BASE_HEADER_SIZE)) + (MethodIndex << (SHIFT_FOR_WORD)));
		tmp = ((longAt((blockContext + (BASE_HEADER_SIZE)) + (InstructionPointerIndex << (SHIFT_FOR_WORD)))) >> 1);
		instructionPointer = (usqInt)((method + tmp) + (BASE_HEADER_SIZE)) - 2;
		tmp = ((longAt((blockContext + (BASE_HEADER_SIZE)) + (StackPointerIndex << (SHIFT_FOR_WORD)))) >> 1);
		stackPointer = (usqInt)(blockContext + (BASE_HEADER_SIZE)) + (((TempFrameStart + tmp) - 1) * (BYTES_PER_WORD));
	}
}


/*	The only purpose of this primitive is to indicate that the new EH mechanisms are supported. */

void primitiveValueUninterruptably(void) {
	primitiveValue(); return;
}

void primitiveValueWithArgs(void) {
    sqInt argumentArray;
    sqInt arrayArgumentCount;
    sqInt blockArgumentCount;
    sqInt blockContext;
    sqInt initialIP;
    sqInt sz;
    sqInt header;
    sqInt successBoolean;
    sqInt fromIndex;
    sqInt lastFrom;
    sqInt toIndex;
    sqInt top;
    sqInt top1;
    sqInt tmp;
    sqInt localArgCount;
    sqInt valuePointer;

	/* begin popStack */
	top = longAt(stackPointer);
	stackPointer -= BYTES_PER_WORD;
	argumentArray = top;
	/* begin popStack */
	top1 = longAt(stackPointer);
	stackPointer -= BYTES_PER_WORD;
	blockContext = top1;
	/* begin argumentCountOfBlock: */
	localArgCount = longAt((blockContext + (BASE_HEADER_SIZE)) + (BlockArgumentCountIndex << (SHIFT_FOR_WORD)));
	/* begin checkedIntegerValueOf: */
	if ((localArgCount & 1)) {
		blockArgumentCount = (localArgCount >> 1);
		goto l2;
	} else {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		blockArgumentCount = 0;
		goto l2;
	}
	blockArgumentCount = null;
l2:	/* end argumentCountOfBlock: */;
	if (!(((argumentArray & 1) == 0) && (((((usqInt) (longAt(argumentArray))) >> 8) & 15) == 2))) {
		/* begin unPop: */
		stackPointer += 2 * (BYTES_PER_WORD);
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		return;
	}
	if (!primFailCode) {
		/* begin fetchWordLengthOf: */
		/* begin sizeBitsOf: */
		header = longAt(argumentArray);
		if ((header & TypeMask) == HeaderTypeSizeAndClass) {
			sz = (longAt(argumentArray - ((BYTES_PER_WORD) * 2))) & (LONG_SIZE_MASK);
			goto l1;
		} else {
			sz = header & (SIZE_MASK);
			goto l1;
		}
	l1:	/* end sizeBitsOf: */;
		arrayArgumentCount = ((usqInt) (sz - (BASE_HEADER_SIZE))) >> (SHIFT_FOR_WORD);
		/* begin success: */
		successBoolean = (arrayArgumentCount == blockArgumentCount) && ((longAt((blockContext + (BASE_HEADER_SIZE)) + (CallerIndex << (SHIFT_FOR_WORD)))) == nilObj);
		if (!(successBoolean)) {
			if (!primFailCode) {
				primFailCode = 1;
			}
		}
	}
	if (!primFailCode) {
		/* begin transfer:fromIndex:ofObject:toIndex:ofObject: */
		flag("Dan");
		fromIndex = argumentArray + (0 * (BYTES_PER_WORD));
		toIndex = blockContext + (TempFrameStart * (BYTES_PER_WORD));
		lastFrom = fromIndex + (arrayArgumentCount * (BYTES_PER_WORD));
		while ((((usqInt) fromIndex)) < (((usqInt) lastFrom))) {
			fromIndex += BYTES_PER_WORD;
			toIndex += BYTES_PER_WORD;
			longAtput(toIndex, longAt(fromIndex));
		}
		initialIP = longAt((blockContext + (BASE_HEADER_SIZE)) + (InitialIPIndex << (SHIFT_FOR_WORD)));
		longAtput((blockContext + (BASE_HEADER_SIZE)) + (InstructionPointerIndex << (SHIFT_FOR_WORD)), initialIP);
		/* begin storeStackPointerValue:inContext: */
		longAtput((blockContext + (BASE_HEADER_SIZE)) + (StackPointerIndex << (SHIFT_FOR_WORD)), ((arrayArgumentCount << 1) | 1));
		longAtput((blockContext + (BASE_HEADER_SIZE)) + (CallerIndex << (SHIFT_FOR_WORD)), activeContext);
		/* begin newActiveContext: */
		/* begin storeContextRegisters: */
		longAtput((activeContext + (BASE_HEADER_SIZE)) + (InstructionPointerIndex << (SHIFT_FOR_WORD)), ((((instructionPointer - method) - ((BASE_HEADER_SIZE) - 2)) << 1) | 1));
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer = (((((((usqInt) ((stackPointer - activeContext) - (BASE_HEADER_SIZE))) >> (SHIFT_FOR_WORD)) - TempFrameStart) + 1) << 1) | 1);
		longAtput((activeContext + (BASE_HEADER_SIZE)) + (StackPointerIndex << (SHIFT_FOR_WORD)), valuePointer);
		if ((((usqInt) blockContext)) < (((usqInt) youngStart))) {
			beRootIfOld(blockContext);
		}
		activeContext = blockContext;
		/* begin fetchContextRegisters: */
		tmp = longAt((blockContext + (BASE_HEADER_SIZE)) + (MethodIndex << (SHIFT_FOR_WORD)));
		if ((tmp & 1)) {
			tmp = longAt((blockContext + (BASE_HEADER_SIZE)) + (HomeIndex << (SHIFT_FOR_WORD)));
			if ((((usqInt) tmp)) < (((usqInt) youngStart))) {
				beRootIfOld(tmp);
			}
		} else {
			tmp = blockContext;
		}
		theHomeContext = tmp;
		receiver = longAt((tmp + (BASE_HEADER_SIZE)) + (ReceiverIndex << (SHIFT_FOR_WORD)));
		method = (usqInt)longAt((tmp + (BASE_HEADER_SIZE)) + (MethodIndex << (SHIFT_FOR_WORD)));
		tmp = ((longAt((blockContext + (BASE_HEADER_SIZE)) + (InstructionPointerIndex << (SHIFT_FOR_WORD)))) >> 1);
		instructionPointer = (usqInt)((method + tmp) + (BASE_HEADER_SIZE)) - 2;
		tmp = ((longAt((blockContext + (BASE_HEADER_SIZE)) + (StackPointerIndex << (SHIFT_FOR_WORD)))) >> 1);
		stackPointer = (usqInt)(blockContext + (BASE_HEADER_SIZE)) + (((TempFrameStart + tmp) - 1) * (BYTES_PER_WORD));
	} else {
		/* begin unPop: */
		stackPointer += 2 * (BYTES_PER_WORD);
	}
}

sqInt primitiveWait(void) {
    sqInt activeProc;
    sqInt excessSignals;
    sqInt sema;
    sqInt oop;
    sqInt oop1;
    sqInt lastLink;
    sqInt classOop;
    sqInt ccIndex;
    sqInt cl;
    sqInt oop11;


	/* rcvr */

	sema = longAt(stackPointer);
	/* begin assertClassOf:is: */
	classOop = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassSemaphore << (SHIFT_FOR_WORD)));
	if ((sema & 1)) {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		goto l1;
	}
	ccIndex = (((usqInt) (longAt(sema))) >> 12) & 31;
	if (ccIndex == 0) {
		cl = (longAt(sema - (BASE_HEADER_SIZE))) & (ALL_BUT_TYPE_MASK);
	} else {
		/* begin fetchPointer:ofObject: */
		oop11 = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (CompactClasses << (SHIFT_FOR_WORD)));
		cl = longAt((oop11 + (BASE_HEADER_SIZE)) + ((ccIndex - 1) << (SHIFT_FOR_WORD)));
	}
	/* begin success: */
	if (!(cl == classOop)) {
		if (!primFailCode) {
			primFailCode = 1;
		}
	}
l1:	/* end assertClassOf:is: */;
	if (!primFailCode) {
		excessSignals = fetchIntegerofObject(ExcessSignalsIndex, sema);
		if (excessSignals > 0) {
			/* begin storeInteger:ofObject:withValue: */
			if (
# ifdef SQ_HOST32  // cast to int for 64 bit image on 32 bit host
				(((((int) (excessSignals - 1))) ^ ((((int) (excessSignals - 1))) << 1)) >= 0)
# else
				(((excessSignals - 1) >= -1073741824) && ((excessSignals - 1) <= 1073741823))
# endif  // SQ_HOST32
			) {
				longAtput((sema + (BASE_HEADER_SIZE)) + (ExcessSignalsIndex << (SHIFT_FOR_WORD)), (((excessSignals - 1) << 1) | 1));
			} else {
				/* begin primitiveFail */
				if (primFailCode == 0) {
					primFailCode = 1;
				}
			}
		} else {
			/* begin fetchPointer:ofObject: */
			/* begin fetchPointer:ofObject: */
			oop1 = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (SchedulerAssociation << (SHIFT_FOR_WORD)));
			oop = longAt((oop1 + (BASE_HEADER_SIZE)) + (ValueIndex << (SHIFT_FOR_WORD)));
			activeProc = longAt((oop + (BASE_HEADER_SIZE)) + (ActiveProcessIndex << (SHIFT_FOR_WORD)));
			/* begin addLastLink:toList: */
			if ((longAt((sema + (BASE_HEADER_SIZE)) + (FirstLinkIndex << (SHIFT_FOR_WORD)))) == nilObj) {
				/* begin storePointer:ofObject:withValue: */
				if ((((usqInt) sema)) < (((usqInt) youngStart))) {
					possibleRootStoreIntovalue(sema, activeProc);
				}
				longAtput((sema + (BASE_HEADER_SIZE)) + (FirstLinkIndex << (SHIFT_FOR_WORD)), activeProc);
			} else {
				lastLink = longAt((sema + (BASE_HEADER_SIZE)) + (LastLinkIndex << (SHIFT_FOR_WORD)));
				/* begin storePointer:ofObject:withValue: */
				if ((((usqInt) lastLink)) < (((usqInt) youngStart))) {
					possibleRootStoreIntovalue(lastLink, activeProc);
				}
				longAtput((lastLink + (BASE_HEADER_SIZE)) + (NextLinkIndex << (SHIFT_FOR_WORD)), activeProc);
			}
			/* begin storePointer:ofObject:withValue: */
			if ((((usqInt) sema)) < (((usqInt) youngStart))) {
				possibleRootStoreIntovalue(sema, activeProc);
			}
			longAtput((sema + (BASE_HEADER_SIZE)) + (LastLinkIndex << (SHIFT_FOR_WORD)), activeProc);
			/* begin storePointer:ofObject:withValue: */
			if ((((usqInt) activeProc)) < (((usqInt) youngStart))) {
				possibleRootStoreIntovalue(activeProc, sema);
			}
			longAtput((activeProc + (BASE_HEADER_SIZE)) + (MyListIndex << (SHIFT_FOR_WORD)), sema);
			transferTo(wakeHighestPriority());
		}
	}
	return null;
}


/*	primitively do the equivalent of Process>yield */

sqInt primitiveYield(void) {
    sqInt activeProc;
    sqInt priority;
    sqInt processList;
    sqInt processLists;
    sqInt oop;
    sqInt oop1;
    sqInt lastLink;
    sqInt oop2;
    sqInt oop3;

	/* begin fetchPointer:ofObject: */
	/* begin fetchPointer:ofObject: */
	oop2 = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (SchedulerAssociation << (SHIFT_FOR_WORD)));
	oop = longAt((oop2 + (BASE_HEADER_SIZE)) + (ValueIndex << (SHIFT_FOR_WORD)));
	activeProc = longAt((oop + (BASE_HEADER_SIZE)) + (ActiveProcessIndex << (SHIFT_FOR_WORD)));
	priority = ((longAt((activeProc + (BASE_HEADER_SIZE)) + (PriorityIndex << (SHIFT_FOR_WORD)))) >> 1);
	/* begin fetchPointer:ofObject: */
	/* begin fetchPointer:ofObject: */
	oop3 = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (SchedulerAssociation << (SHIFT_FOR_WORD)));
	oop1 = longAt((oop3 + (BASE_HEADER_SIZE)) + (ValueIndex << (SHIFT_FOR_WORD)));
	processLists = longAt((oop1 + (BASE_HEADER_SIZE)) + (ProcessListsIndex << (SHIFT_FOR_WORD)));
	processList = longAt((processLists + (BASE_HEADER_SIZE)) + ((priority - 1) << (SHIFT_FOR_WORD)));
	if (!((longAt((processList + (BASE_HEADER_SIZE)) + (FirstLinkIndex << (SHIFT_FOR_WORD)))) == nilObj)) {
		/* begin addLastLink:toList: */
		if ((longAt((processList + (BASE_HEADER_SIZE)) + (FirstLinkIndex << (SHIFT_FOR_WORD)))) == nilObj) {
			/* begin storePointer:ofObject:withValue: */
			if ((((usqInt) processList)) < (((usqInt) youngStart))) {
				possibleRootStoreIntovalue(processList, activeProc);
			}
			longAtput((processList + (BASE_HEADER_SIZE)) + (FirstLinkIndex << (SHIFT_FOR_WORD)), activeProc);
		} else {
			lastLink = longAt((processList + (BASE_HEADER_SIZE)) + (LastLinkIndex << (SHIFT_FOR_WORD)));
			/* begin storePointer:ofObject:withValue: */
			if ((((usqInt) lastLink)) < (((usqInt) youngStart))) {
				possibleRootStoreIntovalue(lastLink, activeProc);
			}
			longAtput((lastLink + (BASE_HEADER_SIZE)) + (NextLinkIndex << (SHIFT_FOR_WORD)), activeProc);
		}
		/* begin storePointer:ofObject:withValue: */
		if ((((usqInt) processList)) < (((usqInt) youngStart))) {
			possibleRootStoreIntovalue(processList, activeProc);
		}
		longAtput((processList + (BASE_HEADER_SIZE)) + (LastLinkIndex << (SHIFT_FOR_WORD)), activeProc);
		/* begin storePointer:ofObject:withValue: */
		if ((((usqInt) activeProc)) < (((usqInt) youngStart))) {
			possibleRootStoreIntovalue(activeProc, processList);
		}
		longAtput((activeProc + (BASE_HEADER_SIZE)) + (MyListIndex << (SHIFT_FOR_WORD)), processList);
		transferTo(wakeHighestPriority());
	}
	return null;
}


/*	For testing in Smalltalk, this method should be overridden in a subclass. */

sqInt print(char *s) {
	printf("%s", s);
	return null;
}


/*	Print all the stacks of all running processes, including those that are currently suspended. */

EXPORT(sqInt) printAllStacks(void) {
    sqInt ctx;
    sqInt oop;
    sqInt proc;
    sqInt oop1;
    sqInt sz;
    sqInt header;
    sqInt oop2;


	/* exported to permit access from plugins */

	/* begin fetchPointer:ofObject: */
	/* begin fetchPointer:ofObject: */
	oop2 = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (SchedulerAssociation << (SHIFT_FOR_WORD)));
	oop1 = longAt((oop2 + (BASE_HEADER_SIZE)) + (ValueIndex << (SHIFT_FOR_WORD)));
	proc = longAt((oop1 + (BASE_HEADER_SIZE)) + (ActiveProcessIndex << (SHIFT_FOR_WORD)));
	printNameOfClasscount(fetchClassOf(proc), 5);
	/* begin cr */
	printf("\n");
	printCallStackOf((sqInt)activeContext);
	oop = memory + (headerTypeBytes[(longAt(memory)) & TypeMask]);
	while ((((usqInt) oop)) < (((usqInt) endOfMemory))) {
		if ((fetchClassOf(oop)) == (longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassSemaphore << (SHIFT_FOR_WORD))))) {
			/* begin cr */
			printf("\n");
			proc = longAt((oop + (BASE_HEADER_SIZE)) + (FirstLinkIndex << (SHIFT_FOR_WORD)));
			while (!(proc == nilObj)) {
				printNameOfClasscount(fetchClassOf(proc), 5);
				/* begin cr */
				printf("\n");
				ctx = longAt((proc + (BASE_HEADER_SIZE)) + (SuspendedContextIndex << (SHIFT_FOR_WORD)));
				if (!(ctx == nilObj)) {
					printCallStackOf(ctx);
				}
				proc = longAt((proc + (BASE_HEADER_SIZE)) + (NextLinkIndex << (SHIFT_FOR_WORD)));
			}
		}
		/* begin objectAfter: */
		if (DoAssertionChecks) {
			if ((((usqInt) oop)) >= (((usqInt) endOfMemory))) {
				error("no objects after the end of memory");
			}
		}
		if (((longAt(oop)) & TypeMask) == HeaderTypeFree) {
			sz = (longAt(oop)) & (ALL_BUT_TYPE_MASK);
		} else {
			/* begin sizeBitsOf: */
			header = longAt(oop);
			if ((header & TypeMask) == HeaderTypeSizeAndClass) {
				sz = (longAt(oop - ((BYTES_PER_WORD) * 2))) & (LONG_SIZE_MASK);
				goto l1;
			} else {
				sz = header & (SIZE_MASK);
				goto l1;
			}
		l1:	/* end sizeBitsOf: */;
		}
		oop = (oop + sz) + (headerTypeBytes[(longAt(oop + sz)) & TypeMask]);
	}
	return null;
}

sqInt printCallStack(void) {
	return printCallStackOf((sqInt)activeContext);
}

sqInt printCallStackOf(sqInt aContext) {
    sqInt ctxt;
    sqInt home;
    sqInt message;
    sqInt methClass;
    sqInt methodSel;
    sqInt meth;
    sqInt rcvr;
    sqInt classDict;
    sqInt classDictSize;
    sqInt currClass;
    sqInt done;
    sqInt i;
    sqInt methodArray;
    sqInt sz;
    sqInt header;
    sqInt ccIndex;
    sqInt oop1;
    sqInt ccIndex1;
    sqInt oop11;
    sqInt meth1;
    sqInt rcvr1;
    sqInt classDict1;
    sqInt classDictSize1;
    sqInt currClass1;
    sqInt done1;
    sqInt i1;
    sqInt methodArray1;
    sqInt sz1;
    sqInt header1;
    sqInt ccIndex2;
    sqInt oop12;

	ctxt = aContext;
	while (!(ctxt == nilObj)) {
		if ((fetchClassOf(ctxt)) == (longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassBlockContext << (SHIFT_FOR_WORD))))) {
			home = longAt((ctxt + (BASE_HEADER_SIZE)) + (HomeIndex << (SHIFT_FOR_WORD)));
		} else {
			home = ctxt;
		}
		/* begin findClassOfMethod:forReceiver: */
		meth = longAt((home + (BASE_HEADER_SIZE)) + (MethodIndex << (SHIFT_FOR_WORD)));
		rcvr = longAt((home + (BASE_HEADER_SIZE)) + (ReceiverIndex << (SHIFT_FOR_WORD)));
		/* begin fetchClassOf: */
		if ((rcvr & 1)) {
			currClass = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassInteger << (SHIFT_FOR_WORD)));
			goto l2;
		}
		ccIndex = (((usqInt) (longAt(rcvr))) >> 12) & 31;
		if (ccIndex == 0) {
			currClass = (longAt(rcvr - (BASE_HEADER_SIZE))) & (ALL_BUT_TYPE_MASK);
			goto l2;
		} else {
			/* begin fetchPointer:ofObject: */
			oop1 = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (CompactClasses << (SHIFT_FOR_WORD)));
			currClass = longAt((oop1 + (BASE_HEADER_SIZE)) + ((ccIndex - 1) << (SHIFT_FOR_WORD)));
			goto l2;
		}
	l2:	/* end fetchClassOf: */;
		done = 0;
		while (!(done)) {
			classDict = longAt((currClass + (BASE_HEADER_SIZE)) + (MessageDictionaryIndex << (SHIFT_FOR_WORD)));
			/* begin fetchWordLengthOf: */
			/* begin sizeBitsOf: */
			header = longAt(classDict);
			if ((header & TypeMask) == HeaderTypeSizeAndClass) {
				sz = (longAt(classDict - ((BYTES_PER_WORD) * 2))) & (LONG_SIZE_MASK);
				goto l1;
			} else {
				sz = header & (SIZE_MASK);
				goto l1;
			}
		l1:	/* end sizeBitsOf: */;
			classDictSize = ((usqInt) (sz - (BASE_HEADER_SIZE))) >> (SHIFT_FOR_WORD);
			methodArray = longAt((classDict + (BASE_HEADER_SIZE)) + (MethodArrayIndex << (SHIFT_FOR_WORD)));
			i = 0;
			while (i < (classDictSize - SelectorStart)) {
				if (meth == (longAt((methodArray + (BASE_HEADER_SIZE)) + (i << (SHIFT_FOR_WORD))))) {
					methClass = currClass;
					goto l3;
				}
				i += 1;
			}
			currClass = longAt((currClass + (BASE_HEADER_SIZE)) + (SuperclassIndex << (SHIFT_FOR_WORD)));
			done = currClass == nilObj;
		}
		/* begin fetchClassOf: */
		if ((rcvr & 1)) {
			methClass = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassInteger << (SHIFT_FOR_WORD)));
			goto l3;
		}
		ccIndex1 = (((usqInt) (longAt(rcvr))) >> 12) & 31;
		if (ccIndex1 == 0) {
			methClass = (longAt(rcvr - (BASE_HEADER_SIZE))) & (ALL_BUT_TYPE_MASK);
			goto l3;
		} else {
			/* begin fetchPointer:ofObject: */
			oop11 = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (CompactClasses << (SHIFT_FOR_WORD)));
			methClass = longAt((oop11 + (BASE_HEADER_SIZE)) + ((ccIndex1 - 1) << (SHIFT_FOR_WORD)));
			goto l3;
		}
		methClass = null;
	l3:	/* end findClassOfMethod:forReceiver: */;
		/* begin findSelectorOfMethod:forReceiver: */
		meth1 = longAt((home + (BASE_HEADER_SIZE)) + (MethodIndex << (SHIFT_FOR_WORD)));
		rcvr1 = longAt((home + (BASE_HEADER_SIZE)) + (ReceiverIndex << (SHIFT_FOR_WORD)));
		/* begin fetchClassOf: */
		if ((rcvr1 & 1)) {
			currClass1 = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassInteger << (SHIFT_FOR_WORD)));
			goto l5;
		}
		ccIndex2 = (((usqInt) (longAt(rcvr1))) >> 12) & 31;
		if (ccIndex2 == 0) {
			currClass1 = (longAt(rcvr1 - (BASE_HEADER_SIZE))) & (ALL_BUT_TYPE_MASK);
			goto l5;
		} else {
			/* begin fetchPointer:ofObject: */
			oop12 = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (CompactClasses << (SHIFT_FOR_WORD)));
			currClass1 = longAt((oop12 + (BASE_HEADER_SIZE)) + ((ccIndex2 - 1) << (SHIFT_FOR_WORD)));
			goto l5;
		}
	l5:	/* end fetchClassOf: */;
		done1 = 0;
		while (!(done1)) {
			classDict1 = longAt((currClass1 + (BASE_HEADER_SIZE)) + (MessageDictionaryIndex << (SHIFT_FOR_WORD)));
			/* begin fetchWordLengthOf: */
			/* begin sizeBitsOf: */
			header1 = longAt(classDict1);
			if ((header1 & TypeMask) == HeaderTypeSizeAndClass) {
				sz1 = (longAt(classDict1 - ((BYTES_PER_WORD) * 2))) & (LONG_SIZE_MASK);
				goto l4;
			} else {
				sz1 = header1 & (SIZE_MASK);
				goto l4;
			}
		l4:	/* end sizeBitsOf: */;
			classDictSize1 = ((usqInt) (sz1 - (BASE_HEADER_SIZE))) >> (SHIFT_FOR_WORD);
			methodArray1 = longAt((classDict1 + (BASE_HEADER_SIZE)) + (MethodArrayIndex << (SHIFT_FOR_WORD)));
			i1 = 0;
			while (i1 <= (classDictSize1 - SelectorStart)) {
				if (meth1 == (longAt((methodArray1 + (BASE_HEADER_SIZE)) + (i1 << (SHIFT_FOR_WORD))))) {
					methodSel = longAt((classDict1 + (BASE_HEADER_SIZE)) + ((i1 + SelectorStart) << (SHIFT_FOR_WORD)));
					goto l6;
				}
				i1 += 1;
			}
			currClass1 = longAt((currClass1 + (BASE_HEADER_SIZE)) + (SuperclassIndex << (SHIFT_FOR_WORD)));
			done1 = currClass1 == nilObj;
		}
		methodSel = nilObj;
	l6:	/* end findSelectorOfMethod:forReceiver: */;
		printNum(ctxt);
		print(" ");
		if (!(ctxt == home)) {
			print("[] in ");
		}
		printNameOfClasscount(methClass, 5);
		print(">");
		if (methodSel == nilObj) {
			print("?");
		} else {
			printStringOf(methodSel);
		}
		if (methodSel == (longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (SelectorDoesNotUnderstand << (SHIFT_FOR_WORD))))) {

			/* print arg message selector */

			message = longAt((home + (BASE_HEADER_SIZE)) + ((0 + TempFrameStart) << (SHIFT_FOR_WORD)));
			methodSel = longAt((message + (BASE_HEADER_SIZE)) + (MessageSelectorIndex << (SHIFT_FOR_WORD)));
			print(" ");
			printStringOf(methodSel);
		}
		/* begin cr */
		printf("\n");
		ctxt = longAt((ctxt + (BASE_HEADER_SIZE)) + (SenderIndex << (SHIFT_FOR_WORD)));
	}
	return null;
}


/*	Print n in hex,  in the form '    0x1234', padded to a width of 10 characters
	 in 32-bits ('0x' + 8 nibbles) or 18 characters in 64-bits ('0x' + 16 nibbles) */

sqInt printHex(sqInt n) {
    char buf[35];
    sqInt len;


	/* large enough for a 64-bit value in hex plus the null plus 16 spaces */

	memset(buf,' ',34);
	len = sprintf(buf + 2 + 2 * BYTES_PER_WORD, "0x%lx", (unsigned long)(n));
	printf("%s", buf + len);
	;
	return null;
}


/*	Details: The count argument is used to avoid a possible infinite recursion if classOop is a corrupted object. */

sqInt printNameOfClasscount(sqInt classOop, sqInt cnt) {
	if (cnt <= 0) {
		return print("bad class");
	}
	if ((sizeBitsOf(classOop)) == (7 * (BYTES_PER_WORD))) {

		/* (Metaclass instSize+1 * 4) */

		printNameOfClasscount(longAt((classOop + (BASE_HEADER_SIZE)) + (5 << (SHIFT_FOR_WORD))), cnt - 1);
		print(" class");
	} else {
		printStringOf(longAt((classOop + (BASE_HEADER_SIZE)) + (6 << (SHIFT_FOR_WORD))));
	}
	return null;
}


/*	For testing in Smalltalk, this method should be overridden in a subclass. */

sqInt printNum(sqInt n) {
	printf("%ld", (long) n);
	return null;
}

sqInt printStringOf(sqInt oop) {
    sqInt cnt;
    sqInt fmt;
    sqInt i;

	if ((oop & 1)) {
		return null;
	}
	fmt = (((usqInt) (longAt(oop))) >> 8) & 15;
	if (fmt < 8) {
		return null;
	}
	cnt = ((100 < (lengthOf(oop))) ? 100 : (lengthOf(oop)));
	i = 0;
	while (i < cnt) {
		/* begin printChar: */
		putchar(byteAt((oop + (BASE_HEADER_SIZE)) + i));
		i += 1;
	}
	return null;
}

sqInt printUnbalancedStack(sqInt primIdx) {
	print("Stack unbalanced after ");
	if (!primFailCode) {
		print("successful primitive ");
	} else {
		print("failed primitive ");
	}
	printNum(primIdx);
	/* begin cr */
	printf("\n");
	return null;
}

sqInt push(sqInt object) {
    sqInt sp;

	longAtput((sp = stackPointer + (BYTES_PER_WORD)), object);
	stackPointer = sp;
	return null;
}

sqInt pushBool(sqInt trueOrFalse) {
    sqInt sp;
    sqInt sp1;

	if (trueOrFalse) {
		/* begin push: */
		longAtput((sp = stackPointer + (BYTES_PER_WORD)), trueObj);
		stackPointer = sp;
	} else {
		/* begin push: */
		longAtput((sp1 = stackPointer + (BYTES_PER_WORD)), falseObj);
		stackPointer = sp1;
	}
	return null;
}

sqInt pushFloat(double  f) {
    sqInt object;
    sqInt sp;

	/* begin push: */
	object = floatObjectOf(f);
	longAtput((sp = stackPointer + (BYTES_PER_WORD)), object);
	stackPointer = sp;
	return null;
}

sqInt pushInteger(sqInt integerValue) {
    sqInt sp;

	/* begin push: */
	longAtput((sp = stackPointer + (BYTES_PER_WORD)), ((integerValue << 1) | 1));
	stackPointer = sp;
	return null;
}


/*	Record the given object in a the remap buffer. Objects in this buffer are remapped when a compaction occurs. This facility is used by the interpreter to ensure that objects in temporary variables are properly remapped. */

sqInt pushRemappableOop(sqInt oop) {
	remapBuffer[(remapBufferCount += 1)] = oop;
	return null;
}


/*	Append aWord to aFile in this platforms 'natural' byte order.  (Bytes will be swapped, if
	necessary, when the image is read on a different platform.) Set primFailCode if the
	write fails. */

sqInt putLongtoFile(sqInt aWord, sqImageFile  aFile) {
    sqInt objectsWritten;

	objectsWritten = sqImageFileWrite(&aWord, sizeof(aWord), 1, aFile);
	/* begin success: */
	if (!(objectsWritten == 1)) {
		if (!primFailCode) {
			primFailCode = 1;
		}
	}
	return null;
}


/*	Read an image header from the given file stream, and answer the image format
	version number for the saved image. Exported to allow platform support code to
	query image files for image format number. */

EXPORT(sqInt) readImageFormatFromFileStartingAt(sqImageFile  f, squeakFileOffsetType  imageOffset) {
	checkImageVersionFromstartingAt(f, imageOffset);
	return imageFormatInitialVersion;
}


/*	Read an image from the given file stream, allocating the given amount of memory to its object heap. Fail if the image has an unknown format or requires more than the given amount of memory. */
/*	Details: This method detects when the image was stored on a machine with the opposite byte ordering from this machine and swaps the bytes automatically. Furthermore, it allows the header information to start 512 bytes into the file, since some file transfer programs for the Macintosh apparently prepend a Mac-specific header of this size. Note that this same 512 bytes of prefix area could also be used to store an exec command on Unix systems, allowing one to launch Smalltalk by invoking the image name as a command. */
/*	This code is based on C code by Ian Piumarta and Smalltalk code by Tim Rowledge. Many thanks to both of you!! */

sqInt readImageFromFileHeapSizeStartingAt(sqImageFile  f, usqInt desiredHeapSize, squeakFileOffsetType  imageOffset) {
    sqInt bytesRead;
    sqInt bytesToShift;
    size_t  dataSize;
    sqInt headerSize;
    squeakFileOffsetType  headerStart;
    sqInt heapSize;
    sqInt memStart;
    sqInt minimumMemory;
    sqInt oldBaseAddr;
    sqInt swapBytes;
    sqInt oop;
    sqInt hash;
    sqInt flagsWord;
    sqInt addr;

	swapBytes = checkImageVersionFromstartingAt(f, imageOffset);

	/* record header start position */

	headerStart = (sqImageFilePosition(f)) - (BYTES_PER_WORD);
	headerSize = getLongFromFileswap(f, swapBytes);
	dataSize = getLongFromFileswap(f, swapBytes);
	oldBaseAddr = getLongFromFileswap(f, swapBytes);
	/* begin setSpecialObjectsOop: */
	oop = getLongFromFileswap(f, swapBytes);
	specialObjectsOop = oop;
	/* begin setLastHash: */
	hash = getLongFromFileswap(f, swapBytes);
	lastHash = hash;
	savedWindowSize = getLongFromFileswap(f, swapBytes);
	/* begin oldFormatFullScreenFlag: */
	flagsWord = getLongFromFileswap(f, swapBytes);
	fullScreenFlag = flagsWord & 1;
	extraVMMemory = getLongFromFileswap(f, swapBytes);
	if (lastHash == 0) {

		/* lastHash wasn't stored (e.g. by the cloner); use 999 as the seed */

		/* begin setLastHash: */
		lastHash = 999;
	}
	heapSize = reserveExtraCHeapBytes(desiredHeapSize, extraVMMemory);

	/* need at least 100K of breathing room */

	minimumMemory = dataSize + 100000;
	if (heapSize < minimumMemory) {
		insufficientMemorySpecifiedError();
	}
	if (((memory = (usqInt)allocateMemoryMinimumImageFileHeaderSize(heapSize, minimumMemory, f, headerSize))) == null) {
		insufficientMemoryAvailableError();
	}
	memStart = memory;
	/* begin setMemoryLimit: */
	memoryLimit = (usqInt)(memStart + heapSize) - 24;
	/* begin setEndOfMemory: */
	endOfMemory = (usqInt)memStart + dataSize;
	sqImageFileSeek(f, headerStart + headerSize);
	bytesRead = sqImageFileReadEntireImage(pointerForOop(memory), sizeof(unsigned char), dataSize, f);
	if (bytesRead != dataSize) {
		unableToReadImageError();
	}
	/* begin headerTypeBytesAt:put: */
	headerTypeBytes[0] = ((BYTES_PER_WORD) * 2);
	/* begin headerTypeBytesAt:put: */
	headerTypeBytes[1] = (BYTES_PER_WORD);
	/* begin headerTypeBytesAt:put: */
	headerTypeBytes[2] = 0;
	/* begin headerTypeBytesAt:put: */
	headerTypeBytes[3] = 0;
	if (swapBytes) {
		/* begin reverseBytesInImage */
		/* begin reverseBytesFrom:to: */
		flag("Dan");
		addr = memory;
		while ((((usqInt) addr)) < (((usqInt) endOfMemory))) {
			longAtput(addr, byteSwapped(longAt(addr)));
			addr += BYTES_PER_WORD;
		}
		/* begin byteSwapByteObjects */
		byteSwapByteObjectsFromto(memory + (headerTypeBytes[(longAt(memory)) & TypeMask]), (sqInt)endOfMemory);
	}
	bytesToShift = memStart - oldBaseAddr;
	initializeInterpreter(bytesToShift);
	isBigEnder();
	if ((imageFormatInitialVersion & 1) == 1) {

		/* Low order bit set, indicating that the image was saved from
			a StackInterpreter (Cog) VM. Storage of all Float objects must be
			returned to older object memory format. */

		normalizeFloatOrderingInImage();
	}
	return dataSize;
}


/*	Anwer true if images of the given format are readable by this interpreter. Allows
	a virtual machine to accept selected older image formats.  In our case we can
	select a newer (closure) image format as well as the existing format. Images with
	platform-ordered floats (StackInterpreter and Cog format) are readable but will be
	converted to traditional word ordering. */

sqInt readableFormat(sqInt imageVersion) {
	if ((BYTES_PER_WORD) == 4) {
		return ((imageVersion == 6502) || (imageVersion == 6504)) || (imageVersion == 6505);
	} else {
		return ((imageVersion == 68000) || (imageVersion == 68002)) || (imageVersion == 68003);
	}
	return null;
}


/*	callbackContext is an activation of invokeCallback:stack:registers:jmpbuf:.  Its sender
	 is the interpreter's state prior to the callback.  Reestablish that state. */

EXPORT(sqInt) reestablishContextPriorToCallback(sqInt callbackContext) {
    sqInt calloutContext;
    sqInt tmp;
    sqInt valuePointer;

	if ((fetchClassOf(callbackContext)) != (longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassMethodContext << (SHIFT_FOR_WORD))))) {
		return 0;
	}
	calloutContext = longAt((callbackContext + (BASE_HEADER_SIZE)) + (SenderIndex << (SHIFT_FOR_WORD)));
	/* begin newActiveContext: */
	/* begin storeContextRegisters: */
	longAtput((activeContext + (BASE_HEADER_SIZE)) + (InstructionPointerIndex << (SHIFT_FOR_WORD)), ((((instructionPointer - method) - ((BASE_HEADER_SIZE) - 2)) << 1) | 1));
	/* begin storePointerUnchecked:ofObject:withValue: */
	valuePointer = (((((((usqInt) ((stackPointer - activeContext) - (BASE_HEADER_SIZE))) >> (SHIFT_FOR_WORD)) - TempFrameStart) + 1) << 1) | 1);
	longAtput((activeContext + (BASE_HEADER_SIZE)) + (StackPointerIndex << (SHIFT_FOR_WORD)), valuePointer);
	if ((((usqInt) calloutContext)) < (((usqInt) youngStart))) {
		beRootIfOld(calloutContext);
	}
	activeContext = calloutContext;
	/* begin fetchContextRegisters: */
	tmp = longAt((calloutContext + (BASE_HEADER_SIZE)) + (MethodIndex << (SHIFT_FOR_WORD)));
	if ((tmp & 1)) {
		tmp = longAt((calloutContext + (BASE_HEADER_SIZE)) + (HomeIndex << (SHIFT_FOR_WORD)));
		if ((((usqInt) tmp)) < (((usqInt) youngStart))) {
			beRootIfOld(tmp);
		}
	} else {
		tmp = calloutContext;
	}
	theHomeContext = tmp;
	receiver = longAt((tmp + (BASE_HEADER_SIZE)) + (ReceiverIndex << (SHIFT_FOR_WORD)));
	method = (usqInt)longAt((tmp + (BASE_HEADER_SIZE)) + (MethodIndex << (SHIFT_FOR_WORD)));
	tmp = ((longAt((calloutContext + (BASE_HEADER_SIZE)) + (InstructionPointerIndex << (SHIFT_FOR_WORD)))) >> 1);
	instructionPointer = (usqInt)((method + tmp) + (BASE_HEADER_SIZE)) - 2;
	tmp = ((longAt((calloutContext + (BASE_HEADER_SIZE)) + (StackPointerIndex << (SHIFT_FOR_WORD)))) >> 1);
	stackPointer = (usqInt)(calloutContext + (BASE_HEADER_SIZE)) + (((TempFrameStart + tmp) - 1) * (BYTES_PER_WORD));
	return 1;
}


/*	Map the given oop to its new value during a compaction or 
	become: operation. If it has no forwarding table entry, 
	return the oop itself. */

sqInt remap(sqInt oop) {
    sqInt fwdBlock;

	if (((oop & 1) == 0) && (((longAt(oop)) & (MARK_BIT)) != 0)) {

		/* get the new value for oop from its forwarding block */

		fwdBlock = ((longAt(oop)) & (ALL_BUT_MARK_BIT_AND_TYPE_MASK)) << 1;
		if (DoAssertionChecks) {
			/* begin fwdBlockValidate: */
			if (!(((((usqInt) fwdBlock)) > (((usqInt) endOfMemory))) && (((((usqInt) fwdBlock)) <= (((usqInt) fwdTableNext))) && ((fwdBlock & 3) == 0)))) {
				error("invalid fwd table entry");
			}
		}
		return longAt(fwdBlock);
	}
	return oop;
}


/*	Remove the first process from the given linked list. */

sqInt removeFirstLinkOfList(sqInt aList) {
    sqInt first;
    sqInt last;
    sqInt next;

	first = longAt((aList + (BASE_HEADER_SIZE)) + (FirstLinkIndex << (SHIFT_FOR_WORD)));
	last = longAt((aList + (BASE_HEADER_SIZE)) + (LastLinkIndex << (SHIFT_FOR_WORD)));
	if (first == last) {
		/* begin storePointer:ofObject:withValue: */
		if ((((usqInt) aList)) < (((usqInt) youngStart))) {
			possibleRootStoreIntovalue(aList, nilObj);
		}
		longAtput((aList + (BASE_HEADER_SIZE)) + (FirstLinkIndex << (SHIFT_FOR_WORD)), nilObj);
		/* begin storePointer:ofObject:withValue: */
		if ((((usqInt) aList)) < (((usqInt) youngStart))) {
			possibleRootStoreIntovalue(aList, nilObj);
		}
		longAtput((aList + (BASE_HEADER_SIZE)) + (LastLinkIndex << (SHIFT_FOR_WORD)), nilObj);
	} else {
		next = longAt((first + (BASE_HEADER_SIZE)) + (NextLinkIndex << (SHIFT_FOR_WORD)));
		/* begin storePointer:ofObject:withValue: */
		if ((((usqInt) aList)) < (((usqInt) youngStart))) {
			possibleRootStoreIntovalue(aList, next);
		}
		longAtput((aList + (BASE_HEADER_SIZE)) + (FirstLinkIndex << (SHIFT_FOR_WORD)), next);
	}
	/* begin storePointer:ofObject:withValue: */
	if ((((usqInt) first)) < (((usqInt) youngStart))) {
		possibleRootStoreIntovalue(first, nilObj);
	}
	longAtput((first + (BASE_HEADER_SIZE)) + (NextLinkIndex << (SHIFT_FOR_WORD)), nilObj);
	return first;
}


/*	Remove the given variable location to the extra roots table */

EXPORT(sqInt) removeGCRoot(sqInt *varLoc) {
    sqInt i;
    sqInt *root;

	for (i = 1; i <= extraRootCount; i++) {
		root = extraRoots[i];
		if (root == varLoc) {

			/* swap varLoc with last entry */

			extraRoots[i] = (extraRoots[extraRootCount]);
			extraRootCount -= 1;
			return 1;
		}
	}
	return 0;
}


/*	Restore the original header of the given oop from its 
	forwarding block. */

sqInt restoreHeaderOf(sqInt oop) {
    sqInt fwdBlock;
    sqInt fwdHeader;

	fwdHeader = longAt(oop);
	fwdBlock = (fwdHeader & (ALL_BUT_MARK_BIT_AND_TYPE_MASK)) << 1;
	if (DoAssertionChecks) {
		if ((fwdHeader & (MARK_BIT)) == 0) {
			error("attempting to restore the header of an object that has no forwarding block");
		}
		/* begin fwdBlockValidate: */
		if (!(((((usqInt) fwdBlock)) > (((usqInt) endOfMemory))) && (((((usqInt) fwdBlock)) <= (((usqInt) fwdTableNext))) && ((fwdBlock & 3) == 0)))) {
			error("invalid fwd table entry");
		}
	}
	longAtput(oop, longAt(fwdBlock + (BYTES_PER_WORD)));
	return null;
}


/*	Restore headers smashed by forwarding links */

sqInt restoreHeadersFromtofromandtofrom(sqInt firstIn, sqInt lastIn, sqInt hdrBaseIn, sqInt firstOut, sqInt lastOut, sqInt hdrBaseOut) {
    sqInt header;
    sqInt oop;
    sqInt tablePtr;
    sqInt sz;
    sqInt header1;

	tablePtr = firstIn;
	while ((((usqInt) tablePtr)) <= (((usqInt) lastIn))) {
		oop = longAt(tablePtr);
		header = longAt(hdrBaseIn + (tablePtr - firstIn));
		longAtput(oop, header);
		tablePtr += BYTES_PER_WORD;
	}
	tablePtr = firstOut;
	while ((((usqInt) tablePtr)) <= (((usqInt) lastOut))) {
		oop = longAt(tablePtr);
		header = longAt(hdrBaseOut + (tablePtr - firstOut));
		longAtput(oop, header);
		tablePtr += BYTES_PER_WORD;
	}
	oop = memory + (headerTypeBytes[(longAt(memory)) & TypeMask]);
	while ((((usqInt) oop)) < (((usqInt) endOfMemory))) {
		if (!(((longAt(oop)) & TypeMask) == HeaderTypeFree)) {
			longAtput(oop, (longAt(oop)) & (ALL_BUT_MARK_BIT));
		}
		/* begin objectAfter: */
		if (DoAssertionChecks) {
			if ((((usqInt) oop)) >= (((usqInt) endOfMemory))) {
				error("no objects after the end of memory");
			}
		}
		if (((longAt(oop)) & TypeMask) == HeaderTypeFree) {
			sz = (longAt(oop)) & (ALL_BUT_TYPE_MASK);
		} else {
			/* begin sizeBitsOf: */
			header1 = longAt(oop);
			if ((header1 & TypeMask) == HeaderTypeSizeAndClass) {
				sz = (longAt(oop - ((BYTES_PER_WORD) * 2))) & (LONG_SIZE_MASK);
				goto l1;
			} else {
				sz = header1 & (SIZE_MASK);
				goto l1;
			}
		l1:	/* end sizeBitsOf: */;
		}
		oop = (oop + sz) + (headerTypeBytes[(longAt(oop + sz)) & TypeMask]);
	}
	return null;
}

sqInt resume(sqInt aProcess) {
    sqInt activePriority;
    sqInt activeProc;
    sqInt newPriority;
    sqInt oop;
    sqInt oop1;
    sqInt priority;
    sqInt processList;
    sqInt processLists;
    sqInt oop2;
    sqInt oop11;
    sqInt lastLink;
    sqInt priority1;
    sqInt processList1;
    sqInt processLists1;
    sqInt oop3;
    sqInt oop12;
    sqInt lastLink1;

	/* begin fetchPointer:ofObject: */
	/* begin fetchPointer:ofObject: */
	oop1 = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (SchedulerAssociation << (SHIFT_FOR_WORD)));
	oop = longAt((oop1 + (BASE_HEADER_SIZE)) + (ValueIndex << (SHIFT_FOR_WORD)));
	activeProc = longAt((oop + (BASE_HEADER_SIZE)) + (ActiveProcessIndex << (SHIFT_FOR_WORD)));
	activePriority = ((longAt((activeProc + (BASE_HEADER_SIZE)) + (PriorityIndex << (SHIFT_FOR_WORD)))) >> 1);
	newPriority = ((longAt((aProcess + (BASE_HEADER_SIZE)) + (PriorityIndex << (SHIFT_FOR_WORD)))) >> 1);
	if (newPriority > activePriority) {
		/* begin putToSleep: */
		priority = ((longAt((activeProc + (BASE_HEADER_SIZE)) + (PriorityIndex << (SHIFT_FOR_WORD)))) >> 1);
		/* begin fetchPointer:ofObject: */
		/* begin fetchPointer:ofObject: */
		oop11 = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (SchedulerAssociation << (SHIFT_FOR_WORD)));
		oop2 = longAt((oop11 + (BASE_HEADER_SIZE)) + (ValueIndex << (SHIFT_FOR_WORD)));
		processLists = longAt((oop2 + (BASE_HEADER_SIZE)) + (ProcessListsIndex << (SHIFT_FOR_WORD)));
		processList = longAt((processLists + (BASE_HEADER_SIZE)) + ((priority - 1) << (SHIFT_FOR_WORD)));
		/* begin addLastLink:toList: */
		if ((longAt((processList + (BASE_HEADER_SIZE)) + (FirstLinkIndex << (SHIFT_FOR_WORD)))) == nilObj) {
			/* begin storePointer:ofObject:withValue: */
			if ((((usqInt) processList)) < (((usqInt) youngStart))) {
				possibleRootStoreIntovalue(processList, activeProc);
			}
			longAtput((processList + (BASE_HEADER_SIZE)) + (FirstLinkIndex << (SHIFT_FOR_WORD)), activeProc);
		} else {
			lastLink = longAt((processList + (BASE_HEADER_SIZE)) + (LastLinkIndex << (SHIFT_FOR_WORD)));
			/* begin storePointer:ofObject:withValue: */
			if ((((usqInt) lastLink)) < (((usqInt) youngStart))) {
				possibleRootStoreIntovalue(lastLink, activeProc);
			}
			longAtput((lastLink + (BASE_HEADER_SIZE)) + (NextLinkIndex << (SHIFT_FOR_WORD)), activeProc);
		}
		/* begin storePointer:ofObject:withValue: */
		if ((((usqInt) processList)) < (((usqInt) youngStart))) {
			possibleRootStoreIntovalue(processList, activeProc);
		}
		longAtput((processList + (BASE_HEADER_SIZE)) + (LastLinkIndex << (SHIFT_FOR_WORD)), activeProc);
		/* begin storePointer:ofObject:withValue: */
		if ((((usqInt) activeProc)) < (((usqInt) youngStart))) {
			possibleRootStoreIntovalue(activeProc, processList);
		}
		longAtput((activeProc + (BASE_HEADER_SIZE)) + (MyListIndex << (SHIFT_FOR_WORD)), processList);
		transferTo(aProcess);
	} else {
		/* begin putToSleep: */
		priority1 = ((longAt((aProcess + (BASE_HEADER_SIZE)) + (PriorityIndex << (SHIFT_FOR_WORD)))) >> 1);
		/* begin fetchPointer:ofObject: */
		/* begin fetchPointer:ofObject: */
		oop12 = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (SchedulerAssociation << (SHIFT_FOR_WORD)));
		oop3 = longAt((oop12 + (BASE_HEADER_SIZE)) + (ValueIndex << (SHIFT_FOR_WORD)));
		processLists1 = longAt((oop3 + (BASE_HEADER_SIZE)) + (ProcessListsIndex << (SHIFT_FOR_WORD)));
		processList1 = longAt((processLists1 + (BASE_HEADER_SIZE)) + ((priority1 - 1) << (SHIFT_FOR_WORD)));
		/* begin addLastLink:toList: */
		if ((longAt((processList1 + (BASE_HEADER_SIZE)) + (FirstLinkIndex << (SHIFT_FOR_WORD)))) == nilObj) {
			/* begin storePointer:ofObject:withValue: */
			if ((((usqInt) processList1)) < (((usqInt) youngStart))) {
				possibleRootStoreIntovalue(processList1, aProcess);
			}
			longAtput((processList1 + (BASE_HEADER_SIZE)) + (FirstLinkIndex << (SHIFT_FOR_WORD)), aProcess);
		} else {
			lastLink1 = longAt((processList1 + (BASE_HEADER_SIZE)) + (LastLinkIndex << (SHIFT_FOR_WORD)));
			/* begin storePointer:ofObject:withValue: */
			if ((((usqInt) lastLink1)) < (((usqInt) youngStart))) {
				possibleRootStoreIntovalue(lastLink1, aProcess);
			}
			longAtput((lastLink1 + (BASE_HEADER_SIZE)) + (NextLinkIndex << (SHIFT_FOR_WORD)), aProcess);
		}
		/* begin storePointer:ofObject:withValue: */
		if ((((usqInt) processList1)) < (((usqInt) youngStart))) {
			possibleRootStoreIntovalue(processList1, aProcess);
		}
		longAtput((processList1 + (BASE_HEADER_SIZE)) + (LastLinkIndex << (SHIFT_FOR_WORD)), aProcess);
		/* begin storePointer:ofObject:withValue: */
		if ((((usqInt) aProcess)) < (((usqInt) youngStart))) {
			possibleRootStoreIntovalue(aProcess, processList1);
		}
		longAtput((aProcess + (BASE_HEADER_SIZE)) + (MyListIndex << (SHIFT_FOR_WORD)), processList1);
	}
	return null;
}


/*	Reverse the given range of Display words (at different bit 
	depths, this will reverse different numbers of pixels). Used to 
	give feedback during VM activities such as garbage 
	collection when debugging. It is assumed that the given 
	word range falls entirely within the first line of the Display. */

sqInt reverseDisplayFromto(sqInt startIndex, sqInt endIndex) {
    sqInt dispBitsPtr;
    sqInt displayObj;
    sqInt ptr;
    sqInt reversed;
    sqInt w;

	displayObj = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (TheDisplay << (SHIFT_FOR_WORD)));
	if (!((((displayObj & 1) == 0) && (((((usqInt) (longAt(displayObj))) >> 8) & 15) <= 4)) && ((lengthOf(displayObj)) >= 4))) {
		return null;
	}
	w = fetchIntegerofObject(1, displayObj);
	dispBitsPtr = longAt((displayObj + (BASE_HEADER_SIZE)) + (0 << (SHIFT_FOR_WORD)));
	if ((dispBitsPtr & 1)) {
		return null;
	}
	dispBitsPtr += BASE_HEADER_SIZE;
	for (ptr = (dispBitsPtr + (startIndex * 4)); ptr <= (dispBitsPtr + (endIndex * 4)); ptr += 4) {
		reversed = (long32At(ptr)) ^ 4294967295U;
		longAtput(ptr, reversed);
	}
	/* begin initPrimCall */
	primFailCode = 0;
	displayBitsOfLeftTopRightBottom(displayObj, 0, 0, w, 1);
	ioForceDisplayUpdate();
	return null;
}


/*	Rewrite the cache entry with the given primitive index and matching function pointer */

sqInt rewriteMethodCacheSelclassprimIndex(sqInt selector, sqInt class, sqInt localPrimIndex) {
    void (*primPtr)(void);

	if (localPrimIndex == 0) {
		primPtr = 0;
	} else {
		primPtr = primitiveTable[localPrimIndex];
	}
	rewriteMethodCacheSelclassprimIndexprimFunction(selector, class, localPrimIndex, primPtr);
	return null;
}


/*	Rewrite an existing entry in the method cache with a new primitive 
	index & function address. Used by primExternalCall to make direct jumps to found external prims */

sqInt rewriteMethodCacheSelclassprimIndexprimFunction(sqInt selector, sqInt class, sqInt localPrimIndex, void (*localPrimAddress)(void)) {
    sqInt hash;
    sqInt p;
    sqInt probe;

	hash = selector ^ class;
	for (p = 0; p <= (CacheProbeMax - 1); p += 1) {
		probe = (((usqInt) hash) >> p) & MethodCacheMask;
		if (((methodCache[probe + MethodCacheSelector]) == selector) && ((methodCache[probe + MethodCacheClass]) == class)) {
			methodCache[probe + MethodCachePrim] = localPrimIndex;
			methodCache[probe + MethodCachePrimFunction] = (((long) localPrimAddress));
			return null;
		}
	}
	return null;
}


/*	Send the 4 argument callback message invokeCallback:stack:registers:jmpbuf:
	 to Alien class with the supplied args.  The arguments are raw C addresses
	 and are converted to integer objects on the way. */

EXPORT(sqInt) sendInvokeCallbackStackRegistersJmpbuf(sqInt thunkPtr, sqInt stackPtr, sqInt regsPtr, sqInt jmpBufPtr) {
    sqInt where;
    sqInt oop;
    sqInt oop1;
    sqInt oop2;
    sqInt oop3;
    sqInt i;
    sqInt initialIP;
    sqInt methodHeader;
    sqInt needsLarge;
    sqInt newContext;
    sqInt tempCount;
    sqInt where1;
    sqInt tmp;
    sqInt ccIndex;
    sqInt oop11;
    sqInt valuePointer;

	/* begin pushRemappableOop: */
	oop = positive32BitIntegerFor(jmpBufPtr);
	remapBuffer[(remapBufferCount += 1)] = oop;
	/* begin pushRemappableOop: */
	oop1 = positive32BitIntegerFor(regsPtr);
	remapBuffer[(remapBufferCount += 1)] = oop1;
	/* begin pushRemappableOop: */
	oop2 = positive32BitIntegerFor(stackPtr);
	remapBuffer[(remapBufferCount += 1)] = oop2;
	/* begin pushRemappableOop: */
	oop3 = positive32BitIntegerFor(thunkPtr);
	remapBuffer[(remapBufferCount += 1)] = oop3;
	receiver = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassAlien << (SHIFT_FOR_WORD)));
	/* begin fetchClassOfNonInt: */
	ccIndex = (((usqInt) (longAt(receiver))) >> 12) & 31;
	if (ccIndex == 0) {
		lkupClass = (longAt(receiver - (BASE_HEADER_SIZE))) & (ALL_BUT_TYPE_MASK);
		goto l1;
	} else {
		/* begin fetchPointer:ofObject: */
		oop11 = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (CompactClasses << (SHIFT_FOR_WORD)));
		lkupClass = longAt((oop11 + (BASE_HEADER_SIZE)) + ((ccIndex - 1) << (SHIFT_FOR_WORD)));
		goto l1;
	}
l1:	/* end fetchClassOfNonInt: */;
	messageSelector = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (InvokeCallbackSelector << (SHIFT_FOR_WORD)));
	if (!(lookupInMethodCacheSelclass(messageSelector, lkupClass))) {
		if (!(lookupMethodNoMNUEtcInClass(lkupClass))) {
			return 0;
		}
	}
	if (primitiveIndex != 0) {
		return 0;
	}
	/* begin storeContextRegisters: */
	longAtput((activeContext + (BASE_HEADER_SIZE)) + (InstructionPointerIndex << (SHIFT_FOR_WORD)), ((((instructionPointer - method) - ((BASE_HEADER_SIZE) - 2)) << 1) | 1));
	/* begin storePointerUnchecked:ofObject:withValue: */
	valuePointer = (((((((usqInt) ((stackPointer - activeContext) - (BASE_HEADER_SIZE))) >> (SHIFT_FOR_WORD)) - TempFrameStart) + 1) << 1) | 1);
	longAtput((activeContext + (BASE_HEADER_SIZE)) + (StackPointerIndex << (SHIFT_FOR_WORD)), valuePointer);
	/* begin internalJustActivateNewMethod */
	methodHeader = longAt((newMethod + (BASE_HEADER_SIZE)) + (HeaderIndex << (SHIFT_FOR_WORD)));
	needsLarge = methodHeader & LargeContextBit;
	if ((needsLarge == 0) && (freeContexts != NilContext)) {
		newContext = freeContexts;
		/* begin setFreeContextsAfter: */
		freeContexts = longAt((newContext + (BASE_HEADER_SIZE)) + (0 << (SHIFT_FOR_WORD)));
	} else {
		newContext = allocateOrRecycleContext(needsLarge);
	}
	initialIP = ((LiteralStart + ((((usqInt) methodHeader) >> 10) & 255)) * (BYTES_PER_WORD)) + 1;
	tempCount = (((usqInt) methodHeader) >> 19) & 63;
	where1 = newContext + (BASE_HEADER_SIZE);
	longAtput(where1 + (SenderIndex << (SHIFT_FOR_WORD)), activeContext);
	longAtput(where1 + (InstructionPointerIndex << (SHIFT_FOR_WORD)), ((initialIP << 1) | 1));
	longAtput(where1 + (StackPointerIndex << (SHIFT_FOR_WORD)), ((tempCount << 1) | 1));
	longAtput(where1 + (MethodIndex << (SHIFT_FOR_WORD)), newMethod);
	longAtput(where1 + (ReceiverIndex << (SHIFT_FOR_WORD)), receiver);
	needsLarge = nilObj;
	for (i = (ReceiverIndex + 1); i <= (tempCount + ReceiverIndex); i += 1) {
		longAtput(where1 + (i << (SHIFT_FOR_WORD)), needsLarge);
	}
	reclaimableContextCount += 1;
	activeContext = newContext;
	where = (activeContext + (BASE_HEADER_SIZE)) + (ReceiverIndex << (SHIFT_FOR_WORD));
	longAtput(where + (1 << (SHIFT_FOR_WORD)), popRemappableOop());
	longAtput(where + (2 << (SHIFT_FOR_WORD)), popRemappableOop());
	longAtput(where + (3 << (SHIFT_FOR_WORD)), popRemappableOop());
	longAtput(where + (4 << (SHIFT_FOR_WORD)), popRemappableOop());
	/* begin fetchContextRegisters: */
	tmp = longAt((activeContext + (BASE_HEADER_SIZE)) + (MethodIndex << (SHIFT_FOR_WORD)));
	if ((tmp & 1)) {
		tmp = longAt((activeContext + (BASE_HEADER_SIZE)) + (HomeIndex << (SHIFT_FOR_WORD)));
		if ((((usqInt) tmp)) < (((usqInt) youngStart))) {
			beRootIfOld(tmp);
		}
	} else {
		tmp = activeContext;
	}
	theHomeContext = tmp;
	receiver = longAt((tmp + (BASE_HEADER_SIZE)) + (ReceiverIndex << (SHIFT_FOR_WORD)));
	method = (usqInt)longAt((tmp + (BASE_HEADER_SIZE)) + (MethodIndex << (SHIFT_FOR_WORD)));
	tmp = ((longAt((activeContext + (BASE_HEADER_SIZE)) + (InstructionPointerIndex << (SHIFT_FOR_WORD)))) >> 1);
	instructionPointer = (usqInt)((method + tmp) + (BASE_HEADER_SIZE)) - 2;
	tmp = ((longAt((activeContext + (BASE_HEADER_SIZE)) + (StackPointerIndex << (SHIFT_FOR_WORD)))) >> 1);
	stackPointer = (usqInt)(activeContext + (BASE_HEADER_SIZE)) + (((TempFrameStart + tmp) - 1) * (BYTES_PER_WORD));
	callInterpreter();
	return 1;
}

sqInt setCompilerInitialized(sqInt newFlag) {
    sqInt oldFlag;

	oldFlag = compilerInitialized;
	compilerInitialized = newFlag;
	return oldFlag;
}

sqInt setFullScreenFlag(sqInt value) {
	fullScreenFlag = value;
	return null;
}

sqInt setInterruptCheckCounter(sqInt value) {
	interruptCheckCounter = value;
	return null;
}

sqInt setInterruptKeycode(sqInt value) {
	interruptKeycode = value;
	return null;
}

sqInt setInterruptPending(sqInt value) {
	interruptPending = value;
	return null;
}


/*	A default substitute for unimplemented ioUtcWithOffset external function. */

sqInt setMicroSecondsandOffset(sqLong *microSeconds, int *utcOffset) {
	flag("toRemove");
	return -1;
}

sqInt setNextWakeupTick(sqInt value) {
	nextWakeupTick = value;
	return null;
}

sqInt setSavedWindowSize(sqInt value) {
	savedWindowSize = value;
	return null;
}


/*	Reduce the number if indexable fields in obj, a pointer object, to nSlots. Convert the
	unused residual to a free chunk. Word and byte indexable objects are not changed.
	Answer the number of bytes returned to free memory, which may be zero if no change
	was possible. */

sqInt shortentoIndexableSize(sqInt obj, sqInt nSlots) {
    sqInt deltaBytes;
    sqInt desiredLength;
    sqInt fixedFields;
    sqInt fmt;
    sqInt hdr;
    sqInt indexableFields;
    sqInt totalLength;
    sqInt sz;
    sqInt class;
    sqInt classFormat;
    sqInt ccIndex;
    sqInt oop1;

	if (!(((((usqInt) (longAt(obj))) >> 8) & 15) <= 4)) {
		return 0;
	}
	if (!(nSlots > 0)) {
		return 0;
	}
	hdr = longAt(obj);
	fmt = (((usqInt) hdr) >> 8) & 15;
	/* begin lengthOf:baseHeader:format: */
	if ((hdr & TypeMask) == HeaderTypeSizeAndClass) {
		sz = (longAt(obj - ((BYTES_PER_WORD) * 2))) & (LONG_SIZE_MASK);
	} else {
		sz = hdr & (SIZE_MASK);
	}
	sz -= hdr & (SIZE_4_BIT);
	if (fmt <= 4) {
		totalLength = ((usqInt) (sz - (BASE_HEADER_SIZE))) >> (SHIFT_FOR_WORD);
		goto l1;
	}
	if (fmt < 8) {
		totalLength = ((usqInt) (sz - (BASE_HEADER_SIZE))) >> 2;
		goto l1;
	} else {
		totalLength = (sz - (BASE_HEADER_SIZE)) - (fmt & 3);
		goto l1;
	}
l1:	/* end lengthOf:baseHeader:format: */;
	/* begin fixedFieldsOf:format:length: */
	if ((fmt > 4) || (fmt == 2)) {
		fixedFields = 0;
		goto l2;
	}
	if (fmt < 2) {
		fixedFields = totalLength;
		goto l2;
	}
	/* begin fetchClassOf: */
	if ((obj & 1)) {
		class = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassInteger << (SHIFT_FOR_WORD)));
		goto l3;
	}
	ccIndex = (((usqInt) (longAt(obj))) >> 12) & 31;
	if (ccIndex == 0) {
		class = (longAt(obj - (BASE_HEADER_SIZE))) & (ALL_BUT_TYPE_MASK);
		goto l3;
	} else {
		/* begin fetchPointer:ofObject: */
		oop1 = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (CompactClasses << (SHIFT_FOR_WORD)));
		class = longAt((oop1 + (BASE_HEADER_SIZE)) + ((ccIndex - 1) << (SHIFT_FOR_WORD)));
		goto l3;
	}
l3:	/* end fetchClassOf: */;
	classFormat = (longAt((class + (BASE_HEADER_SIZE)) + (InstanceSpecificationIndex << (SHIFT_FOR_WORD)))) - 1;
	fixedFields = (((((usqInt) classFormat) >> 11) & 192) + ((((usqInt) classFormat) >> 2) & 63)) - 1;
l2:	/* end fixedFieldsOf:format:length: */;
	indexableFields = totalLength - fixedFields;
	if (nSlots >= indexableFields) {
		return 0;
	}
	desiredLength = fixedFields + nSlots;
	deltaBytes = (totalLength - desiredLength) * (BYTES_PER_WORD);
	/* begin setSizeOfFree:to: */
	longAtput((obj + (BASE_HEADER_SIZE)) + (desiredLength * (BYTES_PER_WORD)), (deltaBytes & (ALL_BUT_TYPE_MASK)) | HeaderTypeFree);
	
	switch ((longAt(obj)) & TypeMask) {
	case HeaderTypeSizeAndClass:
				longAtput(obj - ((BASE_HEADER_SIZE) * 2), (longAt(obj - ((BYTES_PER_WORD) * 2))) - deltaBytes);
		break;
	case HeaderTypeClass:
	case HeaderTypeShort:
				longAtput(obj, (((hdr | (SIZE_MASK)) - (SIZE_MASK))) | ((hdr & (SIZE_MASK)) - deltaBytes));
		break;
	default:
		error("Case not found and no otherwise clause");
	}
	return deltaBytes;
}


/*	Repaint the portion of the Smalltalk screen bounded by the affected rectangle. Used to synchronize the screen after a Bitblt to the Smalltalk Display object. */

sqInt showDisplayBitsLeftTopRightBottom(sqInt aForm, sqInt l, sqInt t, sqInt r, sqInt b) {
	if (deferDisplayUpdates) {
		return null;
	}
	displayBitsOfLeftTopRightBottom(aForm, l, t, r, b);
	return null;
}


/*	Record the given semaphore index in the double buffer semaphores array to be signaled at the next convenient moment. Force a real interrupt check as soon as possible. */

sqInt signalSemaphoreWithIndex(sqInt index) {
	if (index <= 0) {
		return null;
	}
	if (semaphoresUseBufferA) {
		if (semaphoresToSignalCountA < SemaphoresToSignalSize) {
			semaphoresToSignalCountA += 1;
			semaphoresToSignalA[semaphoresToSignalCountA] = index;
		}
	} else {
		if (semaphoresToSignalCountB < SemaphoresToSignalSize) {
			semaphoresToSignalCountB += 1;
			semaphoresToSignalB[semaphoresToSignalCountB] = index;
		}
	}
	/* begin forceInterruptCheck */
	interruptCheckCounter = -1000;
	nextPollTick = 0;
	return null;
}


/*	Return a full 32 bit integer object for the given integer value */

sqInt signed32BitIntegerFor(int integerValue) {
    sqInt largeClass;
    sqInt newLargeInteger;
    sqInt value;

	if (
# ifdef SQ_HOST32  // cast to int for 64 bit image on 32 bit host
		(((((int) integerValue)) ^ ((((int) integerValue)) << 1)) >= 0)
# else
		((integerValue >= -1073741824) && (integerValue <= 1073741823))
# endif  // SQ_HOST32
	) {
		return ((integerValue << 1) | 1);
	}
	if (integerValue < 0) {
		largeClass = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassLargeNegativeInteger << (SHIFT_FOR_WORD)));
		value = 0 - integerValue;
	} else {
		largeClass = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassLargePositiveInteger << (SHIFT_FOR_WORD)));
		value = integerValue;
	}
	newLargeInteger = instantiateClassindexableSize(largeClass, 4);
	byteAtput((newLargeInteger + (BASE_HEADER_SIZE)) + 3, (((usqInt) value) >> 24) & 255);
	byteAtput((newLargeInteger + (BASE_HEADER_SIZE)) + 2, (((usqInt) value) >> 16) & 255);
	byteAtput((newLargeInteger + (BASE_HEADER_SIZE)) + 1, (((usqInt) value) >> 8) & 255);
	byteAtput((newLargeInteger + (BASE_HEADER_SIZE)) + 0, value & 255);
	return newLargeInteger;
}


/*	Convert the given object into an integer value.
	The object may be either a positive ST integer or a four-byte LargeInteger. */

int signed32BitValueOf(sqInt oop) {
    sqInt largeClass;
    sqInt negative;
    int value;
    sqInt ccIndex;
    sqInt oop1;

	if ((oop & 1)) {
		return (oop >> 1);
	}
	if ((lengthOf(oop)) > 4) {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		return null;
	}
	/* begin fetchClassOf: */
	if ((oop & 1)) {
		largeClass = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassInteger << (SHIFT_FOR_WORD)));
		goto l1;
	}
	ccIndex = (((usqInt) (longAt(oop))) >> 12) & 31;
	if (ccIndex == 0) {
		largeClass = (longAt(oop - (BASE_HEADER_SIZE))) & (ALL_BUT_TYPE_MASK);
		goto l1;
	} else {
		/* begin fetchPointer:ofObject: */
		oop1 = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (CompactClasses << (SHIFT_FOR_WORD)));
		largeClass = longAt((oop1 + (BASE_HEADER_SIZE)) + ((ccIndex - 1) << (SHIFT_FOR_WORD)));
		goto l1;
	}
l1:	/* end fetchClassOf: */;
	if (largeClass == (longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassLargePositiveInteger << (SHIFT_FOR_WORD))))) {
		negative = 0;
	} else {
		if (largeClass == (longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassLargeNegativeInteger << (SHIFT_FOR_WORD))))) {
			negative = 1;
		} else {
			/* begin primitiveFail */
			if (primFailCode == 0) {
				primFailCode = 1;
			}
			return null;
		}
	}
	if ((lengthOf(oop)) != 4) {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		return null;
	}

	/* Fail if value exceeds range of a 32-bit twos-complement signed integer. */

	value = (((byteAt((oop + (BASE_HEADER_SIZE)) + 0)) + ((byteAt((oop + (BASE_HEADER_SIZE)) + 1)) << 8)) + ((byteAt((oop + (BASE_HEADER_SIZE)) + 2)) << 16)) + ((byteAt((oop + (BASE_HEADER_SIZE)) + 3)) << 24);
	if (negative) {

		/* perform subtraction using unsigned int to prevent undefined result
				for optimizing C compilers in the case of value = 16r80000000 */

		value = 0 - (((unsigned int) value));
		if (value >= 0) {
			/* begin primitiveFail */
			if (primFailCode == 0) {
				primFailCode = 1;
			}
			return null;
		}
	} else {
		if (value < 0) {
			/* begin primitiveFail */
			if (primFailCode == 0) {
				primFailCode = 1;
			}
			return null;
		}
	}
	return value;
}


/*	Return a Large Integer object for the given integer value */

sqInt signed64BitIntegerFor(sqLong integerValue) {
    usqInt highWord;
    sqInt i;
    sqInt intValue;
    sqInt largeClass;
    unsigned sqLong magnitude;
    sqInt newLargeInteger;
    sqInt sz;

	if (integerValue < 0) {
		largeClass = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassLargeNegativeInteger << (SHIFT_FOR_WORD)));
		magnitude = 0 - integerValue;
	} else {
		largeClass = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassLargePositiveInteger << (SHIFT_FOR_WORD)));
		magnitude = integerValue;
	}
	if (magnitude <= 2147483647U) {
		return signed32BitIntegerFor(integerValue);
	}
	highWord = magnitude >> 32;
	if (highWord == 0) {
		sz = 4;
	} else {
		sz = 5;
		if (!(((highWord = ((usqInt) highWord) >> 8)) == 0)) {
			sz += 1;
		}
		if (!(((highWord = ((usqInt) highWord) >> 8)) == 0)) {
			sz += 1;
		}
		if (!(((highWord = ((usqInt) highWord) >> 8)) == 0)) {
			sz += 1;
		}
	}
	newLargeInteger = instantiateClassindexableSize(largeClass, sz);
	for (i = 0; i <= (sz - 1); i += 1) {
		intValue = (magnitude >> (i * 8)) & 255;
		byteAtput((newLargeInteger + (BASE_HEADER_SIZE)) + i, intValue);
	}
	return newLargeInteger;
}


/*	Convert the given object into an integer value.
	The object may be either a positive ST integer or a eight-byte LargeInteger. */

sqLong signed64BitValueOf(sqInt oop) {
    sqInt i;
    sqInt largeClass;
    sqInt negative;
    sqInt sz;
    sqInt szsqLong;
    sqLong value;
    sqInt header;
    sqInt sz1;
    sqInt ccIndex;
    sqInt oop1;

	if ((oop & 1)) {
		return ((sqLong) ((oop >> 1)));
	}
	/* begin lengthOf: */
	header = longAt(oop);
	/* begin lengthOf:baseHeader:format: */
	if ((header & TypeMask) == HeaderTypeSizeAndClass) {
		sz1 = (longAt(oop - ((BYTES_PER_WORD) * 2))) & (LONG_SIZE_MASK);
	} else {
		sz1 = header & (SIZE_MASK);
	}
	sz1 -= header & (SIZE_4_BIT);
	if (((((usqInt) header) >> 8) & 15) <= 4) {
		sz = ((usqInt) (sz1 - (BASE_HEADER_SIZE))) >> (SHIFT_FOR_WORD);
		goto l1;
	}
	if (((((usqInt) header) >> 8) & 15) < 8) {
		sz = ((usqInt) (sz1 - (BASE_HEADER_SIZE))) >> 2;
		goto l1;
	} else {
		sz = (sz1 - (BASE_HEADER_SIZE)) - (((((usqInt) header) >> 8) & 15) & 3);
		goto l1;
	}
l1:	/* end lengthOf:baseHeader:format: */;
	if (sz > 8) {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		return null;
	}
	/* begin fetchClassOf: */
	if ((oop & 1)) {
		largeClass = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassInteger << (SHIFT_FOR_WORD)));
		goto l2;
	}
	ccIndex = (((usqInt) (longAt(oop))) >> 12) & 31;
	if (ccIndex == 0) {
		largeClass = (longAt(oop - (BASE_HEADER_SIZE))) & (ALL_BUT_TYPE_MASK);
		goto l2;
	} else {
		/* begin fetchPointer:ofObject: */
		oop1 = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (CompactClasses << (SHIFT_FOR_WORD)));
		largeClass = longAt((oop1 + (BASE_HEADER_SIZE)) + ((ccIndex - 1) << (SHIFT_FOR_WORD)));
		goto l2;
	}
l2:	/* end fetchClassOf: */;
	if (largeClass == (longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassLargePositiveInteger << (SHIFT_FOR_WORD))))) {
		negative = 0;
	} else {
		if (largeClass == (longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassLargeNegativeInteger << (SHIFT_FOR_WORD))))) {
			negative = 1;
		} else {
			/* begin primitiveFail */
			if (primFailCode == 0) {
				primFailCode = 1;
			}
			return null;
		}
	}
	szsqLong = sizeof(sqLong);
	if (sz > szsqLong) {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		return null;
	}
	value = 0;
	for (i = 0; i <= (sz - 1); i += 1) {
		value += (((sqLong) (byteAt((oop + (BASE_HEADER_SIZE)) + i)))) << (i * 8);
	}
	if (negative) {

		/* perform subtraction using unsigned usqLong to prevent undefined result
				for optimizing C compilers in the case of value = 16r8000000000000000 */

		value = 0 - (((usqLong) value));
		if (value >= 0) {
			/* begin primitiveFail */
			if (primFailCode == 0) {
				primFailCode = 1;
			}
			return null;
		}
	} else {
		if (value < 0) {
			/* begin primitiveFail */
			if (primFailCode == 0) {
				primFailCode = 1;
			}
			return null;
		}
	}
	return value;
}


/*	Answer the number of bytes in the given object, including its base header, rounded up to an integral number of words. */
/*	Note: byte indexable objects need to have low bits subtracted from this size. */

sqInt sizeBitsOf(sqInt oop) {
    sqInt header;

	header = longAt(oop);
	if ((header & TypeMask) == HeaderTypeSizeAndClass) {
		return (longAt(oop - ((BYTES_PER_WORD) * 2))) & (LONG_SIZE_MASK);
	} else {
		return header & (SIZE_MASK);
	}
	return null;
}


/*	Return the number of indexable fields of the given object. This method is to be called from an automatically generated C primitive. The argument is assumed to be a pointer to the first indexable field of a words or bytes object; the object header starts 4 bytes before that. */
/*	Note: Only called by translated primitive code. */

sqInt sizeOfSTArrayFromCPrimitive(void *cPtr) {
    sqInt oop;
    sqInt header;
    sqInt sz;

	oop = (oopForPointer(((char *) cPtr))) - (BASE_HEADER_SIZE);
	if (!(((oop & 1) == 0) && (isWordsOrBytesNonInt(oop)))) {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		return 0;
	}
	/* begin lengthOf: */
	header = longAt(oop);
	/* begin lengthOf:baseHeader:format: */
	if ((header & TypeMask) == HeaderTypeSizeAndClass) {
		sz = (longAt(oop - ((BYTES_PER_WORD) * 2))) & (LONG_SIZE_MASK);
	} else {
		sz = header & (SIZE_MASK);
	}
	sz -= header & (SIZE_4_BIT);
	if (((((usqInt) header) >> 8) & 15) <= 4) {
		return ((usqInt) (sz - (BASE_HEADER_SIZE))) >> (SHIFT_FOR_WORD);
	}
	if (((((usqInt) header) >> 8) & 15) < 8) {
		return ((usqInt) (sz - (BASE_HEADER_SIZE))) >> 2;
	} else {
		return (sz - (BASE_HEADER_SIZE)) - (((((usqInt) header) >> 8) & 15) & 3);
	}
	return null;
}


/*	Returns the number of slots in the receiver.
	If the receiver is a byte object, return the number of bytes.
	Otherwise return the number of words. */

sqInt slotSizeOf(sqInt oop) {
    sqInt header;
    sqInt sz;

	if ((oop & 1)) {
		return 0;
	}
	/* begin lengthOf: */
	header = longAt(oop);
	/* begin lengthOf:baseHeader:format: */
	if ((header & TypeMask) == HeaderTypeSizeAndClass) {
		sz = (longAt(oop - ((BYTES_PER_WORD) * 2))) & (LONG_SIZE_MASK);
	} else {
		sz = header & (SIZE_MASK);
	}
	sz -= header & (SIZE_4_BIT);
	if (((((usqInt) header) >> 8) & 15) <= 4) {
		return ((usqInt) (sz - (BASE_HEADER_SIZE))) >> (SHIFT_FOR_WORD);
	}
	if (((((usqInt) header) >> 8) & 15) < 8) {
		return ((usqInt) (sz - (BASE_HEADER_SIZE))) >> 2;
	} else {
		return (sz - (BASE_HEADER_SIZE)) - (((((usqInt) header) >> 8) & 15) & 3);
	}
	return null;
}


/*	update state of active context */

sqInt snapshot(sqInt embedded) {
    sqInt activeProc;
    sqInt dataSize;
    sqInt rcvr;
    void *setMacType;
    sqInt top;
    sqInt sp;
    sqInt sp1;
    sqInt sp2;
    sqInt oop;
    sqInt oop1;
    sqInt valuePointer;
    sqInt fmt;
    sqInt header;
    sqInt i;
    sqInt oop2;
    sqInt sz;
    sqInt header1;
    sqInt i1;
    sqInt oop11;
    sqInt sz1;
    sqInt header2;

	if (compilerInitialized) {
		compilerPreSnapshot();
	} else {
		/* begin storeContextRegisters: */
		longAtput((activeContext + (BASE_HEADER_SIZE)) + (InstructionPointerIndex << (SHIFT_FOR_WORD)), ((((instructionPointer - method) - ((BASE_HEADER_SIZE) - 2)) << 1) | 1));
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer = (((((((usqInt) ((stackPointer - activeContext) - (BASE_HEADER_SIZE))) >> (SHIFT_FOR_WORD)) - TempFrameStart) + 1) << 1) | 1);
		longAtput((activeContext + (BASE_HEADER_SIZE)) + (StackPointerIndex << (SHIFT_FOR_WORD)), valuePointer);
	}
	/* begin fetchPointer:ofObject: */
	/* begin fetchPointer:ofObject: */
	oop1 = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (SchedulerAssociation << (SHIFT_FOR_WORD)));
	oop = longAt((oop1 + (BASE_HEADER_SIZE)) + (ValueIndex << (SHIFT_FOR_WORD)));
	activeProc = longAt((oop + (BASE_HEADER_SIZE)) + (ActiveProcessIndex << (SHIFT_FOR_WORD)));
	/* begin storePointer:ofObject:withValue: */
	if ((((usqInt) activeProc)) < (((usqInt) youngStart))) {
		possibleRootStoreIntovalue(activeProc, (sqInt)activeContext);
	}
	longAtput((activeProc + (BASE_HEADER_SIZE)) + (SuspendedContextIndex << (SHIFT_FOR_WORD)), activeContext);
	incrementalGC();
	fullGC();
	/* begin snapshotCleanUp */
	oop2 = memory + (headerTypeBytes[(longAt(memory)) & TypeMask]);
	while ((((usqInt) oop2)) < (((usqInt) endOfMemory))) {
		if (!(((longAt(oop2)) & TypeMask) == HeaderTypeFree)) {
			header = longAt(oop2);
			fmt = (((usqInt) header) >> 8) & 15;
			if ((fmt == 3) && ((((((usqInt) header) >> 12) & 31) == 13) || ((((((usqInt) header) >> 12) & 31) == 14) || (((((usqInt) header) >> 12) & 31) == 4)))) {
				/* begin sizeBitsOf: */
				header1 = longAt(oop2);
				if ((header1 & TypeMask) == HeaderTypeSizeAndClass) {
					sz = (longAt(oop2 - ((BYTES_PER_WORD) * 2))) & (LONG_SIZE_MASK);
					goto l1;
				} else {
					sz = header1 & (SIZE_MASK);
					goto l1;
				}
			l1:	/* end sizeBitsOf: */;
				for (i = ((lastPointerOf(oop2)) + (BYTES_PER_WORD)); i <= (sz - (BASE_HEADER_SIZE)); i += (BYTES_PER_WORD)) {
					longAtput(oop2 + i, nilObj);
				}
			}
			if (fmt >= 12) {
				if ((primitiveIndexOf(oop2)) == PrimitiveExternalCallIndex) {
					flushExternalPrimitiveOf(oop2);
				}
			}
		}
		/* begin objectAfter: */
		if (DoAssertionChecks) {
			if ((((usqInt) oop2)) >= (((usqInt) endOfMemory))) {
				error("no objects after the end of memory");
			}
		}
		if (((longAt(oop2)) & TypeMask) == HeaderTypeFree) {
			sz1 = (longAt(oop2)) & (ALL_BUT_TYPE_MASK);
		} else {
			/* begin sizeBitsOf: */
			header2 = longAt(oop2);
			if ((header2 & TypeMask) == HeaderTypeSizeAndClass) {
				sz1 = (longAt(oop2 - ((BYTES_PER_WORD) * 2))) & (LONG_SIZE_MASK);
				goto l2;
			} else {
				sz1 = header2 & (SIZE_MASK);
				goto l2;
			}
		l2:	/* end sizeBitsOf: */;
		}
		oop2 = (oop2 + sz1) + (headerTypeBytes[(longAt(oop2 + sz1)) & TypeMask]);
	}
	/* begin clearRootsTable */
	for (i1 = 1; i1 <= rootTableCount; i1 += 1) {
		oop11 = rootTable[i1];
		longAtput(oop11, (longAt(oop11)) & (ALL_BUT_ROOT_BIT));
		rootTable[i1] = 0;
	}
	rootTableCount = 0;

	/* Assume all objects are below the start of the free block */

	dataSize = freeBlock - memory;
	if (!primFailCode) {
		/* begin popStack */
		top = longAt(stackPointer);
		stackPointer -= BYTES_PER_WORD;
		rcvr = top;
		/* begin push: */
		longAtput((sp = stackPointer + (BYTES_PER_WORD)), trueObj);
		stackPointer = sp;
		writeImageFile(dataSize);
		if (!(embedded)) {

			/* set Mac file type and creator; this is a noop on other platforms */

			setMacType = ioLoadFunctionFrom("setMacFileTypeAndCreator", "FilePlugin");
			if (!(setMacType == 0)) {
				((sqInt (*)(char *, char *, char *))setMacType)(imageName, "STim", "FAST");
			}
		}
		/* begin pop: */
		stackPointer -= 1 * (BYTES_PER_WORD);
	}
	beRootIfOld((sqInt)activeContext);
	if (!primFailCode) {
		/* begin push: */
		longAtput((sp1 = stackPointer + (BYTES_PER_WORD)), falseObj);
		stackPointer = sp1;
	} else {
		/* begin push: */
		longAtput((sp2 = stackPointer + (BYTES_PER_WORD)), rcvr);
		stackPointer = sp2;
	}
	if (compilerInitialized) {
		compilerPostSnapshot();
	}
	return null;
}


/*	Return one of the objects in the SpecialObjectsArray */

sqInt splObj(sqInt index) {
	return longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (index << (SHIFT_FOR_WORD)));
}


/*	Return what ST would return for <obj> at: index. */

sqInt stObjectat(sqInt array, sqInt index) {
    sqInt fixedFields;
    sqInt fmt;
    sqInt hdr;
    sqInt stSize;
    sqInt totalLength;
    sqInt sp;
    sqInt sz;
    sqInt class;
    sqInt classFormat;
    sqInt ccIndex;
    sqInt oop1;

	hdr = longAt(array);
	fmt = (((usqInt) hdr) >> 8) & 15;
	/* begin lengthOf:baseHeader:format: */
	if ((hdr & TypeMask) == HeaderTypeSizeAndClass) {
		sz = (longAt(array - ((BYTES_PER_WORD) * 2))) & (LONG_SIZE_MASK);
	} else {
		sz = hdr & (SIZE_MASK);
	}
	sz -= hdr & (SIZE_4_BIT);
	if (fmt <= 4) {
		totalLength = ((usqInt) (sz - (BASE_HEADER_SIZE))) >> (SHIFT_FOR_WORD);
		goto l2;
	}
	if (fmt < 8) {
		totalLength = ((usqInt) (sz - (BASE_HEADER_SIZE))) >> 2;
		goto l2;
	} else {
		totalLength = (sz - (BASE_HEADER_SIZE)) - (fmt & 3);
		goto l2;
	}
l2:	/* end lengthOf:baseHeader:format: */;
	/* begin fixedFieldsOf:format:length: */
	if ((fmt > 4) || (fmt == 2)) {
		fixedFields = 0;
		goto l3;
	}
	if (fmt < 2) {
		fixedFields = totalLength;
		goto l3;
	}
	/* begin fetchClassOf: */
	if ((array & 1)) {
		class = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassInteger << (SHIFT_FOR_WORD)));
		goto l4;
	}
	ccIndex = (((usqInt) (longAt(array))) >> 12) & 31;
	if (ccIndex == 0) {
		class = (longAt(array - (BASE_HEADER_SIZE))) & (ALL_BUT_TYPE_MASK);
		goto l4;
	} else {
		/* begin fetchPointer:ofObject: */
		oop1 = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (CompactClasses << (SHIFT_FOR_WORD)));
		class = longAt((oop1 + (BASE_HEADER_SIZE)) + ((ccIndex - 1) << (SHIFT_FOR_WORD)));
		goto l4;
	}
l4:	/* end fetchClassOf: */;
	classFormat = (longAt((class + (BASE_HEADER_SIZE)) + (InstanceSpecificationIndex << (SHIFT_FOR_WORD)))) - 1;
	fixedFields = (((((usqInt) classFormat) >> 11) & 192) + ((((usqInt) classFormat) >> 2) & 63)) - 1;
l3:	/* end fixedFieldsOf:format:length: */;
	if ((fmt == 3) && ((((((usqInt) hdr) >> 12) & 31) == 13) || ((((((usqInt) hdr) >> 12) & 31) == 14) || (((((usqInt) hdr) >> 12) & 31) == 4)))) {
		/* begin fetchStackPointerOf: */
		sp = longAt((array + (BASE_HEADER_SIZE)) + (StackPointerIndex << (SHIFT_FOR_WORD)));
		if (!((sp & 1))) {
			stSize = 0;
			goto l1;
		}
		stSize = (sp >> 1);
	l1:	/* end fetchStackPointerOf: */;
	} else {
		stSize = totalLength - fixedFields;
	}
	if (((((usqInt) index)) >= (((usqInt) 1))) && ((((usqInt) index)) <= (((usqInt) stSize)))) {
		/* begin subscript:with:format: */
		if (fmt <= 4) {
			return longAt((array + (BASE_HEADER_SIZE)) + (((index + fixedFields) - 1) << (SHIFT_FOR_WORD)));
		}
		if (fmt < 8) {
			return positive32BitIntegerFor(long32At((array + (BASE_HEADER_SIZE)) + (((index + fixedFields) - 1) << 2)));
		} else {
			return (((byteAt((array + (BASE_HEADER_SIZE)) + ((index + fixedFields) - 1))) << 1) | 1);
		}
		return null;
	} else {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		return 0;
	}
	return null;
}


/*	Do what ST would return for <obj> at: index put: value. */

sqInt stObjectatput(sqInt array, sqInt index, sqInt value) {
    sqInt fixedFields;
    sqInt fmt;
    sqInt hdr;
    sqInt stSize;
    sqInt totalLength;
    sqInt sp;
    sqInt sz;
    sqInt class;
    sqInt classFormat;
    sqInt valueToStore;
    sqInt ccIndex;
    sqInt oop1;

	hdr = longAt(array);
	fmt = (((usqInt) hdr) >> 8) & 15;
	/* begin lengthOf:baseHeader:format: */
	if ((hdr & TypeMask) == HeaderTypeSizeAndClass) {
		sz = (longAt(array - ((BYTES_PER_WORD) * 2))) & (LONG_SIZE_MASK);
	} else {
		sz = hdr & (SIZE_MASK);
	}
	sz -= hdr & (SIZE_4_BIT);
	if (fmt <= 4) {
		totalLength = ((usqInt) (sz - (BASE_HEADER_SIZE))) >> (SHIFT_FOR_WORD);
		goto l2;
	}
	if (fmt < 8) {
		totalLength = ((usqInt) (sz - (BASE_HEADER_SIZE))) >> 2;
		goto l2;
	} else {
		totalLength = (sz - (BASE_HEADER_SIZE)) - (fmt & 3);
		goto l2;
	}
l2:	/* end lengthOf:baseHeader:format: */;
	/* begin fixedFieldsOf:format:length: */
	if ((fmt > 4) || (fmt == 2)) {
		fixedFields = 0;
		goto l3;
	}
	if (fmt < 2) {
		fixedFields = totalLength;
		goto l3;
	}
	/* begin fetchClassOf: */
	if ((array & 1)) {
		class = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassInteger << (SHIFT_FOR_WORD)));
		goto l4;
	}
	ccIndex = (((usqInt) (longAt(array))) >> 12) & 31;
	if (ccIndex == 0) {
		class = (longAt(array - (BASE_HEADER_SIZE))) & (ALL_BUT_TYPE_MASK);
		goto l4;
	} else {
		/* begin fetchPointer:ofObject: */
		oop1 = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (CompactClasses << (SHIFT_FOR_WORD)));
		class = longAt((oop1 + (BASE_HEADER_SIZE)) + ((ccIndex - 1) << (SHIFT_FOR_WORD)));
		goto l4;
	}
l4:	/* end fetchClassOf: */;
	classFormat = (longAt((class + (BASE_HEADER_SIZE)) + (InstanceSpecificationIndex << (SHIFT_FOR_WORD)))) - 1;
	fixedFields = (((((usqInt) classFormat) >> 11) & 192) + ((((usqInt) classFormat) >> 2) & 63)) - 1;
l3:	/* end fixedFieldsOf:format:length: */;
	if ((fmt == 3) && ((((((usqInt) hdr) >> 12) & 31) == 13) || ((((((usqInt) hdr) >> 12) & 31) == 14) || (((((usqInt) hdr) >> 12) & 31) == 4)))) {
		/* begin fetchStackPointerOf: */
		sp = longAt((array + (BASE_HEADER_SIZE)) + (StackPointerIndex << (SHIFT_FOR_WORD)));
		if (!((sp & 1))) {
			stSize = 0;
			goto l1;
		}
		stSize = (sp >> 1);
	l1:	/* end fetchStackPointerOf: */;
	} else {
		stSize = totalLength - fixedFields;
	}
	if (((((usqInt) index)) >= (((usqInt) 1))) && ((((usqInt) index)) <= (((usqInt) stSize)))) {
		/* begin subscript:with:storing:format: */
		if (fmt <= 4) {
			/* begin storePointer:ofObject:withValue: */
			if ((((usqInt) array)) < (((usqInt) youngStart))) {
				possibleRootStoreIntovalue(array, value);
			}
			longAtput((array + (BASE_HEADER_SIZE)) + (((index + fixedFields) - 1) << (SHIFT_FOR_WORD)), value);
		} else {
			if (fmt < 8) {
				valueToStore = positive32BitValueOf(value);
				if (!primFailCode) {
					long32Atput((array + (BASE_HEADER_SIZE)) + (((index + fixedFields) - 1) << 2), valueToStore);
				}
			} else {
				if (!((value & 1))) {
					/* begin primitiveFail */
					if (primFailCode == 0) {
						primFailCode = 1;
					}
				}
				valueToStore = (value >> 1);
				if (!((valueToStore >= 0) && (valueToStore <= 255))) {
					/* begin primitiveFail */
					if (primFailCode == 0) {
						primFailCode = 1;
					}
				}
				if (!primFailCode) {
					byteAtput((array + (BASE_HEADER_SIZE)) + ((index + fixedFields) - 1), valueToStore);
				}
			}
		}
	} else {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
	}
	return null;
}


/*	Return the number of indexable fields in the given object. (i.e., what Smalltalk would return for <obj> size). */
/*	Note: Assume oop is not a SmallInteger! */

sqInt stSizeOf(sqInt oop) {
    sqInt fixedFields;
    sqInt fmt;
    sqInt hdr;
    sqInt totalLength;
    sqInt sp;
    sqInt sz;
    sqInt class;
    sqInt classFormat;
    sqInt ccIndex;
    sqInt oop1;

	hdr = longAt(oop);
	fmt = (((usqInt) hdr) >> 8) & 15;
	/* begin lengthOf:baseHeader:format: */
	if ((hdr & TypeMask) == HeaderTypeSizeAndClass) {
		sz = (longAt(oop - ((BYTES_PER_WORD) * 2))) & (LONG_SIZE_MASK);
	} else {
		sz = hdr & (SIZE_MASK);
	}
	sz -= hdr & (SIZE_4_BIT);
	if (fmt <= 4) {
		totalLength = ((usqInt) (sz - (BASE_HEADER_SIZE))) >> (SHIFT_FOR_WORD);
		goto l1;
	}
	if (fmt < 8) {
		totalLength = ((usqInt) (sz - (BASE_HEADER_SIZE))) >> 2;
		goto l1;
	} else {
		totalLength = (sz - (BASE_HEADER_SIZE)) - (fmt & 3);
		goto l1;
	}
l1:	/* end lengthOf:baseHeader:format: */;
	/* begin fixedFieldsOf:format:length: */
	if ((fmt > 4) || (fmt == 2)) {
		fixedFields = 0;
		goto l2;
	}
	if (fmt < 2) {
		fixedFields = totalLength;
		goto l2;
	}
	/* begin fetchClassOf: */
	if ((oop & 1)) {
		class = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassInteger << (SHIFT_FOR_WORD)));
		goto l3;
	}
	ccIndex = (((usqInt) (longAt(oop))) >> 12) & 31;
	if (ccIndex == 0) {
		class = (longAt(oop - (BASE_HEADER_SIZE))) & (ALL_BUT_TYPE_MASK);
		goto l3;
	} else {
		/* begin fetchPointer:ofObject: */
		oop1 = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (CompactClasses << (SHIFT_FOR_WORD)));
		class = longAt((oop1 + (BASE_HEADER_SIZE)) + ((ccIndex - 1) << (SHIFT_FOR_WORD)));
		goto l3;
	}
l3:	/* end fetchClassOf: */;
	classFormat = (longAt((class + (BASE_HEADER_SIZE)) + (InstanceSpecificationIndex << (SHIFT_FOR_WORD)))) - 1;
	fixedFields = (((((usqInt) classFormat) >> 11) & 192) + ((((usqInt) classFormat) >> 2) & 63)) - 1;
l2:	/* end fixedFieldsOf:format:length: */;
	if ((fmt == 3) && ((((((usqInt) hdr) >> 12) & 31) == 13) || ((((((usqInt) hdr) >> 12) & 31) == 14) || (((((usqInt) hdr) >> 12) & 31) == 4)))) {
		/* begin fetchStackPointerOf: */
		sp = longAt((oop + (BASE_HEADER_SIZE)) + (StackPointerIndex << (SHIFT_FOR_WORD)));
		if (!((sp & 1))) {
			return 0;
		}
		return (sp >> 1);
	} else {
		return totalLength - fixedFields;
	}
	return null;
}


/*	Note: May be called by translated primitive code. */

double stackFloatValue(sqInt offset) {
    sqInt floatPointer;
    double  result;

	floatPointer = longAt(stackPointer - (offset * (BYTES_PER_WORD)));
	if (!((fetchClassOf(floatPointer)) == (longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (ClassFloat << (SHIFT_FOR_WORD)))))) {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		return 0.0;
	}
	;
	fetchFloatAtinto(floatPointer + (BASE_HEADER_SIZE), result);
	return result;
}

sqInt stackIntegerValue(sqInt offset) {
    sqInt integerPointer;

	integerPointer = longAt(stackPointer - (offset * (BYTES_PER_WORD)));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		return (integerPointer >> 1);
	} else {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		return 0;
	}
	return null;
}


/*	Ensures that the given object is a real object, not a SmallInteger. */

sqInt stackObjectValue(sqInt offset) {
    sqInt oop;

	oop = longAt(stackPointer - (offset * (BYTES_PER_WORD)));
	if ((oop & 1)) {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
		return null;
	}
	return oop;
}

sqInt stackTop(void) {
	return longAt(stackPointer);
}

sqInt stackValue(sqInt offset) {
	return longAt(stackPointer - (offset * (BYTES_PER_WORD)));
}


/*	Note: May be called by translated primitive code. */

sqInt storeIntegerofObjectwithValue(sqInt fieldIndex, sqInt objectPointer, sqInt integerValue) {
	if (
# ifdef SQ_HOST32  // cast to int for 64 bit image on 32 bit host
		(((((int) integerValue)) ^ ((((int) integerValue)) << 1)) >= 0)
# else
		((integerValue >= -1073741824) && (integerValue <= 1073741823))
# endif  // SQ_HOST32
	) {
		longAtput((objectPointer + (BASE_HEADER_SIZE)) + (fieldIndex << (SHIFT_FOR_WORD)), ((integerValue << 1) | 1));
	} else {
		/* begin primitiveFail */
		if (primFailCode == 0) {
			primFailCode = 1;
		}
	}
	return null;
}


/*	Note must check here for stores of young objects into old ones. */

sqInt storePointerofObjectwithValue(sqInt fieldIndex, sqInt oop, sqInt valuePointer) {
	if ((((usqInt) oop)) < (((usqInt) youngStart))) {
		possibleRootStoreIntovalue(oop, valuePointer);
	}
	return longAtput((oop + (BASE_HEADER_SIZE)) + (fieldIndex << (SHIFT_FOR_WORD)), valuePointer);
}


/*	Set the state of the primitive failure code/success flag, iff successBoolean
	 is false. If primFailCode is non-zero a primitive has failed.  If primFailCode
	 is greater than one then its value indicates the reason for failure. */
/*	Use returnTypeC: #sqInt because that's the way it is defined in sq.h.
	 Use no explicit return so that Slang doesn't fail an inlin ingtype-check when
	 a primitive with return type void uses ^self success: false to exit. */

sqInt success(sqInt successBoolean) {
	if (!(successBoolean)) {

		/* Don't overwrite an error code that has already been set. */

		if (!primFailCode) {
			primFailCode = 1;
		}
	}
	return null;
}


/*	Answer the state of the primitive failure code/success flag.  If
	 primFailCode is non-zero a primitive has failed.  If primFailCode
	 is greater than one then its value indicates the reason for failure. */
/*	In C, non-zero is true, so avoid computation by using not the C version. */

sqInt successful(void) {
	return !primFailCode;
}


/*	Return true if there is enough free space after doing a garbage collection. If not, signal that space is low. */

sqInt sufficientSpaceAfterGC(usqInt minFree) {
    usqInt growSize;
    usqInt minFreePlus;
    sqInt oldLimit;
    sqInt anOop;

	incrementalGC();
	if (oopisLessThan((longAt(freeBlock)) & (ALL_BUT_TYPE_MASK), minFree)) {
		if (signalLowSpace) {
			return 0;
		}
		fullGC();
		minFreePlus = minFree + 15000;
		if (minFreePlus < minFree) {
			return 0;
		}
		if (oopisGreaterThanOrEqualTo((longAt(freeBlock)) & (ALL_BUT_TYPE_MASK), minFreePlus)) {
			return 1;
		}
			while (1) {
			oldLimit = memoryLimit;
			growSize = (minFree - ((longAt(freeBlock)) & (ALL_BUT_TYPE_MASK))) + growHeadroom;
			growObjectMemory(growSize);
			/* begin oop:isGreaterThanOrEqualTo: */
			anOop = (longAt(freeBlock)) & (ALL_BUT_TYPE_MASK);
			if ((((usqInt) anOop)) >= (((usqInt) minFreePlus))) break;

			/* If the memoryLimit doesn't change then presumably the platform can't grow anymore. */

			if (oldLimit == memoryLimit) {
				return 0;
			}
		}
	}
	return 1;
}


/*	Return true if there is enough space to allocate the given number of bytes,
	perhaps after doing a garbage collection. Sender is responsible for ensuring
	that requested size does result in arithmetic overflow, see note below. */

sqInt sufficientSpaceToAllocate(usqInt bytes) {
    usqInt minFree;


	/* Note: Arithmetic overflow may occur in calculation of minFree (indicated by
	minFree < bytes after calculation of minFree). The check is performed by sender
	to avoid redundant test here. */


	/* check for low-space */

	minFree = (lowSpaceThreshold + bytes) + (BASE_HEADER_SIZE);
	if (oopisGreaterThanOrEqualTo((longAt(freeBlock)) & (ALL_BUT_TYPE_MASK), minFree)) {
		return 1;
	} else {
		return sufficientSpaceAfterGC(minFree);
	}
	return null;
}

sqInt superclassOf(sqInt classPointer) {
	return longAt((classPointer + (BASE_HEADER_SIZE)) + (SuperclassIndex << (SHIFT_FOR_WORD)));
}


/*	Sweep memory from youngStart through the end of memory. Free all 
	inaccessible objects and coalesce adjacent free chunks. Clear the mark 
	bits of accessible objects. Compute the starting point for the first pass of 
	incremental compaction (compStart). Return the number of surviving 
	objects.  */
/*	Details: Each time a non-free object is encountered, decrement the 
	number of available forward table entries. If all entries are spoken for 
	(i.e., entriesAvailable reaches zero), set compStart to the last free 
	chunk before that object or, if there is no free chunk before the given 
	object, the first free chunk after it. Thus, at the end of the sweep 
	phase, compStart through compEnd spans the highest collection of 
	non-free objects that can be accomodated by the forwarding table. This 
	information is used by the first pass of incremental compaction to 
	ensure that space is initially freed at the end of memory. Note that 
	there should always be at least one free chunk--the one at the end of 
	the heap. */

sqInt sweepPhase(void) {
    usqInt endOfMemoryLocal;
    sqInt entriesAvailable;
    sqInt firstFree;
    sqInt freeChunk;
    sqInt freeChunkSize;
    sqInt hdrBytes;
    usqInt oop;
    sqInt oopHeader;
    sqInt oopHeaderType;
    sqInt oopSize;
    sqInt survivors;

	entriesAvailable = fwdTableInit((BYTES_PER_WORD) * 2);
	survivors = 0;

	/* an invalid object pointer, note that 0 may refer to a meaningful slot */

	freeChunk = -1;

	/* will be updated later */

	firstFree = -1;
	endOfMemoryLocal = endOfMemory;
	oop = youngStart + (headerTypeBytes[(longAt(youngStart)) & TypeMask]);
	while (oop < endOfMemoryLocal) {

		/* get oop's header, header type, size, and header size */

		statSweepCount += 1;
		oopHeader = longAt(oop);
		oopHeaderType = oopHeader & TypeMask;
		hdrBytes = headerTypeBytes[oopHeaderType];
		if ((oopHeaderType & 1) == 1) {
			oopSize = oopHeader & (SIZE_MASK);
		} else {
			if (oopHeaderType == HeaderTypeSizeAndClass) {
				oopSize = (longAt(oop - ((BYTES_PER_WORD) * 2))) & (LONG_SIZE_MASK);
			} else {

				/* free chunk */

				oopSize = oopHeader & (LONG_SIZE_MASK);
			}
		}
		if ((oopHeader & (MARK_BIT)) == 0) {

			/* object is not marked; free it */
			/* <-- Finalization support: We need to mark each oop chunk as free --> */

			longAtput(oop - hdrBytes, HeaderTypeFree);
			if (freeChunk != -1) {

				/* enlarge current free chunk to include this oop */

				freeChunkSize = (freeChunkSize + oopSize) + hdrBytes;
			} else {

				/* start a new free chunk */


				/* chunk may start 4 or 8 bytes before oop */

				freeChunk = oop - hdrBytes;

				/* adjust size for possible extra header bytes */

				freeChunkSize = oopSize + (oop - freeChunk);
				if (firstFree == -1) {
					firstFree = freeChunk;
				}
			}
		} else {

			/* object is marked; clear its mark bit and possibly adjust 
					the compaction start */

			longAtput(oop, oopHeader & (ALL_BUT_MARK_BIT));
			if (((((usqInt) (longAt(oop))) >> 8) & 15) == 4) {
				finalizeReference(oop);
			}
			if (entriesAvailable > 0) {
				entriesAvailable -= 1;
			} else {

				/* start compaction at the last free chunk before this object */

				firstFree = freeChunk;
			}
			if (freeChunk != -1) {

				/* record the size of the last free chunk */

				longAtput(freeChunk, (freeChunkSize & (LONG_SIZE_MASK)) | HeaderTypeFree);
				freeChunk = -1;
			}
			survivors += 1;
		}
		oop = (oop + oopSize) + (headerTypeBytes[(longAt(oop + oopSize)) & TypeMask]);
	}
	if (freeChunk != -1) {

		/* record size of final free chunk */

		longAtput(freeChunk, (freeChunkSize & (LONG_SIZE_MASK)) | HeaderTypeFree);
	}
	if (!(oop == endOfMemory)) {
		error("sweep failed to find exact end of memory");
	}
	if (firstFree == -1) {
		error("expected to find at least one free object");
	} else {
		compStart = firstFree;
	}
	return survivors;
}


/*	Signal the given semaphore from within the interpreter. */

sqInt synchronousSignal(sqInt aSemaphore) {
    sqInt excessSignals;

	if ((longAt((aSemaphore + (BASE_HEADER_SIZE)) + (FirstLinkIndex << (SHIFT_FOR_WORD)))) == nilObj) {

		/* no process is waiting on this semaphore */

		excessSignals = fetchIntegerofObject(ExcessSignalsIndex, aSemaphore);
		/* begin storeInteger:ofObject:withValue: */
		if (
# ifdef SQ_HOST32  // cast to int for 64 bit image on 32 bit host
			(((((int) (excessSignals + 1))) ^ ((((int) (excessSignals + 1))) << 1)) >= 0)
# else
			(((excessSignals + 1) >= -1073741824) && ((excessSignals + 1) <= 1073741823))
# endif  // SQ_HOST32
		) {
			longAtput((aSemaphore + (BASE_HEADER_SIZE)) + (ExcessSignalsIndex << (SHIFT_FOR_WORD)), (((excessSignals + 1) << 1) | 1));
		} else {
			/* begin primitiveFail */
			if (primFailCode == 0) {
				primFailCode = 1;
			}
		}
	} else {
		resume(removeFirstLinkOfList(aSemaphore));
	}
	return null;
}


/*	Do an incremental GC that tenures all surviving young objects to old space. */

sqInt tenuringIncrementalGC(void) {
	forceTenureFlag = 1;
	incrementalGC();
	return null;
}


/*	Returns the top of the remappable oop. Useful when writing loops. */

sqInt topRemappableOop(void) {
	return remapBuffer[remapBufferCount];
}


/*	Record a process to be awoken on the next interpreter cycle. 
	ikp 11/24/1999 06:07 -- added hook for external runtime 
	compiler  */

sqInt transferTo(sqInt aProc) {
    sqInt newProc;
    sqInt oldProc;
    sqInt sched;
    sqInt oop;
    sqInt aContext;
    sqInt tmp;
    sqInt valuePointer;

	newProc = aProc;
	/* begin fetchPointer:ofObject: */
	oop = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (SchedulerAssociation << (SHIFT_FOR_WORD)));
	sched = longAt((oop + (BASE_HEADER_SIZE)) + (ValueIndex << (SHIFT_FOR_WORD)));
	oldProc = longAt((sched + (BASE_HEADER_SIZE)) + (ActiveProcessIndex << (SHIFT_FOR_WORD)));
	/* begin storePointer:ofObject:withValue: */
	if ((((usqInt) sched)) < (((usqInt) youngStart))) {
		possibleRootStoreIntovalue(sched, newProc);
	}
	longAtput((sched + (BASE_HEADER_SIZE)) + (ActiveProcessIndex << (SHIFT_FOR_WORD)), newProc);
	if (compilerInitialized) {
		compilerProcessChangeto(oldProc, newProc);
	} else {
		/* begin storePointer:ofObject:withValue: */
		if ((((usqInt) oldProc)) < (((usqInt) youngStart))) {
			possibleRootStoreIntovalue(oldProc, (sqInt)activeContext);
		}
		longAtput((oldProc + (BASE_HEADER_SIZE)) + (SuspendedContextIndex << (SHIFT_FOR_WORD)), activeContext);
		/* begin newActiveContext: */
		aContext = longAt((newProc + (BASE_HEADER_SIZE)) + (SuspendedContextIndex << (SHIFT_FOR_WORD)));
		/* begin storeContextRegisters: */
		longAtput((activeContext + (BASE_HEADER_SIZE)) + (InstructionPointerIndex << (SHIFT_FOR_WORD)), ((((instructionPointer - method) - ((BASE_HEADER_SIZE) - 2)) << 1) | 1));
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer = (((((((usqInt) ((stackPointer - activeContext) - (BASE_HEADER_SIZE))) >> (SHIFT_FOR_WORD)) - TempFrameStart) + 1) << 1) | 1);
		longAtput((activeContext + (BASE_HEADER_SIZE)) + (StackPointerIndex << (SHIFT_FOR_WORD)), valuePointer);
		if ((((usqInt) aContext)) < (((usqInt) youngStart))) {
			beRootIfOld(aContext);
		}
		activeContext = aContext;
		/* begin fetchContextRegisters: */
		tmp = longAt((aContext + (BASE_HEADER_SIZE)) + (MethodIndex << (SHIFT_FOR_WORD)));
		if ((tmp & 1)) {
			tmp = longAt((aContext + (BASE_HEADER_SIZE)) + (HomeIndex << (SHIFT_FOR_WORD)));
			if ((((usqInt) tmp)) < (((usqInt) youngStart))) {
				beRootIfOld(tmp);
			}
		} else {
			tmp = aContext;
		}
		theHomeContext = tmp;
		receiver = longAt((tmp + (BASE_HEADER_SIZE)) + (ReceiverIndex << (SHIFT_FOR_WORD)));
		method = (usqInt)longAt((tmp + (BASE_HEADER_SIZE)) + (MethodIndex << (SHIFT_FOR_WORD)));
		tmp = ((longAt((aContext + (BASE_HEADER_SIZE)) + (InstructionPointerIndex << (SHIFT_FOR_WORD)))) >> 1);
		instructionPointer = (usqInt)((method + tmp) + (BASE_HEADER_SIZE)) - 2;
		tmp = ((longAt((aContext + (BASE_HEADER_SIZE)) + (StackPointerIndex << (SHIFT_FOR_WORD)))) >> 1);
		stackPointer = (usqInt)(aContext + (BASE_HEADER_SIZE)) + (((TempFrameStart + tmp) - 1) * (BYTES_PER_WORD));
		/* begin storePointer:ofObject:withValue: */
		if ((((usqInt) newProc)) < (((usqInt) youngStart))) {
			possibleRootStoreIntovalue(newProc, nilObj);
		}
		longAtput((newProc + (BASE_HEADER_SIZE)) + (SuspendedContextIndex << (SHIFT_FOR_WORD)), nilObj);
	}
	reclaimableContextCount = 0;
	return null;
}

sqInt trueObject(void) {
	return trueObj;
}


/*	update pointers in the given memory range */

sqInt updatePointersInRangeFromto(sqInt memStart, sqInt memEnd) {
    sqInt oop;
    sqInt fwdBlock;
    sqInt header;
    sqInt realHeader;
    sqInt sz;
    sqInt fieldOffset;
    sqInt fieldOop;
    sqInt fwdBlock3;
    sqInt newOop;
    sqInt contextSize;
    sqInt fmt;
    sqInt fwdBlock1;
    sqInt header1;
    sqInt methodHeader;
    sqInt size;
    sqInt sp;
    sqInt classHeader;
    sqInt classOop;
    sqInt fwdBlock2;
    sqInt newClassHeader;
    sqInt newClassOop;
    sqInt sz1;
    sqInt header2;

	oop = memStart + (headerTypeBytes[(longAt(memStart)) & TypeMask]);
	while ((((usqInt) oop)) < (((usqInt) memEnd))) {
		if (!(((longAt(oop)) & TypeMask) == HeaderTypeFree)) {
			/* begin remapFieldsAndClassOf: */
			/* begin lastPointerWhileForwarding: */
			header1 = longAt(oop);
			if ((header1 & (MARK_BIT)) != 0) {
				fwdBlock1 = (header1 & (ALL_BUT_MARK_BIT_AND_TYPE_MASK)) << 1;
				if (DoAssertionChecks) {
					/* begin fwdBlockValidate: */
					if (!(((((usqInt) fwdBlock1)) > (((usqInt) endOfMemory))) && (((((usqInt) fwdBlock1)) <= (((usqInt) fwdTableNext))) && ((fwdBlock1 & 3) == 0)))) {
						error("invalid fwd table entry");
					}
				}
				header1 = longAt(fwdBlock1 + (BYTES_PER_WORD));
			}
			fmt = (((usqInt) header1) >> 8) & 15;
			if (fmt <= 4) {
				if ((fmt == 3) && ((((((usqInt) header1) >> 12) & 31) == 13) || ((((((usqInt) header1) >> 12) & 31) == 14) || (((((usqInt) header1) >> 12) & 31) == 4)))) {
					/* begin fetchStackPointerOf: */
					sp = longAt((oop + (BASE_HEADER_SIZE)) + (StackPointerIndex << (SHIFT_FOR_WORD)));
					if (!((sp & 1))) {
						contextSize = 0;
						goto l4;
					}
					contextSize = (sp >> 1);
				l4:	/* end fetchStackPointerOf: */;
					fieldOffset = (CtxtTempFrameStart + contextSize) * (BYTES_PER_WORD);
					goto l2;
				}
				if ((header1 & TypeMask) == HeaderTypeSizeAndClass) {
					size = (longAt(oop - ((BYTES_PER_WORD) * 2))) & (ALL_BUT_TYPE_MASK);
				} else {
					size = header1 & (SIZE_MASK);
				}
				fieldOffset = size - (BASE_HEADER_SIZE);
				goto l2;
			}
			if (fmt < 12) {
				fieldOffset = 0;
				goto l2;
			}
			methodHeader = longAt(oop + (BASE_HEADER_SIZE));
			fieldOffset = (((((usqInt) methodHeader) >> 10) & 255) * (BYTES_PER_WORD)) + (BASE_HEADER_SIZE);
		l2:	/* end lastPointerWhileForwarding: */;
			while (fieldOffset >= (BASE_HEADER_SIZE)) {
				fieldOop = longAt(oop + fieldOffset);
				if (((fieldOop & 1) == 0) && (((longAt(fieldOop)) & (MARK_BIT)) != 0)) {
					fwdBlock3 = ((longAt(fieldOop)) & (ALL_BUT_MARK_BIT_AND_TYPE_MASK)) << 1;
					if (DoAssertionChecks) {
						/* begin fwdBlockValidate: */
						if (!(((((usqInt) fwdBlock3)) > (((usqInt) endOfMemory))) && (((((usqInt) fwdBlock3)) <= (((usqInt) fwdTableNext))) && ((fwdBlock3 & 3) == 0)))) {
							error("invalid fwd table entry");
						}
					}
					newOop = longAt(fwdBlock3);
					longAtput(oop + fieldOffset, newOop);
					if (((((usqInt) oop)) < (((usqInt) youngStart))) && ((((usqInt) newOop)) >= (((usqInt) youngStart)))) {
						beRootWhileForwarding(oop);
					}
				}
				fieldOffset -= BYTES_PER_WORD;
			}
			/* begin remapClassOf: */
			if (((longAt(oop)) & TypeMask) == HeaderTypeShort) {
				goto l3;
			}
			classHeader = longAt(oop - (BYTES_PER_WORD));
			classOop = classHeader & (ALL_BUT_TYPE_MASK);
			if (((classOop & 1) == 0) && (((longAt(classOop)) & (MARK_BIT)) != 0)) {
				fwdBlock2 = ((longAt(classOop)) & (ALL_BUT_MARK_BIT_AND_TYPE_MASK)) << 1;
				if (DoAssertionChecks) {
					/* begin fwdBlockValidate: */
					if (!(((((usqInt) fwdBlock2)) > (((usqInt) endOfMemory))) && (((((usqInt) fwdBlock2)) <= (((usqInt) fwdTableNext))) && ((fwdBlock2 & 3) == 0)))) {
						error("invalid fwd table entry");
					}
				}
				newClassOop = longAt(fwdBlock2);
				newClassHeader = newClassOop | (classHeader & TypeMask);
				longAtput(oop - (BYTES_PER_WORD), newClassHeader);
				if (((((usqInt) oop)) < (((usqInt) youngStart))) && ((((usqInt) newClassOop)) >= (((usqInt) youngStart)))) {
					beRootWhileForwarding(oop);
				}
			}
		l3:	/* end remapClassOf: */;
		}
		/* begin objectAfterWhileForwarding: */
		header = longAt(oop);
		if ((header & (MARK_BIT)) == 0) {
			/* begin objectAfter: */
			if (DoAssertionChecks) {
				if ((((usqInt) oop)) >= (((usqInt) endOfMemory))) {
					error("no objects after the end of memory");
				}
			}
			if (((longAt(oop)) & TypeMask) == HeaderTypeFree) {
				sz1 = (longAt(oop)) & (ALL_BUT_TYPE_MASK);
			} else {
				/* begin sizeBitsOf: */
				header2 = longAt(oop);
				if ((header2 & TypeMask) == HeaderTypeSizeAndClass) {
					sz1 = (longAt(oop - ((BYTES_PER_WORD) * 2))) & (LONG_SIZE_MASK);
					goto l5;
				} else {
					sz1 = header2 & (SIZE_MASK);
					goto l5;
				}
			l5:	/* end sizeBitsOf: */;
			}
			oop = (oop + sz1) + (headerTypeBytes[(longAt(oop + sz1)) & TypeMask]);
			goto l1;
		}
		fwdBlock = (header & (ALL_BUT_MARK_BIT_AND_TYPE_MASK)) << 1;
		if (DoAssertionChecks) {
			/* begin fwdBlockValidate: */
			if (!(((((usqInt) fwdBlock)) > (((usqInt) endOfMemory))) && (((((usqInt) fwdBlock)) <= (((usqInt) fwdTableNext))) && ((fwdBlock & 3) == 0)))) {
				error("invalid fwd table entry");
			}
		}
		realHeader = longAt(fwdBlock + (BYTES_PER_WORD));
		if ((realHeader & TypeMask) == HeaderTypeSizeAndClass) {
			sz = (longAt(oop - ((BYTES_PER_WORD) * 2))) & (LONG_SIZE_MASK);
		} else {
			sz = realHeader & (SIZE_MASK);
		}
		oop = (oop + sz) + (headerTypeBytes[(longAt(oop + sz)) & TypeMask]);
	l1:	/* end objectAfterWhileForwarding: */;
	}
	return null;
}


/*	update pointers in root objects */

sqInt updatePointersInRootObjectsFromto(sqInt memStart, sqInt memEnd) {
    sqInt i;
    sqInt oop;
    sqInt fieldOffset;
    sqInt fieldOop;
    sqInt fwdBlock;
    sqInt newOop;
    sqInt contextSize;
    sqInt fmt;
    sqInt fwdBlock1;
    sqInt header;
    sqInt methodHeader;
    sqInt size;
    sqInt sp;
    sqInt classHeader;
    sqInt classOop;
    sqInt fwdBlock2;
    sqInt newClassHeader;
    sqInt newClassOop;

	for (i = 1; i <= rootTableCount; i += 1) {
		oop = rootTable[i];
		if (((((usqInt) oop)) < (((usqInt) memStart))) || ((((usqInt) oop)) >= (((usqInt) memEnd)))) {

			/* Note: must not remap the fields of any object twice! */
			/* remap this oop only if not in the memory range 
					covered below */

			/* begin remapFieldsAndClassOf: */
			/* begin lastPointerWhileForwarding: */
			header = longAt(oop);
			if ((header & (MARK_BIT)) != 0) {
				fwdBlock1 = (header & (ALL_BUT_MARK_BIT_AND_TYPE_MASK)) << 1;
				if (DoAssertionChecks) {
					/* begin fwdBlockValidate: */
					if (!(((((usqInt) fwdBlock1)) > (((usqInt) endOfMemory))) && (((((usqInt) fwdBlock1)) <= (((usqInt) fwdTableNext))) && ((fwdBlock1 & 3) == 0)))) {
						error("invalid fwd table entry");
					}
				}
				header = longAt(fwdBlock1 + (BYTES_PER_WORD));
			}
			fmt = (((usqInt) header) >> 8) & 15;
			if (fmt <= 4) {
				if ((fmt == 3) && ((((((usqInt) header) >> 12) & 31) == 13) || ((((((usqInt) header) >> 12) & 31) == 14) || (((((usqInt) header) >> 12) & 31) == 4)))) {
					/* begin fetchStackPointerOf: */
					sp = longAt((oop + (BASE_HEADER_SIZE)) + (StackPointerIndex << (SHIFT_FOR_WORD)));
					if (!((sp & 1))) {
						contextSize = 0;
						goto l1;
					}
					contextSize = (sp >> 1);
				l1:	/* end fetchStackPointerOf: */;
					fieldOffset = (CtxtTempFrameStart + contextSize) * (BYTES_PER_WORD);
					goto l2;
				}
				if ((header & TypeMask) == HeaderTypeSizeAndClass) {
					size = (longAt(oop - ((BYTES_PER_WORD) * 2))) & (ALL_BUT_TYPE_MASK);
				} else {
					size = header & (SIZE_MASK);
				}
				fieldOffset = size - (BASE_HEADER_SIZE);
				goto l2;
			}
			if (fmt < 12) {
				fieldOffset = 0;
				goto l2;
			}
			methodHeader = longAt(oop + (BASE_HEADER_SIZE));
			fieldOffset = (((((usqInt) methodHeader) >> 10) & 255) * (BYTES_PER_WORD)) + (BASE_HEADER_SIZE);
		l2:	/* end lastPointerWhileForwarding: */;
			while (fieldOffset >= (BASE_HEADER_SIZE)) {
				fieldOop = longAt(oop + fieldOffset);
				if (((fieldOop & 1) == 0) && (((longAt(fieldOop)) & (MARK_BIT)) != 0)) {
					fwdBlock = ((longAt(fieldOop)) & (ALL_BUT_MARK_BIT_AND_TYPE_MASK)) << 1;
					if (DoAssertionChecks) {
						/* begin fwdBlockValidate: */
						if (!(((((usqInt) fwdBlock)) > (((usqInt) endOfMemory))) && (((((usqInt) fwdBlock)) <= (((usqInt) fwdTableNext))) && ((fwdBlock & 3) == 0)))) {
							error("invalid fwd table entry");
						}
					}
					newOop = longAt(fwdBlock);
					longAtput(oop + fieldOffset, newOop);
					if (((((usqInt) oop)) < (((usqInt) youngStart))) && ((((usqInt) newOop)) >= (((usqInt) youngStart)))) {
						beRootWhileForwarding(oop);
					}
				}
				fieldOffset -= BYTES_PER_WORD;
			}
			/* begin remapClassOf: */
			if (((longAt(oop)) & TypeMask) == HeaderTypeShort) {
				goto l3;
			}
			classHeader = longAt(oop - (BYTES_PER_WORD));
			classOop = classHeader & (ALL_BUT_TYPE_MASK);
			if (((classOop & 1) == 0) && (((longAt(classOop)) & (MARK_BIT)) != 0)) {
				fwdBlock2 = ((longAt(classOop)) & (ALL_BUT_MARK_BIT_AND_TYPE_MASK)) << 1;
				if (DoAssertionChecks) {
					/* begin fwdBlockValidate: */
					if (!(((((usqInt) fwdBlock2)) > (((usqInt) endOfMemory))) && (((((usqInt) fwdBlock2)) <= (((usqInt) fwdTableNext))) && ((fwdBlock2 & 3) == 0)))) {
						error("invalid fwd table entry");
					}
				}
				newClassOop = longAt(fwdBlock2);
				newClassHeader = newClassOop | (classHeader & TypeMask);
				longAtput(oop - (BYTES_PER_WORD), newClassHeader);
				if (((((usqInt) oop)) < (((usqInt) youngStart))) && ((((usqInt) newClassOop)) >= (((usqInt) youngStart)))) {
					beRootWhileForwarding(oop);
				}
			}
		l3:	/* end remapClassOf: */;
		}
	}
	return null;
}


/*	Verify that every old object that points to a new object 
		has its root bit set, and
		appears in the rootTable.
	This method should not be called if the rootTable is full, because roots
	are no longer recorded, and incremental collections are not attempted.
	If DoAssertionChecks is true, this routine will halt on an unmarked root.
	Otherwise, this routine will merely return true in that case. */

sqInt validateRoots(void) {
    sqInt badRoot;
    usqInt fieldAddr;
    usqInt fieldOop;
    sqInt header;
    usqInt oop;
    sqInt sz;
    sqInt header1;

	badRoot = 0;
	oop = memory + (headerTypeBytes[(longAt(memory)) & TypeMask]);
	while (oop < youngStart) {
		if (!(((longAt(oop)) & TypeMask) == HeaderTypeFree)) {
			fieldAddr = oop + (lastPointerOf(oop));
			while (fieldAddr > oop) {
				fieldOop = longAt(fieldAddr);
				if ((fieldOop >= youngStart) && (!((fieldOop & 1)))) {

					/* fieldOop is a pointer to a young object */

					header = longAt(oop);
					if ((header & (ROOT_BIT)) == 0) {

						/* Forbidden: points to young obj but root bit not set. */

						if (DoAssertionChecks) {
							error("root bit not set");
						}
						badRoot = 1;
					} else {

						/* Root bit is set */
						/* Extreme test -- validate that oop was entered in rootTable too... */
						/* Disabled for now...
						found := false.
						1 to: rootTableCount do:
							[:i | oop = (rootTable at: i) ifTrue: [found := true]].
						found ifFalse:
							[DoAssertionChecks ifTrue: [self error: 'root table not set'].
							badRoot := true].
						... */

						null;
					}
				}
				fieldAddr -= BYTES_PER_WORD;
			}
		}
		/* begin objectAfter: */
		if (DoAssertionChecks) {
			if ((((usqInt) oop)) >= (((usqInt) endOfMemory))) {
				error("no objects after the end of memory");
			}
		}
		if (((longAt(oop)) & TypeMask) == HeaderTypeFree) {
			sz = (longAt(oop)) & (ALL_BUT_TYPE_MASK);
		} else {
			/* begin sizeBitsOf: */
			header1 = longAt(oop);
			if ((header1 & TypeMask) == HeaderTypeSizeAndClass) {
				sz = (longAt(oop - ((BYTES_PER_WORD) * 2))) & (LONG_SIZE_MASK);
				goto l1;
			} else {
				sz = header1 & (SIZE_MASK);
				goto l1;
			}
		l1:	/* end sizeBitsOf: */;
		}
		oop = (oop + sz) + (headerTypeBytes[(longAt(oop + sz)) & TypeMask]);
	}
	return badRoot;
}

sqInt verifyCleanHeaders(void) {
    sqInt oop;
    sqInt sz;
    sqInt header;

	oop = memory + (headerTypeBytes[(longAt(memory)) & TypeMask]);
	while ((((usqInt) oop)) < (((usqInt) endOfMemory))) {
		if (((longAt(oop)) & TypeMask) == HeaderTypeFree) {

			/* There should only be one free block at end of memory. */

			if (!((objectAfter(oop)) == endOfMemory)) {
				error("Invalid obj with HeaderTypeBits = Free.");
			}
		} else {
			if (((longAt(oop)) & (MARK_BIT)) != 0) {
				error("Invalid obj with MarkBit set.");
			}
		}
		/* begin objectAfter: */
		if (DoAssertionChecks) {
			if ((((usqInt) oop)) >= (((usqInt) endOfMemory))) {
				error("no objects after the end of memory");
			}
		}
		if (((longAt(oop)) & TypeMask) == HeaderTypeFree) {
			sz = (longAt(oop)) & (ALL_BUT_TYPE_MASK);
		} else {
			/* begin sizeBitsOf: */
			header = longAt(oop);
			if ((header & TypeMask) == HeaderTypeSizeAndClass) {
				sz = (longAt(oop - ((BYTES_PER_WORD) * 2))) & (LONG_SIZE_MASK);
				goto l1;
			} else {
				sz = header & (SIZE_MASK);
				goto l1;
			}
		l1:	/* end sizeBitsOf: */;
		}
		oop = (oop + sz) + (headerTypeBytes[(longAt(oop + sz)) & TypeMask]);
	}
	return null;
}


/*	return 0 for little endian, 1 for big endian */

sqInt vmEndianness(void) {
	if (isBigEnder()) {
		return 1;
	} else {
		return 0;
	}
	return null;
}


/*	Return the highest priority process that is ready to run. */
/*	Note: It is a fatal VM error if there is no runnable process. */

sqInt wakeHighestPriority(void) {
    sqInt p;
    sqInt processList;
    sqInt schedLists;
    sqInt oop;
    sqInt sz;
    sqInt header;
    sqInt oop1;

	/* begin fetchPointer:ofObject: */
	/* begin fetchPointer:ofObject: */
	oop1 = longAt((specialObjectsOop + (BASE_HEADER_SIZE)) + (SchedulerAssociation << (SHIFT_FOR_WORD)));
	oop = longAt((oop1 + (BASE_HEADER_SIZE)) + (ValueIndex << (SHIFT_FOR_WORD)));
	schedLists = longAt((oop + (BASE_HEADER_SIZE)) + (ProcessListsIndex << (SHIFT_FOR_WORD)));
	/* begin fetchWordLengthOf: */
	/* begin sizeBitsOf: */
	header = longAt(schedLists);
	if ((header & TypeMask) == HeaderTypeSizeAndClass) {
		sz = (longAt(schedLists - ((BYTES_PER_WORD) * 2))) & (LONG_SIZE_MASK);
		goto l1;
	} else {
		sz = header & (SIZE_MASK);
		goto l1;
	}
l1:	/* end sizeBitsOf: */;
	p = ((usqInt) (sz - (BASE_HEADER_SIZE))) >> (SHIFT_FOR_WORD);

	/* index of last indexable field */

	p -= 1;
	processList = longAt((schedLists + (BASE_HEADER_SIZE)) + (p << (SHIFT_FOR_WORD)));
	while ((longAt((processList + (BASE_HEADER_SIZE)) + (FirstLinkIndex << (SHIFT_FOR_WORD)))) == nilObj) {
		p -= 1;
		if (p < 0) {
			error("scheduler could not find a runnable process");
		}
		processList = longAt((schedLists + (BASE_HEADER_SIZE)) + (p << (SHIFT_FOR_WORD)));
	}
	return removeFirstLinkOfList(processList);
}


/*	Return the given 64-bit integer with its halves in the reverse order. */

sqInt wordSwapped(sqInt w) {
	
# if (BYTES_PER_WORD == 8)  // swap 32-bit ends of a 64-bit object word
	return ((((usqInt) w >> 32)) & Bytes3to0Mask) + ((((usqInt) w << 32)) & Bytes7to4Mask);
# else
	error("This cannot happen.");
# endif  // BYTES_PER_WORD == 8
	
	return null;
}

sqInt writeImageFile(sqInt imageBytes) {
    void *fn;

	writeImageFileIO(imageBytes);
	fn = ioLoadFunctionFrom("setMacFileTypeAndCreator", "FilePlugin");
	if (!(fn == 0)) {
		((sqInt (*)(char*, char*, char*))fn)(imageName, "STim", "FAST");
	}
	return null;
}

sqInt writeImageFileIO(sqInt imageBytes) {
    sqInt bytesWritten;
    sqImageFile f;
    sqInt headerSize;
    squeakFileOffsetType  headerStart;
    sqInt i;
    sqInt okToWrite;
    void *sCWIfn;


	/* If the security plugin can be loaded, use it to check for write permission.
	If not, assume it's ok */

	sCWIfn = ioLoadFunctionFrom("secCanWriteImage", "SecurityPlugin");
	if (sCWIfn != 0) {
		okToWrite = ((sqInt (*)(void))sCWIfn)();
		if (!(okToWrite)) {
			/* begin primitiveFail */
			if (primFailCode == 0) {
				primFailCode = 1;
			}
			return null;
		}
	}
	headerStart = 0;

	/* header size in bytes; do not change! */

	headerSize = 16 * (BYTES_PER_WORD);
	f = sqImageFileOpen(imageName, "wb");
	if (f == null) {

		/* could not open the image file for writing */

		/* begin success: */
		if (!(0)) {
			if (!primFailCode) {
				primFailCode = 1;
			}
		}
		return null;
	}
	headerStart = sqImageFileStartLocation(f,imageName,headerSize+imageBytes);
	/* Note: on Unix systems one could put an exec command here, padded to 512 bytes */;
	sqImageFileSeek(f, headerStart);
	putLongtoFile(imageFormatVersionNumber, f);
	putLongtoFile(headerSize, f);
	putLongtoFile(imageBytes, f);
	putLongtoFile((sqInt)memory, f);
	putLongtoFile(specialObjectsOop, f);
	putLongtoFile(lastHash, f);
	putLongtoFile(ioScreenSize(), f);
	putLongtoFile(fullScreenFlag, f);
	putLongtoFile(extraVMMemory, f);
	for (i = 1; i <= 7; i += 1) {
		putLongtoFile(0, f);
	}
	if (!(!primFailCode)) {

		/* file write or seek failure */

		sqImageFileClose(f);
		return null;
	}
	sqImageFileSeek(f, headerStart + headerSize);
	bytesWritten = sqImageFileWrite(pointerForOop(memory), sizeof(unsigned char), imageBytes, f);
	/* begin success: */
	if (!(bytesWritten == imageBytes)) {
		if (!primFailCode) {
			primFailCode = 1;
		}
	}
	sqImageFileClose(f);
	return null;
}


void* vm_exports[][3] = {
	{"", "primitiveAllObjects", (void*)primitiveAllObjects},
	{"", "addHighPriorityTickee", (void*)addHighPriorityTickee},
	{"", "primitiveDisablePowerManager", (void*)primitiveDisablePowerManager},
	{"", "removeGCRoot", (void*)removeGCRoot},
	{"", "primitiveSetGCSemaphore", (void*)primitiveSetGCSemaphore},
	{"", "printAllStacks", (void*)printAllStacks},
	{"", "addSynchronousTickee", (void*)addSynchronousTickee},
	{"", "reestablishContextPriorToCallback", (void*)reestablishContextPriorToCallback},
	{"", "primitiveRootTableAt", (void*)primitiveRootTableAt},
	{"", "primitiveLocalMicrosecondClock", (void*)primitiveLocalMicrosecondClock},
	{"", "primitiveIsRoot", (void*)primitiveIsRoot},
	{"", "primitiveDivideLargeIntegers", (void*)primitiveDivideLargeIntegers},
	{"", "primitiveUTCMicrosecondClock", (void*)primitiveUTCMicrosecondClock},
	{"", "primitiveRemLargeIntegers", (void*)primitiveRemLargeIntegers},
	{"", "readImageFormatFromFileStartingAt", (void*)readImageFormatFromFileStartingAt},
	{"", "primitiveEqualLargeIntegers", (void*)primitiveEqualLargeIntegers},
	{"", "amInVMThread", (void*)amInVMThread},
	{"", "primitiveQuoLargeIntegers", (void*)primitiveQuoLargeIntegers},
	{"", "getStackPointer", (void*)getStackPointer},
	{"", "callbackLeave", (void*)callbackLeave},
	{"", "primitiveSetGCBiasToGrowGCLimit", (void*)primitiveSetGCBiasToGrowGCLimit},
	{"", "primitiveMillisecondClockMask", (void*)primitiveMillisecondClockMask},
	{"", "primitiveRootTable", (void*)primitiveRootTable},
	{"", "primitiveDivLargeIntegers", (void*)primitiveDivLargeIntegers},
	{"", "internalIsMutable", (void*)internalIsMutable},
	{"", "primitiveChangeClassWithClass", (void*)primitiveChangeClassWithClass},
	{"", "primitiveAddLargeIntegers", (void*)primitiveAddLargeIntegers},
	{"", "primitiveGreaterOrEqualLargeIntegers", (void*)primitiveGreaterOrEqualLargeIntegers},
	{"", "ioUTCMicroseconds", (void*)ioUTCMicroseconds},
	{"", "primitiveMultiplyLargeIntegers", (void*)primitiveMultiplyLargeIntegers},
	{"", "moduleUnloaded", (void*)moduleUnloaded},
	{"", "primitiveBitAndLargeIntegers", (void*)primitiveBitAndLargeIntegers},
	{"", "callInterpreter", (void*)callInterpreter},
	{"", "primitiveModLargeIntegers", (void*)primitiveModLargeIntegers},
	{"", "primitivePlatformSourceVersion", (void*)primitivePlatformSourceVersion},
	{"", "sendInvokeCallbackStackRegistersJmpbuf", (void*)sendInvokeCallbackStackRegistersJmpbuf},
	{"", "primitiveScreenDepth", (void*)primitiveScreenDepth},
	{"", "primitiveNotEqualLargeIntegers", (void*)primitiveNotEqualLargeIntegers},
	{"", "primitiveMicrosecondClock", (void*)primitiveMicrosecondClock},
	{"", "primitiveLessOrEqualLargeIntegers", (void*)primitiveLessOrEqualLargeIntegers},
	{"", "primitiveBitShiftLargeIntegers", (void*)primitiveBitShiftLargeIntegers},
	{"", "extraHeaderBytes", (void*)extraHeaderBytes},
	{"", "primitiveVMVersion", (void*)primitiveVMVersion},
	{"", "primitiveGreaterThanLargeIntegers", (void*)primitiveGreaterThanLargeIntegers},
	{"", "primitiveIsYoung", (void*)primitiveIsYoung},
	{"", "primitiveBitXorLargeIntegers", (void*)primitiveBitXorLargeIntegers},
	{"", "primitiveSetGCBiasToGrow", (void*)primitiveSetGCBiasToGrow},
	{"", "primitiveLessThanLargeIntegers", (void*)primitiveLessThanLargeIntegers},
	{"", "internalIsImmutable", (void*)internalIsImmutable},
	{"", "primitiveImageFormatVersion", (void*)primitiveImageFormatVersion},
	{"", "primitiveUtcWithOffset", (void*)primitiveUtcWithOffset},
	{"", "dumpImage", (void*)dumpImage},
	{"", "primitiveSubtractLargeIntegers", (void*)primitiveSubtractLargeIntegers},
	{"", "callbackEnter", (void*)callbackEnter},
	{"", "primitiveBitOrLargeIntegers", (void*)primitiveBitOrLargeIntegers},
	{"", "primitiveTestShortenIndexableSize", (void*)primitiveTestShortenIndexableSize},
	{"", "addGCRoot", (void*)addGCRoot},
	{"", "primitiveForceTenure", (void*)primitiveForceTenure},
	{"", "primitiveInterpreterSourceVersion", (void*)primitiveInterpreterSourceVersion},
	{NULL, NULL, NULL}
};
